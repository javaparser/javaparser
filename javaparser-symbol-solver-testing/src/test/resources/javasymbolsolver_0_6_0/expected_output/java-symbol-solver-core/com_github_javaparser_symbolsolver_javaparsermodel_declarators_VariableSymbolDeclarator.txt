  Line 48) node.getClass() ==> java.lang.Object.getClass()
  Line 86) getVisibleFields().stream().filter(f -> f.getName().equals(name)) ==> java.util.stream.Stream.filter(java.util.function.Predicate<? super T>)
  Line 86) getVisibleFields().stream() ==> java.util.Collection.stream()
  Line 86) getVisibleFields() ==> com.github.javaparser.symbolsolver.model.declarations.ReferenceTypeDeclaration.getVisibleFields()
  Line 86) f.getName().equals(name) ==> java.lang.String.equals(java.lang.Object)
  Line 86) f.getName() ==> com.github.javaparser.symbolsolver.model.declarations.Declaration.getName()
  Line 87) field.isPresent() ==> java.util.Optional.isPresent()
  Line 107) compareConsideringTypeParameters(otherAncestor) ==> com.github.javaparser.symbolsolver.model.typesystem.ReferenceType.compareConsideringTypeParameters(com.github.javaparser.symbolsolver.model.typesystem.ReferenceType)
  Line 112) other.isTypeVariable() ==> com.github.javaparser.symbolsolver.model.typesystem.Type.isTypeVariable()
  Line 44) Collectors.toList() ==> java.util.stream.Collectors.toList()
  Line 88) field.get() ==> java.util.Optional.get()
  Line 53) node.getClass().getCanonicalName() ==> java.lang.Class.getCanonicalName()
  Line 113) other.asTypeVariable().asTypeParameter().getBounds(typeSolver) ==> ERROR
  Line 45) clazz.getSuperclass() ==> java.lang.Class.getSuperclass()
  Line 117) typeParameters.addAll(constructor.declaringType().getTypeParameters()) ==> java.util.List.addAll(java.util.Collection<? extends E>)
  Line 47) clazz.getSuperclass() ==> java.lang.Class.getSuperclass()
  Line 117) constructor.declaringType().getTypeParameters() ==> com.github.javaparser.symbolsolver.model.declarations.TypeParametrizable.getTypeParameters()
  Line 117) constructor.declaringType() ==> com.github.javaparser.symbolsolver.model.declarations.ConstructorDeclaration.declaringType()
  Line 119) MethodResolutionLogic.replaceTypeParam(expectedType, tp, typeSolver) ==> com.github.javaparser.symbolsolver.resolution.MethodResolutionLogic.replaceTypeParam(com.github.javaparser.symbolsolver.model.typesystem.Type, com.github.javaparser.symbolsolver.model.declarations.TypeParameterDeclaration, com.github.javaparser.symbolsolver.model.resolution.TypeSolver)
  Line 92) getParent() ==> com.github.javaparser.symbolsolver.javaparsermodel.contexts.AbstractJavaParserContext.getParent()
  Line 69) Optional.of((TypeDeclaration<?>) n) ==> java.util.Optional.of(T)
  Line 73) getInnerTypeName(qualifiedName) ==> com.github.javaparser.symbolsolver.javaparser.Navigator.getInnerTypeName(java.lang.String)
  Line 94) Optional.empty() ==> java.util.Optional.empty()
  Line 113) other.asTypeVariable().asTypeParameter() ==> com.github.javaparser.symbolsolver.model.typesystem.TypeVariable.asTypeParameter()
  Line 88) methodDeclaration.getTypeParameters().stream().filter(tp -> tp.getName().equals(name)) ==> java.util.stream.Stream.filter(java.util.function.Predicate<? super T>)
  Line 88) methodDeclaration.getTypeParameters().stream() ==> java.util.Collection.stream()
  Line 88) methodDeclaration.getTypeParameters() ==> com.github.javaparser.symbolsolver.model.declarations.TypeParametrizable.getTypeParameters()
  Line 52) clazz.getGenericInterfaces() ==> java.lang.Class.getGenericInterfaces()
  Line 96) parent.solveGenericType(name, typeSolver) ==> com.github.javaparser.symbolsolver.core.resolution.Context.solveGenericType(java.lang.String, com.github.javaparser.symbolsolver.model.resolution.TypeSolver)
  Line 51) packageName.isEmpty() ==> java.lang.String.isEmpty()
  Line 53) node.getClass() ==> java.lang.Object.getClass()
  Line 51) className.isEmpty() ==> java.lang.String.isEmpty()
  Line 122) expectedType.isAssignableBy(actualType) ==> com.github.javaparser.symbolsolver.model.typesystem.Type.isAssignableBy(com.github.javaparser.symbolsolver.model.typesystem.Type)
  Line 123) actualType.isWildcard() ==> com.github.javaparser.symbolsolver.model.typesystem.Type.isWildcard()
  Line 113) other.asTypeVariable() ==> com.github.javaparser.symbolsolver.model.typesystem.Type.asTypeVariable()
  Line 123) expectedType.isPrimitive() ==> com.github.javaparser.symbolsolver.model.typesystem.Type.isPrimitive()
  Line 127) constructor.hasVariadicParameter() ==> com.github.javaparser.symbolsolver.model.declarations.MethodLikeDeclaration.hasVariadicParameter()
  Line 127) constructor.getNumberOfParams() ==> com.github.javaparser.symbolsolver.model.declarations.MethodLikeDeclaration.getNumberOfParams()
  Line 128) new ArrayType(expectedType).isAssignableBy(actualType) ==> com.github.javaparser.symbolsolver.model.typesystem.ArrayType.isAssignableBy(com.github.javaparser.symbolsolver.model.typesystem.Type)
  Line 149) findMostApplicable(constructors, argumentsTypes, typeSolver, false) ==> com.github.javaparser.symbolsolver.resolution.ConstructorResolutionLogic.findMostApplicable(java.util.List<com.github.javaparser.symbolsolver.model.declarations.ConstructorDeclaration>, java.util.List<com.github.javaparser.symbolsolver.model.typesystem.Type>, com.github.javaparser.symbolsolver.model.resolution.TypeSolver, boolean)
  Line 74) type.isPresent() ==> java.util.Optional.isPresent()
  Line 74) innerTypeName.isEmpty() ==> java.lang.String.isEmpty()
  Line 150) res.isSolved() ==> com.github.javaparser.symbolsolver.model.resolution.SymbolReference.isSolved()
  Line 153) findMostApplicable(constructors, argumentsTypes, typeSolver, true) ==> com.github.javaparser.symbolsolver.resolution.ConstructorResolutionLogic.findMostApplicable(java.util.List<com.github.javaparser.symbolsolver.model.declarations.ConstructorDeclaration>, java.util.List<com.github.javaparser.symbolsolver.model.typesystem.Type>, com.github.javaparser.symbolsolver.model.resolution.TypeSolver, boolean)
  Line 114) bound.isExtends() ==> com.github.javaparser.symbolsolver.model.declarations.TypeParameterDeclaration.Bound.isExtends()
  Line 125) JavassistUtils.getMethodUsage(ctClass, name, argumentsTypes, typeSolver, invokationContext) ==> com.github.javaparser.symbolsolver.javassistmodel.JavassistUtils.getMethodUsage(javassist.CtClass, java.lang.String, java.util.List<com.github.javaparser.symbolsolver.model.typesystem.Type>, com.github.javaparser.symbolsolver.model.resolution.TypeSolver, com.github.javaparser.symbolsolver.core.resolution.Context)
  Line 33) Short.class.getCanonicalName() ==> java.lang.Class.getCanonicalName()
  Line 115) this.isAssignableBy(bound.getType()) ==> com.github.javaparser.symbolsolver.model.typesystem.ReferenceTypeImpl.isAssignableBy(com.github.javaparser.symbolsolver.model.typesystem.Type)
  Line 115) bound.getType() ==> com.github.javaparser.symbolsolver.model.declarations.TypeParameterDeclaration.Bound.getType()
  Line 130) ctClass.getDeclaredFields() ==> javassist.CtClass.getDeclaredFields()
  Line 121) other.isConstraint() ==> com.github.javaparser.symbolsolver.model.typesystem.Type.isConstraint()
  Line 57) ((CompilationUnit) container).getPackageDeclaration() ==> com.github.javaparser.ast.CompilationUnit.getPackageDeclaration()
  Line 88) tp.getName().equals(name) ==> java.lang.String.equals(java.lang.Object)
  Line 102) getParentNode(wrappedNode) ==> com.github.javaparser.symbolsolver.javaparser.Navigator.getParentNode(com.github.javaparser.ast.Node)
  Line 56) typeDeclaration.getAllMethods().stream().filter(m -> m.getDeclaration().isAbstract()).filter(m -> !declaredOnObject(m)) ==> java.util.stream.Stream.filter(java.util.function.Predicate<? super T>)
  Line 56) typeDeclaration.getAllMethods().stream().filter(m -> m.getDeclaration().isAbstract()) ==> java.util.stream.Stream.filter(java.util.function.Predicate<? super T>)
  Line 56) typeDeclaration.getAllMethods().stream() ==> java.util.Collection.stream()
  Line 33) ImmutableList.of(BYTE) ==> com.google.common.collect.ImmutableList.of(E)
  Line 98) this.getAllFields().stream().filter(f -> f.getName().equals(name)).findFirst().isPresent() ==> java.util.Optional.isPresent()
  Line 98) this.getAllFields().stream().filter(f -> f.getName().equals(name)).findFirst() ==> java.util.stream.Stream.findFirst()
  Line 98) this.getAllFields().stream().filter(f -> f.getName().equals(name)) ==> java.util.stream.Stream.filter(java.util.function.Predicate<? super T>)
  Line 98) this.getAllFields().stream() ==> java.util.Collection.stream()
  Line 98) this.getAllFields() ==> com.github.javaparser.symbolsolver.model.declarations.ReferenceTypeDeclaration.getAllFields()
  Line 98) f.getName().equals(name) ==> java.lang.String.equals(java.lang.Object)
  Line 34) Character.class.getCanonicalName() ==> java.lang.Class.getCanonicalName()
  Line 98) f.getName() ==> com.github.javaparser.symbolsolver.model.declarations.Declaration.getName()
  Line 88) tp.getName() ==> com.github.javaparser.symbolsolver.model.declarations.TypeParameterDeclaration.getName()
  Line 72) srcFile.getAbsolutePath() ==> java.io.File.getAbsolutePath()
  Line 56) typeDeclaration.getAllMethods() ==> com.github.javaparser.symbolsolver.model.declarations.ReferenceTypeDeclaration.getAllMethods()
  Line 57) m.getDeclaration().isAbstract() ==> com.github.javaparser.symbolsolver.model.declarations.MethodDeclaration.isAbstract()
  Line 57) m.getDeclaration() ==> com.github.javaparser.symbolsolver.model.methods.MethodUsage.getDeclaration()
  Line 58) p.isPresent() ==> java.util.Optional.isPresent()
  Line 58) node.getClass().getCanonicalName() ==> java.lang.Class.getCanonicalName()
  Line 59) p.get().getName().toString() ==> com.github.javaparser.ast.Node.toString()
  Line 59) p.get().getName() ==> com.github.javaparser.ast.PackageDeclaration.getName()
  Line 59) p.get() ==> java.util.Optional.get()
  Line 88) toType(tp) ==> com.github.javaparser.symbolsolver.declarations.common.MethodDeclarationCommonLogic.toType(com.github.javaparser.symbolsolver.model.declarations.TypeParameterDeclaration)
  Line 105) getVisibleFields().stream().filter(f -> f.getName().equals(name)).findFirst().isPresent() ==> java.util.Optional.isPresent()
  Line 105) getVisibleFields().stream().filter(f -> f.getName().equals(name)).findFirst() ==> java.util.stream.Stream.findFirst()
  Line 131) field.getName().equals(name) ==> java.lang.String.equals(java.lang.Object)
  Line 103) getParentNode(wrappedNode) ==> com.github.javaparser.symbolsolver.javaparser.Navigator.getParentNode(com.github.javaparser.ast.Node)
  Line 60) declaredOnObject(m) ==> com.github.javaparser.symbolsolver.logic.FunctionalInterfaceLogic.declaredOnObject(com.github.javaparser.symbolsolver.model.methods.MethodUsage)
  Line 61) Collectors.toSet() ==> java.util.stream.Collectors.toSet()
  Line 55) Arrays.stream(parameterizedType.getActualTypeArguments()).map((t) -> ReflectionFactory.typeUsageFor(t, typeSolver)).collect(Collectors.toList()) ==> java.util.stream.Stream.collect(java.util.stream.Collector<? super T, A, R>)
  Line 122) isAssignableBy(other.asConstraintType().getBound()) ==> com.github.javaparser.symbolsolver.model.typesystem.ReferenceTypeImpl.isAssignableBy(com.github.javaparser.symbolsolver.model.typesystem.Type)
  Line 105) getVisibleFields().stream().filter(f -> f.getName().equals(name)) ==> java.util.stream.Stream.filter(java.util.function.Predicate<? super T>)
  Line 105) getVisibleFields().stream() ==> java.util.Collection.stream()
  Line 105) getVisibleFields() ==> com.github.javaparser.symbolsolver.model.declarations.ReferenceTypeDeclaration.getVisibleFields()
  Line 38) getParentNode(wrappedNode) ==> com.github.javaparser.symbolsolver.javaparser.Navigator.getParentNode(com.github.javaparser.ast.Node)
  Line 105) f.getName().equals(name) ==> java.lang.String.equals(java.lang.Object)
  Line 63) methods.size() ==> java.util.Set.size()
  Line 64) Optional.of(methods.iterator().next()) ==> java.util.Optional.of(T)
  Line 64) methods.iterator().next() ==> java.util.Iterator.next()
  Line 64) methods.iterator() ==> java.util.Set.iterator()
  Line 66) Optional.empty() ==> java.util.Optional.empty()
  Line 55) Arrays.stream(parameterizedType.getActualTypeArguments()).map((t) -> ReflectionFactory.typeUsageFor(t, typeSolver)) ==> java.util.stream.Stream.map(java.util.function.Function<? super T, ? extends R>)
  Line 55) Arrays.stream(parameterizedType.getActualTypeArguments()) ==> java.util.Arrays.stream(T[])
  Line 55) parameterizedType.getActualTypeArguments() ==> java.lang.reflect.ParameterizedType.getActualTypeArguments()
  Line 122) other.asConstraintType().getBound() ==> com.github.javaparser.symbolsolver.model.typesystem.LambdaConstraintType.getBound()
  Line 122) other.asConstraintType() ==> com.github.javaparser.symbolsolver.model.typesystem.Type.asConstraintType()
  Line 123) other.isWildcard() ==> com.github.javaparser.symbolsolver.model.typesystem.Type.isWildcard()
  Line 124) this.getQualifiedName().equals(Object.class.getCanonicalName()) ==> java.lang.String.equals(java.lang.Object)
  Line 124) this.getQualifiedName() ==> com.github.javaparser.symbolsolver.model.typesystem.ReferenceType.getQualifiedName()
  Line 124) Object.class.getCanonicalName() ==> java.lang.Class.getCanonicalName()
  Line 105) f.getName() ==> com.github.javaparser.symbolsolver.model.declarations.Declaration.getName()
  Line 126) other.asWildcard().isExtends() ==> com.github.javaparser.symbolsolver.model.typesystem.Wildcard.isExtends()
  Line 126) other.asWildcard() ==> com.github.javaparser.symbolsolver.model.typesystem.Type.asWildcard()
  Line 157) constructors.stream().filter((m) -> isApplicable(m, argumentsTypes, typeSolver, wildcardTolerance)).collect(Collectors.toList()) ==> java.util.stream.Stream.collect(java.util.stream.Collector<? super T, A, R>)
  Line 157) constructors.stream().filter((m) -> isApplicable(m, argumentsTypes, typeSolver, wildcardTolerance)) ==> java.util.stream.Stream.filter(java.util.function.Predicate<? super T>)
  Line 157) constructors.stream() ==> java.util.Collection.stream()
  Line 127) isAssignableBy(other.asWildcard().getBoundedType()) ==> com.github.javaparser.symbolsolver.model.typesystem.ReferenceTypeImpl.isAssignableBy(com.github.javaparser.symbolsolver.model.typesystem.Type)
  Line 127) other.asWildcard().getBoundedType() ==> com.github.javaparser.symbolsolver.model.typesystem.Wildcard.getBoundedType()
  Line 127) other.asWildcard() ==> com.github.javaparser.symbolsolver.model.typesystem.Type.asWildcard()
  Line 157) isApplicable(m, argumentsTypes, typeSolver, wildcardTolerance) ==> com.github.javaparser.symbolsolver.resolution.ConstructorResolutionLogic.isApplicable(com.github.javaparser.symbolsolver.model.declarations.ConstructorDeclaration, java.util.List<com.github.javaparser.symbolsolver.model.typesystem.Type>, com.github.javaparser.symbolsolver.model.resolution.TypeSolver, boolean)
  Line 157) Collectors.toList() ==> java.util.stream.Collectors.toList()
  Line 158) applicableConstructors.isEmpty() ==> java.util.List.isEmpty()
  Line 159) SymbolReference.unsolved(ConstructorDeclaration.class) ==> com.github.javaparser.symbolsolver.model.resolution.SymbolReference.unsolved(java.lang.Class<S2>)
  Line 161) applicableConstructors.size() ==> java.util.List.size()
  Line 119) getAllFields().stream().filter(f -> f.declaringType().equals(this) || f.accessLevel() != AccessLevel.PRIVATE).collect(Collectors.toList()) ==> java.util.stream.Stream.collect(java.util.stream.Collector<? super T, A, R>)
  Line 119) getAllFields().stream().filter(f -> f.declaringType().equals(this) || f.accessLevel() != AccessLevel.PRIVATE) ==> java.util.stream.Stream.filter(java.util.function.Predicate<? super T>)
  Line 119) getAllFields().stream() ==> java.util.Collection.stream()
  Line 119) getAllFields() ==> com.github.javaparser.symbolsolver.model.declarations.ReferenceTypeDeclaration.getAllFields()
  Line 140) getTypeDeclaration().getDeclaredMethods() ==> com.github.javaparser.symbolsolver.model.declarations.ReferenceTypeDeclaration.getDeclaredMethods()
  Line 140) getTypeDeclaration() ==> com.github.javaparser.symbolsolver.model.typesystem.ReferenceType.getTypeDeclaration()
  Line 131) field.getName() ==> javassist.CtField.getName()
  Line 132) SymbolReference.solved(new JavassistFieldDeclaration(field, typeSolver)) ==> com.github.javaparser.symbolsolver.model.resolution.SymbolReference.solved(S2)
  Line 105) parentCall.getArguments() ==> com.github.javaparser.ast.expr.MethodCallExpr.getArguments()
  Line 34) ImmutableList.of() ==> com.google.common.collect.ImmutableList.of()
  Line 35) Integer.class.getCanonicalName() ==> java.lang.Class.getCanonicalName()
  Line 45) wrappedNode.getVariables().stream().map(v -> JavaParserSymbolDeclaration.localVar(v, typeSolver)).collect(Collectors.toCollection(() -> new LinkedList<>())) ==> ERROR
  Line 45) wrappedNode.getVariables().stream().map(v -> JavaParserSymbolDeclaration.localVar(v, typeSolver)) ==> ERROR
  Line 62) getPackageName(getParentNode(container)) ==> com.github.javaparser.symbolsolver.javaparsermodel.declarations.Helper.getPackageName(com.github.javaparser.ast.Node)
  Line 35) ImmutableList.of(BYTE, SHORT, CHAR) ==> com.google.common.collect.ImmutableList.of(E, E, E)
  Line 36) Long.class.getCanonicalName() ==> java.lang.Class.getCanonicalName()
  Line 162) SymbolReference.solved(applicableConstructors.get(0)) ==> com.github.javaparser.symbolsolver.model.resolution.SymbolReference.solved(S2)
  Line 162) applicableConstructors.get(0) ==> java.util.List.get(int)
  Line 137) ctClass.getSuperclass() ==> javassist.CtClass.getSuperclass()
  Line 164) applicableConstructors.get(0) ==> java.util.List.get(int)
  Line 167) applicableConstructors.size() ==> java.util.List.size()
  Line 142) methods.add(methodUsage) ==> java.util.Set.add(E)
  Line 73) parsedFiles.put(srcFile.getAbsolutePath(), JavaParser.parse(srcFile)) ==> java.util.Map.put(K, V)
  Line 73) srcFile.getAbsolutePath() ==> java.io.File.getAbsolutePath()
  Line 139) new JavassistClassDeclaration(superClass, typeSolver).solveSymbol(name, typeSolver) ==> com.github.javaparser.symbolsolver.javassistmodel.JavassistClassDeclaration.solveSymbol(java.lang.String, com.github.javaparser.symbolsolver.model.resolution.TypeSolver)
  Line 56) ReflectionFactory.typeUsageFor(t, typeSolver) ==> com.github.javaparser.symbolsolver.reflectionmodel.ReflectionFactory.typeUsageFor(java.lang.reflect.Type, com.github.javaparser.symbolsolver.model.resolution.TypeSolver)
  Line 57) Collectors.toList() ==> java.util.stream.Collectors.toList()
  Line 120) f.declaringType().equals(this) ==> java.lang.Object.equals(java.lang.Object)
  Line 140) ref.isSolved() ==> com.github.javaparser.symbolsolver.model.resolution.SymbolReference.isSolved()
  Line 106) parentCall.getArguments() ==> com.github.javaparser.ast.expr.MethodCallExpr.getArguments()
  Line 36) ImmutableList.of(BYTE, SHORT, INT, CHAR) ==> com.google.common.collect.ImmutableList.of(E, E, E, E)
  Line 120) f.declaringType() ==> com.github.javaparser.symbolsolver.model.declarations.FieldDeclaration.declaringType()
  Line 37) Boolean.class.getCanonicalName() ==> java.lang.Class.getCanonicalName()
  Line 58) interfaces.add(new ReferenceTypeImpl(new ReflectionInterfaceDeclaration((Class<?>) ((ParameterizedType) superInterface).getRawType(), typeSolver), typeParameters, typeSolver)) ==> java.util.List.add(E)
  Line 58) ((ParameterizedType) superInterface).getRawType() ==> java.lang.reflect.ParameterizedType.getRawType()
  Line 149) ctClass.getInterfaces() ==> javassist.CtClass.getInterfaces()
  Line 60) interfaces.add(new ReferenceTypeImpl(new ReflectionInterfaceDeclaration((Class<?>) superInterface, typeSolver), typeSolver)) ==> java.util.List.add(E)
  Line 68) getSuperClass() ==> com.github.javaparser.symbolsolver.reflectionmodel.ReflectionClassAdapter.getSuperClass()
  Line 69) getSuperClass() ==> com.github.javaparser.symbolsolver.reflectionmodel.ReflectionClassAdapter.getSuperClass()
  Line 113) getParentNode(wrappedNode) ==> com.github.javaparser.symbolsolver.javaparser.Navigator.getParentNode(com.github.javaparser.ast.Node)
  Line 70) ancestors.add(superClass) ==> java.util.List.add(E)
  Line 73) ancestors.add(object) ==> java.util.List.add(E)
  Line 150) new JavassistInterfaceDeclaration(interfaze, typeSolver).solveSymbol(name, typeSolver) ==> com.github.javaparser.symbolsolver.javassistmodel.JavassistInterfaceDeclaration.solveSymbol(java.lang.String, com.github.javaparser.symbolsolver.model.resolution.TypeSolver)
  Line 62) getParentNode(container) ==> com.github.javaparser.symbolsolver.javaparser.Navigator.getParentNode(com.github.javaparser.ast.Node)
  Line 151) ref.isSolved() ==> com.github.javaparser.symbolsolver.model.resolution.SymbolReference.isSolved()
  Line 73) JavaParser.parse(srcFile) ==> com.github.javaparser.JavaParser.parse(java.io.File)
  Line 159) SymbolReference.unsolved(ValueDeclaration.class) ==> com.github.javaparser.symbolsolver.model.resolution.SymbolReference.unsolved(java.lang.Class<S2>)
  Line 165) getSuperClass() ==> com.github.javaparser.symbolsolver.javassistmodel.JavassistClassDeclaration.getSuperClass()
  Line 75) parsedFiles.get(srcFile.getAbsolutePath()) ==> java.util.Map.get(java.lang.Object)
  Line 75) srcFile.getAbsolutePath() ==> java.io.File.getAbsolutePath()
  Line 168) applicableConstructors.get(i) ==> java.util.List.get(int)
  Line 169) isMoreSpecific(winningCandidate, other, typeSolver) ==> com.github.javaparser.symbolsolver.resolution.ConstructorResolutionLogic.isMoreSpecific(com.github.javaparser.symbolsolver.model.declarations.ConstructorDeclaration, com.github.javaparser.symbolsolver.model.declarations.ConstructorDeclaration, com.github.javaparser.symbolsolver.model.resolution.TypeSolver)
  Line 75) ancestors.addAll(getInterfaces()) ==> java.util.List.addAll(java.util.Collection<? extends E>)
  Line 75) getInterfaces() ==> com.github.javaparser.symbolsolver.reflectionmodel.ReflectionClassAdapter.getInterfaces()
  Line 120) f.accessLevel() ==> com.github.javaparser.symbolsolver.model.declarations.HasAccessLevel.accessLevel()
  Line 171) isMoreSpecific(other, winningCandidate, typeSolver) ==> com.github.javaparser.symbolsolver.resolution.ConstructorResolutionLogic.isMoreSpecific(com.github.javaparser.symbolsolver.model.declarations.ConstructorDeclaration, com.github.javaparser.symbolsolver.model.declarations.ConstructorDeclaration, com.github.javaparser.symbolsolver.model.resolution.TypeSolver)
  Line 121) Collectors.toList() ==> java.util.stream.Collectors.toList()
  Line 175) winningCandidate.declaringType().getQualifiedName().equals(other.declaringType().getQualifiedName()) ==> java.lang.String.equals(java.lang.Object)
  Line 175) winningCandidate.declaringType().getQualifiedName() ==> com.github.javaparser.symbolsolver.model.declarations.TypeDeclaration.getQualifiedName()
  Line 175) winningCandidate.declaringType() ==> com.github.javaparser.symbolsolver.model.declarations.ConstructorDeclaration.declaringType()
  Line 176) other.declaringType().getQualifiedName() ==> com.github.javaparser.symbolsolver.model.declarations.TypeDeclaration.getQualifiedName()
  Line 176) other.declaringType() ==> com.github.javaparser.symbolsolver.model.declarations.ConstructorDeclaration.declaringType()
  Line 185) MethodResolutionLogic.isExactMatch(winningCandidate, argumentsTypes) ==> com.github.javaparser.symbolsolver.resolution.MethodResolutionLogic.isExactMatch(com.github.javaparser.symbolsolver.model.declarations.MethodLikeDeclaration, java.util.List<com.github.javaparser.symbolsolver.model.typesystem.Type>)
  Line 186) MethodResolutionLogic.isExactMatch(other, argumentsTypes) ==> com.github.javaparser.symbolsolver.resolution.MethodResolutionLogic.isExactMatch(com.github.javaparser.symbolsolver.model.declarations.MethodLikeDeclaration, java.util.List<com.github.javaparser.symbolsolver.model.typesystem.Type>)
  Line 193) SymbolReference.solved(winningCandidate) ==> com.github.javaparser.symbolsolver.model.resolution.SymbolReference.solved(S2)
  Line 69) getClassName(base, getParentNode(container)) ==> com.github.javaparser.symbolsolver.javaparsermodel.declarations.Helper.getClassName(java.lang.String, com.github.javaparser.ast.Node)
  Line 45) wrappedNode.getVariables().stream() ==> java.util.Collection.stream()
  Line 166) ancestors.add(getSuperClass()) ==> java.util.List.add(E)
  Line 166) getSuperClass() ==> com.github.javaparser.symbolsolver.javassistmodel.JavassistClassDeclaration.getSuperClass()
  Line 200) constructorA.getNumberOfParams() ==> com.github.javaparser.symbolsolver.model.declarations.MethodLikeDeclaration.getNumberOfParams()
  Line 200) constructorB.getNumberOfParams() ==> com.github.javaparser.symbolsolver.model.declarations.MethodLikeDeclaration.getNumberOfParams()
  Line 115) getParentNode(notMethod) ==> com.github.javaparser.symbolsolver.javaparser.Navigator.getParentNode(com.github.javaparser.ast.Node)
  Line 37) ImmutableList.of() ==> com.google.common.collect.ImmutableList.of()
  Line 58) node.getClass() ==> java.lang.Object.getClass()
  Line 79) parsedDirectories.containsKey(srcDirectory.getAbsolutePath()) ==> java.util.Map.containsKey(java.lang.Object)
  Line 79) srcDirectory.getAbsolutePath() ==> java.io.File.getAbsolutePath()
  Line 81) srcDirectory.listFiles() ==> java.io.File.listFiles()
  Line 82) srcDirectory.getAbsolutePath() ==> java.io.File.getAbsolutePath()
  Line 84) file.getName().toLowerCase().endsWith(".java") ==> java.lang.String.endsWith(java.lang.String)
  Line 84) file.getName().toLowerCase() ==> java.lang.String.toLowerCase()
  Line 128) getAllFields().stream().filter(it -> !it.isStatic()).collect(Collectors.toList()) ==> java.util.stream.Stream.collect(java.util.stream.Collector<? super T, A, R>)
  Line 76) ancestors.size() ==> java.util.List.size()
  Line 128) getAllFields().stream().filter(it -> !it.isStatic()) ==> java.util.stream.Stream.filter(java.util.function.Predicate<? super T>)
  Line 128) getAllFields().stream() ==> java.util.Collection.stream()
  Line 128) getAllFields() ==> com.github.javaparser.symbolsolver.model.declarations.ReferenceTypeDeclaration.getAllFields()
  Line 38) Float.class.getCanonicalName() ==> java.lang.Class.getCanonicalName()
  Line 45) wrappedNode.getVariables() ==> com.github.javaparser.ast.expr.VariableDeclarationExpr.getVariables()
  Line 128) it.isStatic() ==> com.github.javaparser.symbolsolver.model.declarations.FieldDeclaration.isStatic()
  Line 128) Collectors.toList() ==> java.util.stream.Collectors.toList()
  Line 84) file.getName() ==> java.io.File.getName()
  Line 63) node.getClass().getCanonicalName() ==> java.lang.Class.getCanonicalName()
  Line 69) getParentNode(container) ==> com.github.javaparser.symbolsolver.javaparser.Navigator.getParentNode(com.github.javaparser.ast.Node)
  Line 63) node.getClass() ==> java.lang.Object.getClass()
  Line 168) ancestors.addAll(getInterfaces()) ==> java.util.List.addAll(java.util.Collection<? extends E>)
  Line 168) getInterfaces() ==> com.github.javaparser.symbolsolver.javassistmodel.JavassistClassDeclaration.getInterfaces()
  Line 68) node.getClass().getCanonicalName() ==> java.lang.Class.getCanonicalName()
  Line 68) node.getClass() ==> java.lang.Object.getClass()
  Line 203) constructorA.getNumberOfParams() ==> com.github.javaparser.symbolsolver.model.declarations.MethodLikeDeclaration.getNumberOfParams()
  Line 117) JavaParserFactory.getContext(notMethod, typeSolver) ==> com.github.javaparser.symbolsolver.javaparsermodel.JavaParserFactory.getContext(com.github.javaparser.ast.Node, com.github.javaparser.symbolsolver.model.resolution.TypeSolver)
  Line 70) ((com.github.javaparser.ast.body.ClassOrInterfaceDeclaration) container).getName().getId() ==> com.github.javaparser.ast.nodeTypes.NodeWithIdentifier.getId()
  Line 70) ((com.github.javaparser.ast.body.ClassOrInterfaceDeclaration) container).getName() ==> com.github.javaparser.ast.body.TypeDeclaration.getName()
  Line 71) b.isEmpty() ==> java.lang.String.isEmpty()
  Line 77) ancestors.get(i) ==> java.util.List.get(int)
  Line 78) ancestor.hasName() ==> com.github.javaparser.symbolsolver.model.typesystem.ReferenceType.hasName()
  Line 78) ancestor.getQualifiedName().equals(Object.class.getCanonicalName()) ==> java.lang.String.equals(java.lang.Object)
  Line 78) ancestor.getQualifiedName() ==> com.github.javaparser.symbolsolver.model.typesystem.ReferenceType.getQualifiedName()
  Line 78) Object.class.getCanonicalName() ==> java.lang.Class.getCanonicalName()
  Line 75) findType(type.get(), innerTypeName) ==> com.github.javaparser.symbolsolver.javaparser.Navigator.findType(com.github.javaparser.ast.body.TypeDeclaration<?>, java.lang.String)
  Line 79) ancestors.remove(i) ==> java.util.List.remove(int)
  Line 75) type.get() ==> java.util.Optional.get()
  Line 85) units.add(parse(file)) ==> java.util.List.add(E)
  Line 85) parse(file) ==> com.github.javaparser.symbolsolver.resolution.typesolvers.JavaParserTypeSolver.parse(java.io.File)
  Line 175) Modifier.isStatic(m.getModifiers()) ==> java.lang.reflect.Modifier.isStatic(int)
  Line 175) m.getModifiers() ==> javassist.CtBehavior.getModifiers()
  Line 88) parsedDirectories.put(srcDirectory.getAbsolutePath(), units) ==> java.util.Map.put(K, V)
  Line 87) clazz.getDeclaredFields() ==> java.lang.Class.getDeclaredFields()
  Line 88) srcDirectory.getAbsolutePath() ==> java.io.File.getAbsolutePath()
  Line 88) field.getName().equals(name) ==> java.lang.String.equals(java.lang.Object)
  Line 88) field.getName() ==> java.lang.reflect.Field.getName()
  Line 71) String.format("%s(%s)", m.getName(), String.join(", ", Arrays.stream(m.getParameters()).map(p -> toSignature(p)).collect(Collectors.toList()))) ==> java.lang.String.format(java.lang.String, java.lang.Object...)
  Line 120) getParentNode(wrappedNode) ==> com.github.javaparser.symbolsolver.javaparser.Navigator.getParentNode(com.github.javaparser.ast.Node)
  Line 71) m.getName() ==> java.lang.reflect.Method.getName()
  Line 92) typeDeclaration.getAllAncestors() ==> com.github.javaparser.symbolsolver.model.declarations.ReferenceTypeDeclaration.getAllAncestors()
  Line 77) getClassName(base, getParentNode(container)) ==> com.github.javaparser.symbolsolver.javaparsermodel.declarations.Helper.getClassName(java.lang.String, com.github.javaparser.ast.Node)
  Line 38) ImmutableList.of(LONG, INT, SHORT, BYTE, CHAR) ==> com.google.common.collect.ImmutableList.of(E, E, E, E, E)
  Line 46) JavaParserSymbolDeclaration.localVar(v, typeSolver) ==> ERROR
  Line 48) Collectors.toCollection(() -> new LinkedList<>()) ==> java.util.stream.Collectors.toCollection(java.util.function.Supplier<C>)
