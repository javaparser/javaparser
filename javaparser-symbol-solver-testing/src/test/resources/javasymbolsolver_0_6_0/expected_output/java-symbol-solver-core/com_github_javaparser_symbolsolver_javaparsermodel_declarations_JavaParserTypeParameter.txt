  Line 183) staticValue.toString() ==> com.github.javaparser.ast.Node.toString()
  Line 184) typeAccessedStatically.isSolved() ==> com.github.javaparser.symbolsolver.model.resolution.SymbolReference.isSolved()
  Line 186) solveDotExpressionType(typeAccessedStatically.getCorrespondingDeclaration().asReferenceType(), node) ==> com.github.javaparser.symbolsolver.javaparsermodel.TypeExtractor.solveDotExpressionType(com.github.javaparser.symbolsolver.model.declarations.ReferenceTypeDeclaration, com.github.javaparser.ast.expr.FieldAccessExpr)
  Line 187) typeAccessedStatically.getCorrespondingDeclaration().asReferenceType() ==> com.github.javaparser.symbolsolver.model.declarations.TypeDeclaration.asReferenceType()
  Line 187) typeAccessedStatically.getCorrespondingDeclaration() ==> com.github.javaparser.symbolsolver.model.resolution.SymbolReference.getCorrespondingDeclaration()
  Line 189) node.getScope() ==> com.github.javaparser.ast.expr.FieldAccessExpr.getScope()
  Line 56) Collections.emptySet() ==> java.util.Collections.emptySet()
  Line 60) getContext().solveMethod(name, parameterTypes, false, typeSolver) ==> com.github.javaparser.symbolsolver.core.resolution.Context.solveMethod(java.lang.String, java.util.List<com.github.javaparser.symbolsolver.model.typesystem.Type>, boolean, com.github.javaparser.symbolsolver.model.resolution.TypeSolver)
  Line 60) getContext() ==> com.github.javaparser.symbolsolver.javaparsermodel.declarations.JavaParserTypeParameter.getContext()
  Line 439) wildcardUsage.isSuper() ==> com.github.javaparser.symbolsolver.model.typesystem.Wildcard.isSuper()
  Line 440) solveMethodAsUsage(wildcardUsage.getBoundedType(), name, argumentsTypes, typeSolver, invokationContext) ==> com.github.javaparser.symbolsolver.javaparsermodel.contexts.MethodCallExprContext.solveMethodAsUsage(com.github.javaparser.symbolsolver.model.typesystem.Type, java.lang.String, java.util.List<com.github.javaparser.symbolsolver.model.typesystem.Type>, com.github.javaparser.symbolsolver.model.resolution.TypeSolver, com.github.javaparser.symbolsolver.core.resolution.Context)
  Line 440) wildcardUsage.getBoundedType() ==> com.github.javaparser.symbolsolver.model.typesystem.Wildcard.getBoundedType()
  Line 441) wildcardUsage.isExtends() ==> com.github.javaparser.symbolsolver.model.typesystem.Wildcard.isExtends()
  Line 70) wrappedNode.equals(that.wrappedNode) ==> com.github.javaparser.ast.Node.equals(java.lang.Object)
  Line 77) wrappedNode.hashCode() ==> com.github.javaparser.ast.Node.hashCode()
  Line 78) typeSolver.hashCode() ==> java.lang.Object.hashCode()
  Line 84) wrappedNode.getName().getId() ==> com.github.javaparser.ast.nodeTypes.NodeWithIdentifier.getId()
  Line 84) wrappedNode.getName() ==> com.github.javaparser.ast.type.TypeParameter.getName()
  Line 89) isAssignableBy(new ReferenceTypeImpl(other, typeSolver)) ==> com.github.javaparser.symbolsolver.javaparsermodel.declarations.JavaParserTypeParameter.isAssignableBy(com.github.javaparser.symbolsolver.model.typesystem.Type)
  Line 94) getContainer() ==> com.github.javaparser.symbolsolver.javaparsermodel.declarations.JavaParserTypeParameter.getContainer()
  Line 448) solveMethodAsUsage(constraintType.getBound(), name, argumentsTypes, typeSolver, invokationContext) ==> com.github.javaparser.symbolsolver.javaparsermodel.contexts.MethodCallExprContext.solveMethodAsUsage(com.github.javaparser.symbolsolver.model.typesystem.Type, java.lang.String, java.util.List<com.github.javaparser.symbolsolver.model.typesystem.Type>, com.github.javaparser.symbolsolver.model.resolution.TypeSolver, com.github.javaparser.symbolsolver.core.resolution.Context)
  Line 96) ((ReferenceTypeDeclaration) container).getQualifiedName() ==> com.github.javaparser.symbolsolver.model.declarations.TypeDeclaration.getQualifiedName()
  Line 448) constraintType.getBound() ==> com.github.javaparser.symbolsolver.model.typesystem.LambdaConstraintType.getBound()
  Line 98) ((JavaParserConstructorDeclaration) container).getQualifiedSignature() ==> com.github.javaparser.symbolsolver.model.declarations.MethodLikeDeclaration.getQualifiedSignature()
  Line 100) ((JavaParserMethodDeclaration) container).getQualifiedSignature() ==> com.github.javaparser.symbolsolver.model.declarations.MethodLikeDeclaration.getQualifiedSignature()
  Line 106) getContainer() ==> com.github.javaparser.symbolsolver.javaparsermodel.declarations.JavaParserTypeParameter.getContainer()
  Line 108) ((ReferenceTypeDeclaration) container).getId() ==> com.github.javaparser.symbolsolver.model.declarations.TypeDeclaration.getId()
  Line 110) ((JavaParserConstructorDeclaration) container).getQualifiedSignature() ==> com.github.javaparser.symbolsolver.model.declarations.MethodLikeDeclaration.getQualifiedSignature()
  Line 112) ((JavaParserMethodDeclaration) container).getQualifiedSignature() ==> com.github.javaparser.symbolsolver.model.declarations.MethodLikeDeclaration.getQualifiedSignature()
  Line 118) getParentNode(wrappedNode) ==> com.github.javaparser.symbolsolver.javaparser.Navigator.getParentNode(com.github.javaparser.ast.Node)
  Line 451) solveMethodAsUsage(new ReferenceTypeImpl(new ReflectionClassDeclaration(Object.class, typeSolver), typeSolver), name, argumentsTypes, typeSolver, invokationContext) ==> com.github.javaparser.symbolsolver.javaparsermodel.contexts.MethodCallExprContext.solveMethodAsUsage(com.github.javaparser.symbolsolver.model.typesystem.ReferenceType, java.lang.String, java.util.List<com.github.javaparser.symbolsolver.model.typesystem.Type>, com.github.javaparser.symbolsolver.model.resolution.TypeSolver, com.github.javaparser.symbolsolver.core.resolution.Context)
  Line 453) type.getClass().getCanonicalName() ==> java.lang.Class.getCanonicalName()
  Line 453) type.getClass() ==> java.lang.Object.getClass()
  Line 458) type.isReferenceType() ==> com.github.javaparser.symbolsolver.model.typesystem.Type.isReferenceType()
  Line 459) type.asReferenceType().getTypeParametersMap() ==> com.github.javaparser.symbolsolver.model.typesystem.ReferenceType.getTypeParametersMap()
  Line 459) type.asReferenceType() ==> com.github.javaparser.symbolsolver.model.typesystem.Type.asReferenceType()
  Line 460) entry._1.declaredOnType() ==> com.github.javaparser.symbolsolver.model.declarations.TypeParameterDeclaration.declaredOnType()
  Line 192) facade.solve((ThisExpr) node.getScope()) ==> com.github.javaparser.symbolsolver.javaparsermodel.JavaParserFacade.solve(com.github.javaparser.ast.expr.ThisExpr)
  Line 192) node.getScope() ==> com.github.javaparser.ast.expr.FieldAccessExpr.getScope()
  Line 194) solve.isSolved() ==> com.github.javaparser.symbolsolver.model.resolution.SymbolReference.isSolved()
  Line 195) solve.getCorrespondingDeclaration() ==> com.github.javaparser.symbolsolver.model.resolution.SymbolReference.getCorrespondingDeclaration()
  Line 460) scope.asReferenceType().getGenericParameterByName(entry._1.getName()).isPresent() ==> java.util.Optional.isPresent()
  Line 460) scope.asReferenceType().getGenericParameterByName(entry._1.getName()) ==> com.github.javaparser.symbolsolver.model.typesystem.ReferenceType.getGenericParameterByName(java.lang.String)
  Line 460) scope.asReferenceType() ==> com.github.javaparser.symbolsolver.model.typesystem.Type.asReferenceType()
  Line 460) entry._1.getName() ==> com.github.javaparser.symbolsolver.model.declarations.TypeParameterDeclaration.getName()
  Line 197) solveDotExpressionType(correspondingDeclaration.asReferenceType(), node) ==> com.github.javaparser.symbolsolver.javaparsermodel.TypeExtractor.solveDotExpressionType(com.github.javaparser.symbolsolver.model.declarations.ReferenceTypeDeclaration, com.github.javaparser.ast.expr.FieldAccessExpr)
  Line 197) correspondingDeclaration.asReferenceType() ==> com.github.javaparser.symbolsolver.model.declarations.TypeDeclaration.asReferenceType()
  Line 201) node.getScope().toString().indexOf('.') ==> java.lang.String.indexOf(int)
  Line 201) node.getScope().toString() ==> com.github.javaparser.ast.Node.toString()
  Line 201) node.getScope() ==> com.github.javaparser.ast.expr.FieldAccessExpr.getScope()
  Line 203) typeSolver.tryToSolveType(node.getScope().toString()) ==> com.github.javaparser.symbolsolver.model.resolution.TypeSolver.tryToSolveType(java.lang.String)
  Line 203) node.getScope().toString() ==> com.github.javaparser.ast.Node.toString()
  Line 203) node.getScope() ==> com.github.javaparser.ast.expr.FieldAccessExpr.getScope()
  Line 204) sr.isSolved() ==> com.github.javaparser.symbolsolver.model.resolution.SymbolReference.isSolved()
  Line 461) type.replaceTypeVariables(entry._1, scope.asReferenceType().getGenericParameterByName(entry._1.getName()).get(), inferredTypes) ==> com.github.javaparser.symbolsolver.model.typesystem.Type.replaceTypeVariables(com.github.javaparser.symbolsolver.model.declarations.TypeParameterDeclaration, com.github.javaparser.symbolsolver.model.typesystem.Type, java.util.Map<com.github.javaparser.symbolsolver.model.declarations.TypeParameterDeclaration, com.github.javaparser.symbolsolver.model.typesystem.Type>)
  Line 461) scope.asReferenceType().getGenericParameterByName(entry._1.getName()).get() ==> java.util.Optional.get()
  Line 121) JavaParserFacade.get(typeSolver).getTypeDeclaration(jpTypeDeclaration) ==> com.github.javaparser.symbolsolver.javaparsermodel.JavaParserFacade.getTypeDeclaration(com.github.javaparser.ast.body.ClassOrInterfaceDeclaration)
  Line 461) scope.asReferenceType().getGenericParameterByName(entry._1.getName()) ==> com.github.javaparser.symbolsolver.model.typesystem.ReferenceType.getGenericParameterByName(java.lang.String)
  Line 461) scope.asReferenceType() ==> com.github.javaparser.symbolsolver.model.typesystem.Type.asReferenceType()
  Line 121) JavaParserFacade.get(typeSolver) ==> com.github.javaparser.symbolsolver.javaparsermodel.JavaParserFacade.get(com.github.javaparser.symbolsolver.model.resolution.TypeSolver)
  Line 461) entry._1.getName() ==> com.github.javaparser.symbolsolver.model.declarations.TypeParameterDeclaration.getName()
  Line 471) inferredTypes.keySet() ==> java.util.Map.keySet()
  Line 205) solveDotExpressionType(sr.getCorrespondingDeclaration(), node) ==> com.github.javaparser.symbolsolver.javaparsermodel.TypeExtractor.solveDotExpressionType(com.github.javaparser.symbolsolver.model.declarations.ReferenceTypeDeclaration, com.github.javaparser.ast.expr.FieldAccessExpr)
  Line 205) sr.getCorrespondingDeclaration() ==> com.github.javaparser.symbolsolver.model.resolution.SymbolReference.getCorrespondingDeclaration()
  Line 124) jpConstructorDeclaration.getAncestorOfType(com.github.javaparser.ast.body.ClassOrInterfaceDeclaration.class) ==> com.github.javaparser.HasParentNode.getAncestorOfType(java.lang.Class<N>)
  Line 125) jpTypeDeclaration.isPresent() ==> java.util.Optional.isPresent()
  Line 472) type.replaceTypeVariables(tp, inferredTypes.get(tp), inferredTypes) ==> com.github.javaparser.symbolsolver.model.typesystem.Type.replaceTypeVariables(com.github.javaparser.symbolsolver.model.declarations.TypeParameterDeclaration, com.github.javaparser.symbolsolver.model.typesystem.Type, java.util.Map<com.github.javaparser.symbolsolver.model.declarations.TypeParameterDeclaration, com.github.javaparser.symbolsolver.model.typesystem.Type>)
  Line 472) inferredTypes.get(tp) ==> java.util.Map.get(java.lang.Object)
  Line 210) new SymbolSolver(typeSolver).solveSymbolAsValue(node.getField().getId(), node) ==> com.github.javaparser.symbolsolver.resolution.SymbolSolver.solveSymbolAsValue(java.lang.String, com.github.javaparser.ast.Node)
  Line 126) JavaParserFacade.get(typeSolver).getTypeDeclaration(jpTypeDeclaration.get()) ==> com.github.javaparser.symbolsolver.javaparsermodel.JavaParserFacade.getTypeDeclaration(com.github.javaparser.ast.body.ClassOrInterfaceDeclaration)
