  Line 90) formalTypeAsReference.getQualifiedName() ==> com.github.javaparser.symbolsolver.model.typesystem.ReferenceType.getQualifiedName()
  Line 90) actualTypeAsReference.getQualifiedName() ==> com.github.javaparser.symbolsolver.model.typesystem.ReferenceType.getQualifiedName()
  Line 188) node.getClass() ==> java.lang.Object.getClass()
  Line 126) expectedType.isAssignableBy(actualType) ==> com.github.javaparser.symbolsolver.model.typesystem.Type.isAssignableBy(com.github.javaparser.symbolsolver.model.typesystem.Type)
  Line 127) actualType.isWildcard() ==> com.github.javaparser.symbolsolver.model.typesystem.Type.isWildcard()
  Line 91) formalTypeAsReference.typeParametersValues().isEmpty() ==> java.util.List.isEmpty()
  Line 91) formalTypeAsReference.typeParametersValues() ==> com.github.javaparser.symbolsolver.model.typesystem.ReferenceType.typeParametersValues()
  Line 92) actualTypeAsReference.isRawType() ==> com.github.javaparser.symbolsolver.model.typesystem.ReferenceType.isRawType()
  Line 96) formalTypeAsReference.typeParametersValues() ==> com.github.javaparser.symbolsolver.model.typesystem.ReferenceType.typeParametersValues()
  Line 303) Arrays.stream(ctClass.getInterfaces()).map(i -> new JavassistInterfaceDeclaration(i, typeSolver)).map(i -> new ReferenceTypeImpl(i, typeSolver)) ==> java.util.stream.Stream.map(java.util.function.Function<? super T, ? extends R>)
  Line 303) Arrays.stream(ctClass.getInterfaces()).map(i -> new JavassistInterfaceDeclaration(i, typeSolver)) ==> java.util.stream.Stream.map(java.util.function.Function<? super T, ? extends R>)
  Line 97) registerCorrespondance(formalTypeParameter, actualTypeAsReference.typeParametersValues().get(i)) ==> com.github.javaparser.symbolsolver.logic.InferenceContext.registerCorrespondance(com.github.javaparser.symbolsolver.model.typesystem.Type, com.github.javaparser.symbolsolver.model.typesystem.Type)
  Line 97) actualTypeAsReference.typeParametersValues().get(i) ==> java.util.List.get(int)
  Line 97) actualTypeAsReference.typeParametersValues() ==> com.github.javaparser.symbolsolver.model.typesystem.ReferenceType.typeParametersValues()
  Line 303) Arrays.stream(ctClass.getInterfaces()) ==> java.util.Arrays.stream(T[])
  Line 127) expectedType.isPrimitive() ==> com.github.javaparser.symbolsolver.model.typesystem.Type.isPrimitive()
  Line 131) method.hasVariadicParameter() ==> com.github.javaparser.symbolsolver.model.declarations.MethodLikeDeclaration.hasVariadicParameter()
  Line 193) node.getClass().getCanonicalName() ==> java.lang.Class.getCanonicalName()
  Line 131) method.getNumberOfParams() ==> com.github.javaparser.symbolsolver.model.declarations.MethodLikeDeclaration.getNumberOfParams()
  Line 193) node.getClass() ==> java.lang.Object.getClass()
  Line 132) new ArrayType(expectedType).isAssignableBy(actualType) ==> com.github.javaparser.symbolsolver.model.typesystem.ArrayType.isAssignableBy(com.github.javaparser.symbolsolver.model.typesystem.Type)
  Line 145) expected.isReferenceType() ==> com.github.javaparser.symbolsolver.model.typesystem.Type.isReferenceType()
  Line 198) node.getClass().getCanonicalName() ==> java.lang.Class.getCanonicalName()
  Line 198) node.getClass() ==> java.lang.Object.getClass()
  Line 103) actualType.isPrimitive() ==> com.github.javaparser.symbolsolver.model.typesystem.Type.isPrimitive()
  Line 145) actual.isReferenceType() ==> com.github.javaparser.symbolsolver.model.typesystem.Type.isReferenceType()
  Line 104) ((InferenceVariableType) formalType).registerEquivalentType(actualType) ==> com.github.javaparser.symbolsolver.logic.InferenceVariableType.registerEquivalentType(com.github.javaparser.symbolsolver.model.typesystem.Type)
  Line 106) ((InferenceVariableType) actualType).registerEquivalentType(formalType) ==> com.github.javaparser.symbolsolver.logic.InferenceVariableType.registerEquivalentType(com.github.javaparser.symbolsolver.model.typesystem.Type)
  Line 108) actualType.isNull() ==> com.github.javaparser.symbolsolver.model.typesystem.Type.isNull()
  Line 110) actualType.equals(formalType) ==> java.lang.Object.equals(java.lang.Object)
  Line 203) node.getClass().getCanonicalName() ==> java.lang.Class.getCanonicalName()
  Line 112) actualType.isArray() ==> com.github.javaparser.symbolsolver.model.typesystem.Type.isArray()
  Line 146) isAssignableMatchTypeParameters(expected.asReferenceType(), actual.asReferenceType(), matchedParameters) ==> com.github.javaparser.symbolsolver.resolution.MethodResolutionLogic.isAssignableMatchTypeParameters(com.github.javaparser.symbolsolver.model.typesystem.ReferenceType, com.github.javaparser.symbolsolver.model.typesystem.ReferenceType, java.util.Map<java.lang.String, com.github.javaparser.symbolsolver.model.typesystem.Type>)
  Line 203) node.getClass() ==> java.lang.Object.getClass()
  Line 112) formalType.isArray() ==> com.github.javaparser.symbolsolver.model.typesystem.Type.isArray()
  Line 146) expected.asReferenceType() ==> com.github.javaparser.symbolsolver.model.typesystem.Type.asReferenceType()
  Line 113) registerCorrespondance(formalType.asArrayType().getComponentType(), actualType.asArrayType().getComponentType()) ==> com.github.javaparser.symbolsolver.logic.InferenceContext.registerCorrespondance(com.github.javaparser.symbolsolver.model.typesystem.Type, com.github.javaparser.symbolsolver.model.typesystem.Type)
  Line 303) ctClass.getInterfaces() ==> javassist.CtClass.getInterfaces()
  Line 113) formalType.asArrayType().getComponentType() ==> com.github.javaparser.symbolsolver.model.typesystem.ArrayType.getComponentType()
  Line 146) actual.asReferenceType() ==> com.github.javaparser.symbolsolver.model.typesystem.Type.asReferenceType()
  Line 306) Collectors.toList() ==> java.util.stream.Collectors.toList()
  Line 113) formalType.asArrayType() ==> com.github.javaparser.symbolsolver.model.typesystem.Type.asArrayType()
  Line 113) actualType.asArrayType().getComponentType() ==> com.github.javaparser.symbolsolver.model.typesystem.ArrayType.getComponentType()
  Line 147) expected.isTypeVariable() ==> com.github.javaparser.symbolsolver.model.typesystem.Type.isTypeVariable()
  Line 113) actualType.asArrayType() ==> com.github.javaparser.symbolsolver.model.typesystem.Type.asArrayType()
  Line 308) SignatureAttribute.toClassSignature(ctClass.getGenericSignature()) ==> javassist.bytecode.SignatureAttribute.toClassSignature(java.lang.String)
  Line 142) node.getChildNodes() ==> com.github.javaparser.ast.Node.getChildNodes()
  Line 148) matchedParameters.put(expected.asTypeParameter().getName(), actual) ==> java.util.Map.put(K, V)
  Line 148) expected.asTypeParameter().getName() ==> com.github.javaparser.symbolsolver.model.declarations.TypeParameterDeclaration.getName()
  Line 148) expected.asTypeParameter() ==> com.github.javaparser.symbolsolver.model.typesystem.Type.asTypeParameter()
  Line 208) node.getClass().getCanonicalName() ==> java.lang.Class.getCanonicalName()
  Line 308) ctClass.getGenericSignature() ==> javassist.CtClass.getGenericSignature()
  Line 208) node.getClass() ==> java.lang.Object.getClass()
  Line 114) formalType.isWildcard() ==> com.github.javaparser.symbolsolver.model.typesystem.Type.isWildcard()
  Line 116) formalType.asWildcard().isBounded() ==> com.github.javaparser.symbolsolver.model.typesystem.Wildcard.isBounded()
  Line 116) formalType.asWildcard() ==> com.github.javaparser.symbolsolver.model.typesystem.Type.asWildcard()
  Line 151) expected.getClass().getCanonicalName() ==> java.lang.Class.getCanonicalName()
  Line 151) expected.getClass() ==> java.lang.Object.getClass()
  Line 151) actual.getClass().getCanonicalName() ==> java.lang.Class.getCanonicalName()
  Line 151) actual.getClass() ==> java.lang.Object.getClass()
  Line 62) clazz.isInterface() ==> java.lang.Class.isInterface()
  Line 65) clazz.isPrimitive() ==> java.lang.Class.isPrimitive()
  Line 68) clazz.isArray() ==> java.lang.Class.isArray()
  Line 71) clazz.isEnum() ==> java.lang.Class.isEnum()
  Line 117) ((InferenceVariableType) actualType).registerEquivalentType(formalType.asWildcard().getBoundedType()) ==> com.github.javaparser.symbolsolver.logic.InferenceVariableType.registerEquivalentType(com.github.javaparser.symbolsolver.model.typesystem.Type)
  Line 139) typeDeclaration.getTypeParameters().stream().map(tp -> typeParametersMap().getValue(tp).describe()).collect(Collectors.toList()) ==> java.util.stream.Stream.collect(java.util.stream.Collector<? super T, A, R>)
  Line 117) formalType.asWildcard().getBoundedType() ==> com.github.javaparser.symbolsolver.model.typesystem.Wildcard.getBoundedType()
  Line 139) typeDeclaration.getTypeParameters().stream().map(tp -> typeParametersMap().getValue(tp).describe()) ==> java.util.stream.Stream.map(java.util.function.Function<? super T, ? extends R>)
  Line 139) typeDeclaration.getTypeParameters().stream() ==> java.util.Collection.stream()
  Line 139) typeDeclaration.getTypeParameters() ==> com.github.javaparser.symbolsolver.model.declarations.TypeParametrizable.getTypeParameters()
  Line 140) typeParametersMap().getValue(tp).describe() ==> com.github.javaparser.symbolsolver.model.typesystem.Type.describe()
  Line 85) reflectionClassAdapter.getDeclaredMethods() ==> com.github.javaparser.symbolsolver.reflectionmodel.ReflectionClassAdapter.getDeclaredMethods()
  Line 90) reflectionClassAdapter.getAncestors() ==> com.github.javaparser.symbolsolver.reflectionmodel.ReflectionClassAdapter.getAncestors()
  Line 96) getClass() ==> java.lang.Object.getClass()
  Line 213) node.getClass().getCanonicalName() ==> java.lang.Class.getCanonicalName()
  Line 140) typeParametersMap().getValue(tp) ==> com.github.javaparser.symbolsolver.model.typesystem.parametrization.TypeParametersMap.getValue(com.github.javaparser.symbolsolver.model.declarations.TypeParameterDeclaration)
  Line 140) typeParametersMap() ==> com.github.javaparser.symbolsolver.model.typesystem.ReferenceType.typeParametersMap()
  Line 141) Collectors.toList() ==> java.util.stream.Collectors.toList()
  Line 96) o.getClass() ==> java.lang.Object.getClass()
  Line 142) sb.append(">") ==> java.lang.StringBuilder.append(java.lang.String)
  Line 100) clazz.getCanonicalName().equals(that.clazz.getCanonicalName()) ==> java.lang.String.equals(java.lang.Object)
  Line 157) actual.getQualifiedName().equals(expected.getQualifiedName()) ==> java.lang.String.equals(java.lang.Object)
  Line 143) solveMethodCalls(child) ==> com.github.javaparser.symbolsolver.SourceFileInfoExtractor.solveMethodCalls(com.github.javaparser.ast.Node)
  Line 117) formalType.asWildcard() ==> com.github.javaparser.symbolsolver.model.typesystem.Type.asWildcard()
  Line 118) formalType.asWildcard().getBoundedType() ==> com.github.javaparser.symbolsolver.model.typesystem.Wildcard.getBoundedType()
  Line 118) formalType.asWildcard() ==> com.github.javaparser.symbolsolver.model.typesystem.Type.asWildcard()
  Line 119) ((InferenceVariableType) formalType.asWildcard().getBoundedType()).registerEquivalentType(actualType) ==> com.github.javaparser.symbolsolver.logic.InferenceVariableType.registerEquivalentType(com.github.javaparser.symbolsolver.model.typesystem.Type)
  Line 119) formalType.asWildcard().getBoundedType() ==> com.github.javaparser.symbolsolver.model.typesystem.Wildcard.getBoundedType()
  Line 119) formalType.asWildcard() ==> com.github.javaparser.symbolsolver.model.typesystem.Type.asWildcard()
  Line 122) actualType.isWildcard() ==> com.github.javaparser.symbolsolver.model.typesystem.Type.isWildcard()
  Line 123) formalType.asWildcard() ==> com.github.javaparser.symbolsolver.model.typesystem.Type.asWildcard()
  Line 124) actualType.asWildcard() ==> com.github.javaparser.symbolsolver.model.typesystem.Type.asWildcard()
  Line 125) formalWildcard.isBounded() ==> com.github.javaparser.symbolsolver.model.typesystem.Wildcard.isBounded()
  Line 125) formalWildcard.getBoundedType() ==> com.github.javaparser.symbolsolver.model.typesystem.Wildcard.getBoundedType()
  Line 100) clazz.getCanonicalName() ==> java.lang.Class.getCanonicalName()
  Line 100) that.clazz.getCanonicalName() ==> java.lang.Class.getCanonicalName()
  Line 144) sb.toString() ==> java.lang.StringBuilder.toString()
  Line 157) this.typeParametersValues() ==> com.github.javaparser.symbolsolver.model.typesystem.ReferenceType.typeParametersValues()
  Line 107) clazz.hashCode() ==> java.lang.Object.hashCode()
  Line 158) transformer.transform(tp) ==> com.github.javaparser.symbolsolver.model.typesystem.TypeTransformer.transform(com.github.javaparser.symbolsolver.model.typesystem.Type)
  Line 113) clazz.getPackage() ==> java.lang.Class.getPackage()
  Line 157) actual.getQualifiedName() ==> com.github.javaparser.symbolsolver.model.typesystem.ReferenceType.getQualifiedName()
  Line 157) expected.getQualifiedName() ==> com.github.javaparser.symbolsolver.model.typesystem.ReferenceType.getQualifiedName()
  Line 114) clazz.getPackage().getName() ==> java.lang.Package.getName()
  Line 114) clazz.getPackage() ==> java.lang.Class.getPackage()
  Line 121) clazz.getCanonicalName() ==> java.lang.Class.getCanonicalName()
  Line 126) formalWildcard.isSuper() ==> com.github.javaparser.symbolsolver.model.typesystem.Wildcard.isSuper()
  Line 122) getPackageName() ==> com.github.javaparser.symbolsolver.reflectionmodel.ReflectionClassDeclaration.getPackageName()
  Line 161) result.asReferenceType().typeParametersValues() ==> com.github.javaparser.symbolsolver.model.typesystem.ReferenceType.typeParametersValues()
  Line 161) result.asReferenceType() ==> com.github.javaparser.symbolsolver.model.typesystem.Type.asReferenceType()
  Line 309) Arrays.stream(classSignature.getInterfaces()).map(i -> JavassistUtils.signatureTypeToType(i, typeSolver, this).asReferenceType()).collect(Collectors.toList()) ==> ERROR
  Line 309) Arrays.stream(classSignature.getInterfaces()).map(i -> JavassistUtils.signatureTypeToType(i, typeSolver, this).asReferenceType()) ==> java.util.stream.Stream.map(java.util.function.Function<? super T, ? extends R>)
  Line 309) Arrays.stream(classSignature.getInterfaces()) ==> java.util.Arrays.stream(T[])
  Line 158) isAssignableMatchTypeParametersMatchingQName(expected, actual, matchedParameters) ==> com.github.javaparser.symbolsolver.resolution.MethodResolutionLogic.isAssignableMatchTypeParametersMatchingQName(com.github.javaparser.symbolsolver.model.typesystem.ReferenceType, com.github.javaparser.symbolsolver.model.typesystem.ReferenceType, java.util.Map<java.lang.String, com.github.javaparser.symbolsolver.model.typesystem.Type>)
  Line 160) actual.getAllAncestors() ==> com.github.javaparser.symbolsolver.model.typesystem.ReferenceType.getAllAncestors()
  Line 123) canonicalName.substring(getPackageName().length() + 1, canonicalName.length()) ==> java.lang.String.substring(int, int)
  Line 123) getPackageName().length() ==> java.lang.String.length()
  Line 213) node.getClass() ==> java.lang.Object.getClass()
  Line 123) getPackageName() ==> com.github.javaparser.symbolsolver.reflectionmodel.ReflectionClassDeclaration.getPackageName()
  Line 218) node.getClass().getCanonicalName() ==> java.lang.Class.getCanonicalName()
  Line 218) node.getClass() ==> java.lang.Object.getClass()
  Line 126) actualWildcard.isSuper() ==> com.github.javaparser.symbolsolver.model.typesystem.Wildcard.isSuper()
  Line 127) ((InferenceVariableType) formalType.asWildcard().getBoundedType()).registerEquivalentType(actualWildcard.getBoundedType()) ==> com.github.javaparser.symbolsolver.logic.InferenceVariableType.registerEquivalentType(com.github.javaparser.symbolsolver.model.typesystem.Type)
  Line 127) formalType.asWildcard().getBoundedType() ==> com.github.javaparser.symbolsolver.model.typesystem.Wildcard.getBoundedType()
  Line 127) formalType.asWildcard() ==> com.github.javaparser.symbolsolver.model.typesystem.Type.asWildcard()
  Line 309) classSignature.getInterfaces() ==> javassist.bytecode.SignatureAttribute.ClassSignature.getInterfaces()
  Line 310) JavassistUtils.signatureTypeToType(i, typeSolver, this).asReferenceType() ==> com.github.javaparser.symbolsolver.model.typesystem.Type.asReferenceType()
  Line 123) canonicalName.length() ==> java.lang.String.length()
  Line 130) clazz.getCanonicalName() ==> java.lang.Class.getCanonicalName()
  Line 162) typeParametersCorrected.set(i, transformedTp) ==> java.util.List.set(int, E)
  Line 310) JavassistUtils.signatureTypeToType(i, typeSolver, this) ==> com.github.javaparser.symbolsolver.javassistmodel.JavassistUtils.signatureTypeToType(javassist.bytecode.SignatureAttribute.Type, com.github.javaparser.symbolsolver.model.resolution.TypeSolver, com.github.javaparser.symbolsolver.model.declarations.TypeParametrizable)
  Line 311) Collectors.toList() ==> java.util.stream.Collectors.toList()
  Line 136) Modifier.isStatic(m.getModifiers()) ==> java.lang.reflect.Modifier.isStatic(int)
  Line 163) create(typeDeclaration, typeParametersCorrected, typeSolver) ==> com.github.javaparser.symbolsolver.model.typesystem.ReferenceType.create(com.github.javaparser.symbolsolver.model.declarations.ReferenceTypeDeclaration, java.util.List<com.github.javaparser.symbolsolver.model.typesystem.Type>, com.github.javaparser.symbolsolver.model.resolution.TypeSolver)
  Line 136) m.getModifiers() ==> java.lang.reflect.Method.getModifiers()
  Line 178) this.typeParametersValues() ==> com.github.javaparser.symbolsolver.model.typesystem.ReferenceType.typeParametersValues()
  Line 237) node.getParentNode().isPresent() ==> java.util.Optional.isPresent()
  Line 237) node.getParentNode() ==> com.github.javaparser.ast.Node.getParentNode()
  Line 223) node.getClass().getCanonicalName() ==> java.lang.Class.getCanonicalName()
  Line 322) ctClass.isInterface() ==> javassist.CtClass.isInterface()
  Line 238) Optional.empty() ==> java.util.Optional.empty()
  Line 179) tp.replaceTypeVariables(tpToReplace, replaced, inferredTypes) ==> com.github.javaparser.symbolsolver.model.typesystem.Type.replaceTypeVariables(com.github.javaparser.symbolsolver.model.declarations.TypeParameterDeclaration, com.github.javaparser.symbolsolver.model.typesystem.Type, java.util.Map<com.github.javaparser.symbolsolver.model.declarations.TypeParameterDeclaration, com.github.javaparser.symbolsolver.model.typesystem.Type>)
  Line 127) actualWildcard.getBoundedType() ==> com.github.javaparser.symbolsolver.model.typesystem.Wildcard.getBoundedType()
  Line 128) formalWildcard.isExtends() ==> com.github.javaparser.symbolsolver.model.typesystem.Wildcard.isExtends()
  Line 128) actualWildcard.isExtends() ==> com.github.javaparser.symbolsolver.model.typesystem.Wildcard.isExtends()
  Line 129) ((InferenceVariableType) formalType.asWildcard().getBoundedType()).registerEquivalentType(actualWildcard.getBoundedType()) ==> com.github.javaparser.symbolsolver.logic.InferenceVariableType.registerEquivalentType(com.github.javaparser.symbolsolver.model.typesystem.Type)
  Line 181) tp.isTypeVariable() ==> com.github.javaparser.symbolsolver.model.typesystem.Type.isTypeVariable()
  Line 162) isAssignableMatchTypeParametersMatchingQName(expected, ancestor, matchedParameters) ==> com.github.javaparser.symbolsolver.resolution.MethodResolutionLogic.isAssignableMatchTypeParametersMatchingQName(com.github.javaparser.symbolsolver.model.typesystem.ReferenceType, com.github.javaparser.symbolsolver.model.typesystem.ReferenceType, java.util.Map<java.lang.String, com.github.javaparser.symbolsolver.model.typesystem.Type>)
  Line 327) ctClass.getName() ==> javassist.CtClass.getName()
  Line 223) node.getClass() ==> java.lang.Object.getClass()
  Line 239) clazz.isInstance(node.getParentNode().get()) ==> java.lang.Class.isInstance(java.lang.Object)
  Line 239) node.getParentNode().get() ==> java.util.Optional.get()
  Line 239) node.getParentNode() ==> com.github.javaparser.ast.Node.getParentNode()
  Line 228) node.getClass().getCanonicalName() ==> java.lang.Class.getCanonicalName()
  Line 332) javassistTypeDeclarationAdapter.getTypeParameters() ==> com.github.javaparser.symbolsolver.javassistmodel.JavassistTypeDeclarationAdapter.getTypeParameters()
  Line 228) node.getClass() ==> java.lang.Object.getClass()
  Line 337) JavassistFactory.modifiersToAccessLevel(ctClass.getModifiers()) ==> com.github.javaparser.symbolsolver.javassistmodel.JavassistFactory.modifiersToAccessLevel(int)
  Line 233) node.getClass().getCanonicalName() ==> java.lang.Class.getCanonicalName()
  Line 233) node.getClass() ==> java.lang.Object.getClass()
  Line 181) tp.asTypeVariable().describe().equals(tpToReplace.getName()) ==> java.lang.String.equals(java.lang.Object)
  Line 181) tp.asTypeVariable().describe() ==> com.github.javaparser.symbolsolver.model.typesystem.TypeVariable.describe()
  Line 129) formalType.asWildcard().getBoundedType() ==> com.github.javaparser.symbolsolver.model.typesystem.Wildcard.getBoundedType()
  Line 337) ctClass.getModifiers() ==> javassist.CtClass.getModifiers()
  Line 181) tp.asTypeVariable() ==> com.github.javaparser.symbolsolver.model.typesystem.Type.asTypeVariable()
  Line 181) tpToReplace.getName() ==> com.github.javaparser.symbolsolver.model.declarations.TypeParameterDeclaration.getName()
  Line 238) node.getClass().getCanonicalName() ==> java.lang.Class.getCanonicalName()
  Line 129) formalType.asWildcard() ==> com.github.javaparser.symbolsolver.model.typesystem.Type.asWildcard()
  Line 129) actualWildcard.getBoundedType() ==> com.github.javaparser.symbolsolver.model.typesystem.Wildcard.getBoundedType()
  Line 134) actualType.isReferenceType() ==> com.github.javaparser.symbolsolver.model.typesystem.Type.isReferenceType()
  Line 135) formalType.asWildcard().isBounded() ==> com.github.javaparser.symbolsolver.model.typesystem.Wildcard.isBounded()
  Line 182) inferredTypes.put(tp.asTypeParameter(), replaced) ==> java.util.Map.put(K, V)
  Line 135) formalType.asWildcard() ==> com.github.javaparser.symbolsolver.model.typesystem.Type.asWildcard()
  Line 342) javassistTypeDeclarationAdapter.getConstructors() ==> com.github.javaparser.symbolsolver.javassistmodel.JavassistTypeDeclarationAdapter.getConstructors()
  Line 347) javassistTypeDeclarationAdapter.containerType() ==> com.github.javaparser.symbolsolver.javassistmodel.JavassistTypeDeclarationAdapter.containerType()
  Line 173) expected.getQualifiedName().equals(actual.getQualifiedName()) ==> java.lang.String.equals(java.lang.Object)
  Line 173) expected.getQualifiedName() ==> com.github.javaparser.symbolsolver.model.typesystem.ReferenceType.getQualifiedName()
  Line 173) actual.getQualifiedName() ==> com.github.javaparser.symbolsolver.model.typesystem.ReferenceType.getQualifiedName()
  Line 238) node.getClass() ==> java.lang.Object.getClass()
  Line 176) expected.typeParametersValues().size() ==> java.util.List.size()
  Line 176) expected.typeParametersValues() ==> com.github.javaparser.symbolsolver.model.typesystem.ReferenceType.typeParametersValues()
  Line 243) node.getClass().getCanonicalName() ==> java.lang.Class.getCanonicalName()
  Line 243) node.getClass() ==> java.lang.Object.getClass()
  Line 136) registerCorrespondance(formalType.asWildcard().getBoundedType(), actualType) ==> com.github.javaparser.symbolsolver.logic.InferenceContext.registerCorrespondance(com.github.javaparser.symbolsolver.model.typesystem.Type, com.github.javaparser.symbolsolver.model.typesystem.Type)
  Line 136) formalType.asWildcard().getBoundedType() ==> com.github.javaparser.symbolsolver.model.typesystem.Wildcard.getBoundedType()
  Line 136) formalType.asWildcard() ==> com.github.javaparser.symbolsolver.model.typesystem.Type.asWildcard()
  Line 141) ((InferenceVariableType) actualType).registerEquivalentType(formalType) ==> com.github.javaparser.symbolsolver.logic.InferenceVariableType.registerEquivalentType(com.github.javaparser.symbolsolver.model.typesystem.Type)
  Line 143) ((InferenceVariableType) actualType).registerEquivalentType(formalType) ==> com.github.javaparser.symbolsolver.logic.InferenceVariableType.registerEquivalentType(com.github.javaparser.symbolsolver.model.typesystem.Type)
  Line 145) actualType.isConstraint() ==> com.github.javaparser.symbolsolver.model.typesystem.Type.isConstraint()
  Line 240) Optional.of(clazz.cast(node.getParentNode().get())) ==> java.util.Optional.of(T)
  Line 240) clazz.cast(node.getParentNode().get()) ==> java.lang.Class.cast(java.lang.Object)
  Line 240) node.getParentNode().get() ==> java.util.Optional.get()
  Line 248) node.getClass().getCanonicalName() ==> java.lang.Class.getCanonicalName()
  Line 248) node.getClass() ==> java.lang.Object.getClass()
  Line 176) actual.typeParametersValues().size() ==> java.util.List.size()
  Line 240) node.getParentNode() ==> com.github.javaparser.ast.Node.getParentNode()
  Line 182) tp.asTypeParameter() ==> com.github.javaparser.symbolsolver.model.typesystem.Type.asTypeParameter()
  Line 185) result.asReferenceType().typeParametersValues() ==> com.github.javaparser.symbolsolver.model.typesystem.ReferenceType.typeParametersValues()
  Line 185) result.asReferenceType() ==> com.github.javaparser.symbolsolver.model.typesystem.ReferenceType.asReferenceType()
  Line 186) typeParametersCorrected.set(i, transformedTp) ==> java.util.List.set(int, E)
  Line 176) actual.typeParametersValues() ==> com.github.javaparser.symbolsolver.model.typesystem.ReferenceType.typeParametersValues()
  Line 180) expected.typeParametersValues().size() ==> java.util.List.size()
  Line 242) findAncestor(node.getParentNode().get(), clazz) ==> com.github.javaparser.symbolsolver.javaparser.Navigator.findAncestor(com.github.javaparser.ast.Node, java.lang.Class<N>)
  Line 242) node.getParentNode().get() ==> java.util.Optional.get()
  Line 242) node.getParentNode() ==> com.github.javaparser.ast.Node.getParentNode()
  Line 146) actualType.asConstraintType() ==> com.github.javaparser.symbolsolver.model.typesystem.Type.asConstraintType()
  Line 180) expected.typeParametersValues() ==> com.github.javaparser.symbolsolver.model.typesystem.ReferenceType.typeParametersValues()
  Line 251) qualifiedName.split("\\.", 2) ==> java.lang.String.split(java.lang.String, int)
  Line 147) constraintType.getBound() ==> com.github.javaparser.symbolsolver.model.typesystem.LambdaConstraintType.getBound()
  Line 255) qualifiedName.contains(".") ==> java.lang.String.contains(java.lang.CharSequence)
  Line 148) ((InferenceVariableType) constraintType.getBound()).registerEquivalentType(formalType) ==> com.github.javaparser.symbolsolver.logic.InferenceVariableType.registerEquivalentType(com.github.javaparser.symbolsolver.model.typesystem.Type)
  Line 148) constraintType.getBound() ==> com.github.javaparser.symbolsolver.model.typesystem.LambdaConstraintType.getBound()
  Line 150) actualType.isPrimitive() ==> com.github.javaparser.symbolsolver.model.typesystem.Type.isPrimitive()
  Line 137) Arrays.stream(clazz.getDeclaredMethods()).filter((m) -> m.getName().equals(name)).filter(staticFilter).sorted(new MethodComparator()).collect(Collectors.toList()) ==> java.util.stream.Stream.collect(java.util.stream.Collector<? super T, A, R>)
  Line 151) formalType.isPrimitive() ==> com.github.javaparser.symbolsolver.model.typesystem.Type.isPrimitive()
  Line 137) Arrays.stream(clazz.getDeclaredMethods()).filter((m) -> m.getName().equals(name)).filter(staticFilter).sorted(new MethodComparator()) ==> java.util.stream.Stream.sorted(java.util.Comparator<? super T>)
  Line 357) Arrays.stream(ctClass.getDeclaredClasses()).map(itype -> JavassistFactory.toTypeDeclaration(itype, typeSolver)).collect(Collectors.toSet()) ==> java.util.stream.Stream.collect(java.util.stream.Collector<? super T, A, R>)
  Line 137) Arrays.stream(clazz.getDeclaredMethods()).filter((m) -> m.getName().equals(name)).filter(staticFilter) ==> java.util.stream.Stream.filter(java.util.function.Predicate<? super T>)
  Line 357) Arrays.stream(ctClass.getDeclaredClasses()).map(itype -> JavassistFactory.toTypeDeclaration(itype, typeSolver)) ==> java.util.stream.Stream.map(java.util.function.Function<? super T, ? extends R>)
  Line 137) Arrays.stream(clazz.getDeclaredMethods()).filter((m) -> m.getName().equals(name)) ==> java.util.stream.Stream.filter(java.util.function.Predicate<? super T>)
  Line 357) Arrays.stream(ctClass.getDeclaredClasses()) ==> java.util.Arrays.stream(T[])
  Line 357) ctClass.getDeclaredClasses() ==> javassist.CtClass.getDeclaredClasses()
  Line 256) qualifiedName.split("\\.", 2) ==> java.lang.String.split(java.lang.String, int)
  Line 137) Arrays.stream(clazz.getDeclaredMethods()) ==> java.util.Arrays.stream(T[])
  Line 137) clazz.getDeclaredMethods() ==> java.lang.Class.getDeclaredMethods()
  Line 137) m.getName().equals(name) ==> java.lang.String.equals(java.lang.Object)
  Line 137) m.getName() ==> java.lang.reflect.Method.getName()
  Line 138) Collectors.toList() ==> java.util.stream.Collectors.toList()
  Line 357) JavassistFactory.toTypeDeclaration(itype, typeSolver) ==> com.github.javaparser.symbolsolver.javassistmodel.JavassistFactory.toTypeDeclaration(javassist.CtClass, com.github.javaparser.symbolsolver.model.resolution.TypeSolver)
  Line 357) Collectors.toSet() ==> java.util.stream.Collectors.toSet()
  Line 181) expected.typeParametersValues().get(i) ==> java.util.List.get(int)
  Line 139) method.isBridge() ==> java.lang.reflect.Method.isBridge()
  Line 154) registerCorrespondance(formalType, objectProvider.byName(actualType.asPrimitive().getBoxTypeQName())) ==> com.github.javaparser.symbolsolver.logic.InferenceContext.registerCorrespondance(com.github.javaparser.symbolsolver.model.typesystem.Type, com.github.javaparser.symbolsolver.model.typesystem.Type)
  Line 154) objectProvider.byName(actualType.asPrimitive().getBoxTypeQName()) ==> com.github.javaparser.symbolsolver.logic.ObjectProvider.byName(java.lang.String)
  Line 187) create(typeDeclaration, typeParametersCorrected, typeSolver) ==> com.github.javaparser.symbolsolver.model.typesystem.ReferenceType.create(com.github.javaparser.symbolsolver.model.declarations.ReferenceTypeDeclaration, java.util.List<com.github.javaparser.symbolsolver.model.typesystem.Type>, com.github.javaparser.symbolsolver.model.resolution.TypeSolver)
  Line 154) actualType.asPrimitive().getBoxTypeQName() ==> com.github.javaparser.symbolsolver.model.typesystem.PrimitiveType.getBoxTypeQName()
  Line 154) actualType.asPrimitive() ==> com.github.javaparser.symbolsolver.model.typesystem.Type.asPrimitive()
  Line 192) result.typeParametersValues() ==> com.github.javaparser.symbolsolver.model.typesystem.ReferenceType.typeParametersValues()
  Line 157) formalType.describe() ==> com.github.javaparser.symbolsolver.model.typesystem.Type.describe()
  Line 181) expected.typeParametersValues() ==> com.github.javaparser.symbolsolver.model.typesystem.ReferenceType.typeParametersValues()
  Line 193) values.contains(tpToReplace) ==> java.util.List.contains(java.lang.Object)
  Line 370) this.internalTypes().stream().filter(f -> f.getName().endsWith(name)).findFirst() ==> ERROR
  Line 370) this.internalTypes().stream().filter(f -> f.getName().endsWith(name)) ==> java.util.stream.Stream.filter(java.util.function.Predicate<? super T>)
  Line 370) this.internalTypes().stream() ==> java.util.Collection.stream()
  Line 139) method.isSynthetic() ==> java.lang.reflect.Method.isSynthetic()
  Line 182) actual.typeParametersValues().get(i) ==> java.util.List.get(int)
  Line 370) this.internalTypes() ==> com.github.javaparser.symbolsolver.javassistmodel.JavassistClassDeclaration.internalTypes()
  Line 265) node.getChildNodes() ==> com.github.javaparser.ast.Node.getChildNodes()
  Line 182) actual.typeParametersValues() ==> com.github.javaparser.symbolsolver.model.typesystem.ReferenceType.typeParametersValues()
  Line 266) findSwitchHelper(child) ==> com.github.javaparser.symbolsolver.javaparser.Navigator.findSwitchHelper(com.github.javaparser.ast.Node)
  Line 157) actualType.describe() ==> com.github.javaparser.symbolsolver.model.typesystem.Type.describe()
  Line 162) type.isWildcard() ==> com.github.javaparser.symbolsolver.model.typesystem.Type.isWildcard()
  Line 370) f.getName().endsWith(name) ==> ERROR
  Line 163) type.asWildcard().isExtends() ==> com.github.javaparser.symbolsolver.model.typesystem.Wildcard.isExtends()
  Line 194) values.indexOf(tpToReplace) ==> java.util.List.indexOf(java.lang.Object)
  Line 275) clazz.isInstance(node) ==> java.lang.Class.isInstance(java.lang.Object)
  Line 195) values.set(index, replaced) ==> java.util.List.set(int, E)
  Line 276) clazz.cast(node) ==> java.lang.Class.cast(java.lang.Object)
  Line 278) node.getChildNodes() ==> com.github.javaparser.ast.Node.getChildNodes()
  Line 196) create(result.getTypeDeclaration(), values, typeSolver) ==> com.github.javaparser.symbolsolver.model.typesystem.ReferenceType.create(com.github.javaparser.symbolsolver.model.declarations.ReferenceTypeDeclaration, java.util.List<com.github.javaparser.symbolsolver.model.typesystem.Type>, com.github.javaparser.symbolsolver.model.resolution.TypeSolver)
  Line 196) result.getTypeDeclaration() ==> com.github.javaparser.symbolsolver.model.typesystem.ReferenceType.getTypeDeclaration()
  Line 279) findNodeOfGivenClassHelper(child, clazz) ==> com.github.javaparser.symbolsolver.javaparser.Navigator.findNodeOfGivenClassHelper(com.github.javaparser.ast.Node, java.lang.Class<N>)
  Line 233) typeDeclaration.getAllAncestors() ==> com.github.javaparser.symbolsolver.model.declarations.ReferenceTypeDeclaration.getAllAncestors()
  Line 163) type.asWildcard() ==> com.github.javaparser.symbolsolver.model.typesystem.Type.asWildcard()
  Line 186) expectedParam.isReferenceType() ==> com.github.javaparser.symbolsolver.model.typesystem.Type.isReferenceType()
  Line 370) f.getName() ==> com.github.javaparser.symbolsolver.model.declarations.Declaration.getName()
  Line 186) actualParam.isReferenceType() ==> com.github.javaparser.symbolsolver.model.typesystem.Type.isReferenceType()
  Line 164) Wildcard.extendsBound(placeInferenceVariables(type.asWildcard().getBoundedType())) ==> com.github.javaparser.symbolsolver.model.typesystem.Wildcard.extendsBound(com.github.javaparser.symbolsolver.model.typesystem.Type)
  Line 187) expectedParam.asReferenceType() ==> com.github.javaparser.symbolsolver.model.typesystem.Type.asReferenceType()
  Line 164) placeInferenceVariables(type.asWildcard().getBoundedType()) ==> com.github.javaparser.symbolsolver.logic.InferenceContext.placeInferenceVariables(com.github.javaparser.symbolsolver.model.typesystem.Type)
  Line 164) type.asWildcard().getBoundedType() ==> com.github.javaparser.symbolsolver.model.typesystem.Wildcard.getBoundedType()
  Line 164) type.asWildcard() ==> com.github.javaparser.symbolsolver.model.typesystem.Type.asWildcard()
  Line 136) JavaParserFacade.get(this).getTypeDeclaration(astTypeDeclaration.get()) ==> com.github.javaparser.symbolsolver.javaparsermodel.JavaParserFacade.getTypeDeclaration(com.github.javaparser.ast.body.TypeDeclaration<?>)
  Line 165) type.asWildcard().isSuper() ==> com.github.javaparser.symbolsolver.model.typesystem.Wildcard.isSuper()
  Line 165) type.asWildcard() ==> com.github.javaparser.symbolsolver.model.typesystem.Type.asWildcard()
  Line 136) JavaParserFacade.get(this) ==> com.github.javaparser.symbolsolver.javaparsermodel.JavaParserFacade.get(com.github.javaparser.symbolsolver.model.resolution.TypeSolver)
  Line 136) astTypeDeclaration.get() ==> java.util.Optional.get()
  Line 143) parseDirectory(srcFile.getParentFile()) ==> com.github.javaparser.symbolsolver.resolution.typesolvers.JavaParserTypeSolver.parseDirectory(java.io.File)
  Line 143) srcFile.getParentFile() ==> java.io.File.getParentFile()
  Line 166) Wildcard.superBound(placeInferenceVariables(type.asWildcard().getBoundedType())) ==> com.github.javaparser.symbolsolver.model.typesystem.Wildcard.superBound(com.github.javaparser.symbolsolver.model.typesystem.Type)
  Line 166) placeInferenceVariables(type.asWildcard().getBoundedType()) ==> com.github.javaparser.symbolsolver.logic.InferenceContext.placeInferenceVariables(com.github.javaparser.symbolsolver.model.typesystem.Type)
  Line 166) type.asWildcard().getBoundedType() ==> com.github.javaparser.symbolsolver.model.typesystem.Wildcard.getBoundedType()
  Line 166) type.asWildcard() ==> com.github.javaparser.symbolsolver.model.typesystem.Type.asWildcard()
  Line 170) type.isTypeVariable() ==> com.github.javaparser.symbolsolver.model.typesystem.Type.isTypeVariable()
  Line 171) inferenceVariableTypeForTp(type.asTypeParameter()) ==> com.github.javaparser.symbolsolver.logic.InferenceContext.inferenceVariableTypeForTp(com.github.javaparser.symbolsolver.model.declarations.TypeParameterDeclaration)
  Line 171) type.asTypeParameter() ==> com.github.javaparser.symbolsolver.model.typesystem.Type.asTypeParameter()
  Line 172) type.isReferenceType() ==> com.github.javaparser.symbolsolver.model.typesystem.Type.isReferenceType()
  Line 371) type.orElseThrow(() -> new UnsolvedSymbolException("Internal type not found: " + name)) ==> java.util.Optional.orElseThrow(java.util.function.Supplier<? extends X>)
  Line 381) this.internalTypes().stream().anyMatch(f -> f.getName().endsWith(name)) ==> java.util.stream.Stream.anyMatch(java.util.function.Predicate<? super T>)
  Line 381) this.internalTypes().stream() ==> java.util.Collection.stream()
  Line 381) this.internalTypes() ==> com.github.javaparser.symbolsolver.javassistmodel.JavassistClassDeclaration.internalTypes()
  Line 141) methods.add(methodDeclaration) ==> java.util.List.add(E)
  Line 143) getSuperClass() ==> com.github.javaparser.symbolsolver.reflectionmodel.ReflectionClassDeclaration.getSuperClass()
  Line 381) f.getName().endsWith(name) ==> java.lang.String.endsWith(java.lang.String)
  Line 144) getSuperClass().getTypeDeclaration() ==> com.github.javaparser.symbolsolver.model.typesystem.ReferenceType.getTypeDeclaration()
  Line 253) node.getClass().getCanonicalName() ==> java.lang.Class.getCanonicalName()
  Line 144) getSuperClass() ==> com.github.javaparser.symbolsolver.reflectionmodel.ReflectionClassDeclaration.getSuperClass()
  Line 188) actualParam.asReferenceType() ==> com.github.javaparser.symbolsolver.model.typesystem.Type.asReferenceType()
  Line 381) f.getName() ==> com.github.javaparser.symbolsolver.model.declarations.Declaration.getName()
  Line 288) clazz.isInstance(node) ==> java.lang.Class.isInstance(java.lang.Object)
  Line 190) isAssignableMatchTypeParametersMatchingQName(r1, r2, matchedParameters) ==> com.github.javaparser.symbolsolver.resolution.MethodResolutionLogic.isAssignableMatchTypeParametersMatchingQName(com.github.javaparser.symbolsolver.model.typesystem.ReferenceType, com.github.javaparser.symbolsolver.model.typesystem.ReferenceType, java.util.Map<java.lang.String, com.github.javaparser.symbolsolver.model.typesystem.Type>)
  Line 145) MethodResolutionLogic.solveMethodInType(superClass, name, argumentsTypes, staticOnly, typeSolver) ==> com.github.javaparser.symbolsolver.resolution.MethodResolutionLogic.solveMethodInType(com.github.javaparser.symbolsolver.model.declarations.TypeDeclaration, java.lang.String, java.util.List<com.github.javaparser.symbolsolver.model.typesystem.Type>, boolean, com.github.javaparser.symbolsolver.model.resolution.TypeSolver)
  Line 253) node.getClass() ==> java.lang.Object.getClass()
  Line 173) type.asReferenceType().transformTypeParameters(tp -> placeInferenceVariables(tp)) ==> com.github.javaparser.symbolsolver.model.typesystem.ReferenceType.transformTypeParameters(com.github.javaparser.symbolsolver.model.typesystem.TypeTransformer)
  Line 145) Navigator.findType(compilationUnit, typeName) ==> com.github.javaparser.symbolsolver.javaparser.Navigator.findType(com.github.javaparser.ast.CompilationUnit, java.lang.String)
  Line 86) JavaParserFacade.get(typeSolver).getTypeDeclaration(localType) ==> com.github.javaparser.symbolsolver.javaparsermodel.JavaParserFacade.getTypeDeclaration(com.github.javaparser.ast.body.TypeDeclaration<?>)
  Line 235) ancestors.stream().map(a -> typeParametersMap().replaceAll(a).asReferenceType()).collect(Collectors.toList()) ==> java.util.stream.Stream.collect(java.util.stream.Collector<? super T, A, R>)
  Line 70) getParentNode(wrappedNode) ==> com.github.javaparser.symbolsolver.javaparser.Navigator.getParentNode(com.github.javaparser.ast.Node)
  Line 149) toString(JavaParserFacade.get(typeSolver).solve(node)) ==> com.github.javaparser.symbolsolver.SourceFileInfoExtractor.toString(com.github.javaparser.symbolsolver.model.resolution.SymbolReference<com.github.javaparser.symbolsolver.model.declarations.MethodDeclaration>)
