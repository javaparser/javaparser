  Line 180) file.isDirectory() ==> java.io.File.isDirectory()
  Line 181) file.listFiles() ==> java.io.File.listFiles()
  Line 446) method.getParam(i).getType() ==> com.github.javaparser.symbolsolver.model.declarations.ValueDeclaration.getType()
  Line 446) method.getParam(i) ==> com.github.javaparser.symbolsolver.model.declarations.MethodLikeDeclaration.getParam(int)
  Line 182) solve(f) ==> com.github.javaparser.symbolsolver.SourceFileInfoExtractor.solve(java.io.File)
  Line 185) file.getName().endsWith(".java") ==> java.lang.String.endsWith(java.lang.String)
  Line 185) file.getName() ==> java.io.File.getName()
  Line 130) nameExpr.getId() ==> com.github.javaparser.ast.nodeTypes.NodeWithIdentifier.getId()
  Line 187) out.println("- parsing " + file.getAbsolutePath()) ==> java.io.PrintStream.println(java.lang.String)
  Line 187) file.getAbsolutePath() ==> java.io.File.getAbsolutePath()
  Line 446) argumentsTypes.get(i) ==> java.util.List.get(int)
  Line 455) methodA.getNumberOfParams() ==> com.github.javaparser.symbolsolver.model.declarations.MethodLikeDeclaration.getNumberOfParams()
  Line 39) clazz.isArray() ==> java.lang.Class.isArray()
  Line 41) clazz.isPrimitive() ==> java.lang.Class.isPrimitive()
  Line 43) clazz.isInterface() ==> java.lang.Class.isInterface()
  Line 45) clazz.isEnum() ==> java.lang.Class.isEnum()
  Line 161) ctClass.getInterfaces() ==> javassist.CtClass.getInterfaces()
  Line 455) methodB.getNumberOfParams() ==> com.github.javaparser.symbolsolver.model.declarations.MethodLikeDeclaration.getNumberOfParams()
  Line 458) methodA.getNumberOfParams() ==> com.github.javaparser.symbolsolver.model.declarations.MethodLikeDeclaration.getNumberOfParams()
  Line 458) methodB.getNumberOfParams() ==> com.github.javaparser.symbolsolver.model.declarations.MethodLikeDeclaration.getNumberOfParams()
  Line 461) methodA.getNumberOfParams() ==> com.github.javaparser.symbolsolver.model.declarations.MethodLikeDeclaration.getNumberOfParams()
  Line 462) methodA.getParam(i).getType() ==> com.github.javaparser.symbolsolver.model.declarations.ValueDeclaration.getType()
  Line 453) otherParam.asTypeVariable().asTypeParameter().getBounds(other.typeSolver).stream().map(bound -> bound.getType()) ==> java.util.stream.Stream.map(java.util.function.Function<? super T, ? extends R>)
  Line 453) otherParam.asTypeVariable().asTypeParameter().getBounds(other.typeSolver).stream() ==> java.util.Collection.stream()
  Line 453) otherParam.asTypeVariable().asTypeParameter().getBounds(other.typeSolver) ==> com.github.javaparser.symbolsolver.model.declarations.TypeParameterDeclaration.getBounds(com.github.javaparser.symbolsolver.model.resolution.TypeSolver)
  Line 453) otherParam.asTypeVariable().asTypeParameter() ==> com.github.javaparser.symbolsolver.model.typesystem.TypeVariable.asTypeParameter()
  Line 462) methodA.getParam(i) ==> com.github.javaparser.symbolsolver.model.declarations.MethodLikeDeclaration.getParam(int)
  Line 453) otherParam.asTypeVariable() ==> com.github.javaparser.symbolsolver.model.typesystem.Type.asTypeVariable()
  Line 463) methodB.getParam(i).getType() ==> com.github.javaparser.symbolsolver.model.declarations.ValueDeclaration.getType()
  Line 463) methodB.getParam(i) ==> com.github.javaparser.symbolsolver.model.declarations.MethodLikeDeclaration.getParam(int)
  Line 453) bound.getType() ==> com.github.javaparser.symbolsolver.model.declarations.TypeParameterDeclaration.Bound.getType()
  Line 453) Collectors.toList() ==> java.util.stream.Collectors.toList()
  Line 55) tv.getGenericDeclaration() ==> java.lang.reflect.TypeVariable.getGenericDeclaration()
  Line 189) JavaParser.parse(file) ==> com.github.javaparser.JavaParser.parse(java.io.File)
  Line 465) tdB.isAssignableBy(tdA) ==> com.github.javaparser.symbolsolver.model.typesystem.Type.isAssignableBy(com.github.javaparser.symbolsolver.model.typesystem.Type)
  Line 465) tdA.isAssignableBy(tdB) ==> com.github.javaparser.symbolsolver.model.typesystem.Type.isAssignableBy(com.github.javaparser.symbolsolver.model.typesystem.Type)
  Line 469) tdA.isAssignableBy(tdB) ==> com.github.javaparser.symbolsolver.model.typesystem.Type.isAssignableBy(com.github.javaparser.symbolsolver.model.typesystem.Type)
  Line 142) type.toString() ==> ERROR
  Line 145) SymbolReference.solved(new JavaParserTypeParameter(new TypeParameter(matchingType.toString()), typeSolver)) ==> com.github.javaparser.symbolsolver.model.resolution.SymbolReference.solved(S2)
  Line 190) collectAllNodes(cu) ==> com.github.javaparser.symbolsolver.SourceFileInfoExtractor.collectAllNodes(com.github.javaparser.ast.Node)
  Line 191) nodes.forEach(n -> solve(n)) ==> java.lang.Iterable.forEach(java.util.function.Consumer<? super T>)
  Line 162) JavassistFactory.typeUsageFor(interfaze, typeSolver).asReferenceType() ==> com.github.javaparser.symbolsolver.model.typesystem.Type.asReferenceType()
  Line 454) thisBounds.size() ==> java.util.List.size()
  Line 162) JavassistFactory.typeUsageFor(interfaze, typeSolver) ==> com.github.javaparser.symbolsolver.javassistmodel.JavassistFactory.typeUsageFor(javassist.CtClass, com.github.javaparser.symbolsolver.model.resolution.TypeSolver)
  Line 454) otherBounds.size() ==> java.util.List.size()
  Line 163) ancestors.add(superInterfaze) ==> java.util.List.add(E)
  Line 469) tdB.isAssignableBy(tdA) ==> com.github.javaparser.symbolsolver.model.typesystem.Type.isAssignableBy(com.github.javaparser.symbolsolver.model.typesystem.Type)
  Line 146) matchingType.toString() ==> ERROR
  Line 475) argumentTypes.size() ==> java.util.List.size()
  Line 477) methodA.hasVariadicParameter() ==> com.github.javaparser.symbolsolver.model.declarations.MethodLikeDeclaration.hasVariadicParameter()
  Line 477) methodB.hasVariadicParameter() ==> com.github.javaparser.symbolsolver.model.declarations.MethodLikeDeclaration.hasVariadicParameter()
  Line 479) argumentTypes.get(lastIndex).isArray() ==> com.github.javaparser.symbolsolver.model.typesystem.Type.isArray()
  Line 60) typeUsageFor(pt.getRawType(), typeSolver).asReferenceType() ==> com.github.javaparser.symbolsolver.model.typesystem.Type.asReferenceType()
  Line 454) otherBounds.containsAll(thisBounds) ==> java.util.List.containsAll(java.util.Collection<? extends java.lang.Object>)
  Line 149) typeArgumentsMatch.isPresent() ==> java.util.Optional.isPresent()
  Line 191) solve(n) ==> com.github.javaparser.symbolsolver.SourceFileInfoExtractor.solve(com.github.javaparser.ast.Node)
  Line 168) ancestors.stream().filter(a -> a.getQualifiedName() != Object.class.getCanonicalName()).collect(Collectors.toList()) ==> java.util.stream.Stream.collect(java.util.stream.Collector<? super T, A, R>)
  Line 168) ancestors.stream().filter(a -> a.getQualifiedName() != Object.class.getCanonicalName()) ==> java.util.stream.Stream.filter(java.util.function.Predicate<? super T>)
  Line 60) typeUsageFor(pt.getRawType(), typeSolver) ==> com.github.javaparser.symbolsolver.reflectionmodel.ReflectionFactory.typeUsageFor(java.lang.reflect.Type, com.github.javaparser.symbolsolver.model.resolution.TypeSolver)
  Line 60) pt.getRawType() ==> java.lang.reflect.ParameterizedType.getRawType()
  Line 479) argumentTypes.get(lastIndex) ==> java.util.List.get(int)
  Line 483) argumentTypes.get(lastIndex).isArray() ==> com.github.javaparser.symbolsolver.model.typesystem.Type.isArray()
  Line 483) argumentTypes.get(lastIndex) ==> java.util.List.get(int)
  Line 487) methodA.hasVariadicParameter() ==> com.github.javaparser.symbolsolver.model.declarations.MethodLikeDeclaration.hasVariadicParameter()
  Line 487) methodB.hasVariadicParameter() ==> com.github.javaparser.symbolsolver.model.declarations.MethodLikeDeclaration.hasVariadicParameter()
  Line 490) argumentTypes.get(lastIndex).isArray() ==> com.github.javaparser.symbolsolver.model.typesystem.Type.isArray()
  Line 490) argumentTypes.get(lastIndex) ==> java.util.List.get(int)
  Line 494) argumentTypes.get(lastIndex).isArray() ==> com.github.javaparser.symbolsolver.model.typesystem.Type.isArray()
  Line 197) file.isDirectory() ==> java.io.File.isDirectory()
  Line 198) file.listFiles() ==> java.io.File.listFiles()
  Line 199) solveMethodCalls(f) ==> com.github.javaparser.symbolsolver.SourceFileInfoExtractor.solveMethodCalls(java.io.File)
  Line 202) file.getName().endsWith(".java") ==> java.lang.String.endsWith(java.lang.String)
  Line 150) typeArgumentsMatch.get() ==> java.util.Optional.get()
  Line 154) myDeclaration.getAncestors() ==> com.github.javaparser.symbolsolver.javaparsermodel.declarations.JavaParserAnonymousClassDeclaration.getAncestors()
  Line 168) ancestors.stream() ==> java.util.Collection.stream()
  Line 156) ancestor.getTypeDeclaration().getName().equals(name) ==> java.lang.String.equals(java.lang.Object)
  Line 156) ancestor.getTypeDeclaration().getName() ==> com.github.javaparser.symbolsolver.model.declarations.Declaration.getName()
  Line 156) ancestor.getTypeDeclaration() ==> com.github.javaparser.symbolsolver.model.typesystem.ReferenceType.getTypeDeclaration()
  Line 157) SymbolReference.solved(ancestor.getTypeDeclaration()) ==> com.github.javaparser.symbolsolver.model.resolution.SymbolReference.solved(S2)
  Line 157) ancestor.getTypeDeclaration() ==> com.github.javaparser.symbolsolver.model.typesystem.ReferenceType.getTypeDeclaration()
  Line 168) a.getQualifiedName() ==> com.github.javaparser.symbolsolver.model.typesystem.ReferenceType.getQualifiedName()
  Line 168) Object.class.getCanonicalName() ==> java.lang.Class.getCanonicalName()
  Line 169) Collectors.toList() ==> java.util.stream.Collectors.toList()
  Line 202) file.getName() ==> java.io.File.getName()
  Line 170) ancestors.add(new ReferenceTypeImpl(typeSolver.solveType(Object.class.getCanonicalName()), typeSolver)) ==> java.util.List.add(E)
  Line 204) out.println("- parsing " + file.getAbsolutePath()) ==> java.io.PrintStream.println(java.lang.String)
  Line 204) file.getAbsolutePath() ==> java.io.File.getAbsolutePath()
  Line 472) typeDeclaration.getTypeParameters().stream().map((tp) -> new TypeVariable(tp)).collect(Collectors.toList()) ==> java.util.stream.Stream.collect(java.util.stream.Collector<? super T, A, R>)
  Line 472) typeDeclaration.getTypeParameters().stream().map((tp) -> new TypeVariable(tp)) ==> java.util.stream.Stream.map(java.util.function.Function<? super T, ? extends R>)
  Line 472) typeDeclaration.getTypeParameters().stream() ==> java.util.Collection.stream()
  Line 206) JavaParser.parse(file) ==> com.github.javaparser.JavaParser.parse(java.io.File)
  Line 472) typeDeclaration.getTypeParameters() ==> com.github.javaparser.symbolsolver.model.declarations.TypeParametrizable.getTypeParameters()
  Line 472) Collectors.toList() ==> java.util.stream.Collectors.toList()
  Line 476) create(typeDeclaration, typeParametersMap, typeSolver) ==> com.github.javaparser.symbolsolver.model.typesystem.ReferenceType.create(com.github.javaparser.symbolsolver.model.declarations.ReferenceTypeDeclaration, com.github.javaparser.symbolsolver.model.typesystem.parametrization.TypeParametersMap, com.github.javaparser.symbolsolver.model.resolution.TypeSolver)
  Line 494) argumentTypes.get(lastIndex) ==> java.util.List.get(int)
  Line 505) methodA.getNoParams() ==> com.github.javaparser.symbolsolver.model.methods.MethodUsage.getNoParams()
  Line 506) methodA.getParamType(i) ==> com.github.javaparser.symbolsolver.model.methods.MethodUsage.getParamType(int)
  Line 507) methodB.getParamType(i) ==> com.github.javaparser.symbolsolver.model.methods.MethodUsage.getParamType(int)
  Line 509) tdA.isAssignableBy(tdB) ==> com.github.javaparser.symbolsolver.model.typesystem.Type.isAssignableBy(com.github.javaparser.symbolsolver.model.typesystem.Type)
  Line 161) ancestor.getTypeDeclaration().internalTypes() ==> com.github.javaparser.symbolsolver.model.declarations.TypeDeclaration.internalTypes()
  Line 161) ancestor.getTypeDeclaration() ==> com.github.javaparser.symbolsolver.model.typesystem.ReferenceType.getTypeDeclaration()
  Line 162) internalTypeDeclaration.getName().equals(name) ==> java.lang.String.equals(java.lang.Object)
  Line 162) internalTypeDeclaration.getName() ==> com.github.javaparser.symbolsolver.model.declarations.Declaration.getName()
  Line 62) actualTypes.addAll(Arrays.asList(pt.getActualTypeArguments())) ==> java.util.List.addAll(java.util.Collection<? extends E>)
  Line 163) SymbolReference.solved(internalTypeDeclaration) ==> com.github.javaparser.symbolsolver.model.resolution.SymbolReference.solved(S2)
  Line 62) Arrays.asList(pt.getActualTypeArguments()) ==> java.util.Arrays.asList(T...)
  Line 62) pt.getActualTypeArguments() ==> java.lang.reflect.ParameterizedType.getActualTypeArguments()
  Line 171) getParent().solveType(name, typeSolver) ==> com.github.javaparser.symbolsolver.core.resolution.Context.solveType(java.lang.String, com.github.javaparser.symbolsolver.model.resolution.TypeSolver)
  Line 170) typeSolver.solveType(Object.class.getCanonicalName()) ==> com.github.javaparser.symbolsolver.model.resolution.TypeSolver.solveType(java.lang.String)
  Line 510) tdB.isAssignableBy(tdA) ==> com.github.javaparser.symbolsolver.model.typesystem.Type.isAssignableBy(com.github.javaparser.symbolsolver.model.typesystem.Type)
  Line 207) solveMethodCalls(cu) ==> com.github.javaparser.symbolsolver.SourceFileInfoExtractor.solveMethodCalls(com.github.javaparser.ast.Node)
  Line 135) solve((NameExpr) expr) ==> com.github.javaparser.symbolsolver.javaparsermodel.JavaParserFacade.solve(com.github.javaparser.ast.expr.NameExpr)
  Line 64) rawType.transformTypeParameters(tp -> typeUsageFor(actualTypes.remove(0), typeSolver)).asReferenceType() ==> com.github.javaparser.symbolsolver.model.typesystem.Type.asReferenceType()
