  Line 193) expectedParam.isTypeVariable() ==> com.github.javaparser.symbolsolver.model.typesystem.Type.isTypeVariable()
  Line 194) expectedParam.asTypeParameter().getName() ==> com.github.javaparser.symbolsolver.model.declarations.TypeParameterDeclaration.getName()
  Line 194) expectedParam.asTypeParameter() ==> com.github.javaparser.symbolsolver.model.typesystem.Type.asTypeParameter()
  Line 195) actualParam.isTypeVariable() ==> com.github.javaparser.symbolsolver.model.typesystem.Type.isTypeVariable()
  Line 146) ref.isSolved() ==> com.github.javaparser.symbolsolver.model.resolution.SymbolReference.isSolved()
  Line 195) actualParam.asTypeParameter().getName().equals(expectedParamName) ==> java.lang.String.equals(java.lang.Object)
  Line 195) actualParam.asTypeParameter().getName() ==> com.github.javaparser.symbolsolver.model.declarations.TypeParameterDeclaration.getName()
  Line 195) actualParam.asTypeParameter() ==> com.github.javaparser.symbolsolver.model.typesystem.Type.asTypeParameter()
  Line 196) matchedParameters.containsKey(expectedParamName) ==> java.util.Map.containsKey(java.lang.Object)
  Line 197) matchedParameters.get(expectedParamName) ==> java.util.Map.get(java.lang.Object)
  Line 258) node.getClass().getCanonicalName() ==> java.lang.Class.getCanonicalName()
  Line 198) matchedParameter.isAssignableBy(actualParam) ==> com.github.javaparser.symbolsolver.model.typesystem.Type.isAssignableBy(com.github.javaparser.symbolsolver.model.typesystem.Type)
  Line 258) node.getClass() ==> java.lang.Object.getClass()
  Line 52) ctConstructor.getName() ==> javassist.CtConstructor.getName()
  Line 72) ctConstructor.getDeclaringClass() ==> javassist.CtMember.getDeclaringClass()
  Line 263) node.getClass().getCanonicalName() ==> java.lang.Class.getCanonicalName()
  Line 78) ctConstructor.getParameterTypes() ==> javassist.CtBehavior.getParameterTypes()
  Line 88) ctConstructor.getModifiers() ==> javassist.CtBehavior.getModifiers()
  Line 89) ctConstructor.getParameterTypes() ==> javassist.CtBehavior.getParameterTypes()
  Line 147) methods.add(ref.getCorrespondingDeclaration()) ==> java.util.List.add(E)
  Line 147) ref.getCorrespondingDeclaration() ==> com.github.javaparser.symbolsolver.model.resolution.SymbolReference.getCorrespondingDeclaration()
  Line 150) getInterfaces() ==> com.github.javaparser.symbolsolver.reflectionmodel.ReflectionClassDeclaration.getInterfaces()
  Line 200) actualParam.isAssignableBy(matchedParameter) ==> com.github.javaparser.symbolsolver.model.typesystem.Type.isAssignableBy(com.github.javaparser.symbolsolver.model.typesystem.Type)
  Line 173) type.asReferenceType() ==> com.github.javaparser.symbolsolver.model.typesystem.Type.asReferenceType()
  Line 289) collector.add(clazz.cast(node)) ==> java.util.List.add(E)
  Line 201) matchedParameters.put(expectedParamName, actualParam) ==> java.util.Map.put(K, V)
  Line 289) clazz.cast(node) ==> java.lang.Class.cast(java.lang.Object)
  Line 173) placeInferenceVariables(tp) ==> com.github.javaparser.symbolsolver.logic.InferenceContext.placeInferenceVariables(com.github.javaparser.symbolsolver.model.typesystem.Type)
  Line 206) matchedParameters.put(expectedParamName, actualParam) ==> java.util.Map.put(K, V)
  Line 174) type.isArray() ==> com.github.javaparser.symbolsolver.model.typesystem.Type.isArray()
  Line 209) expectedParam.isReferenceType() ==> com.github.javaparser.symbolsolver.model.typesystem.Type.isReferenceType()
  Line 175) placeInferenceVariables(type.asArrayType().getComponentType()) ==> com.github.javaparser.symbolsolver.logic.InferenceContext.placeInferenceVariables(com.github.javaparser.symbolsolver.model.typesystem.Type)
  Line 91) ctConstructor.getGenericSignature() ==> javassist.CtBehavior.getGenericSignature()
  Line 175) type.asArrayType().getComponentType() ==> com.github.javaparser.symbolsolver.model.typesystem.ArrayType.getComponentType()
  Line 175) type.asArrayType() ==> com.github.javaparser.symbolsolver.model.typesystem.Type.asArrayType()
  Line 210) expectedParam.equals(actualParam) ==> java.lang.Object.equals(java.lang.Object)
  Line 176) type.isNull() ==> com.github.javaparser.symbolsolver.model.typesystem.Type.isNull()
  Line 213) expectedParam.isWildcard() ==> com.github.javaparser.symbolsolver.model.typesystem.Type.isWildcard()
  Line 291) node.getChildNodes() ==> com.github.javaparser.ast.Node.getChildNodes()
  Line 176) type.isPrimitive() ==> com.github.javaparser.symbolsolver.model.typesystem.Type.isPrimitive()
  Line 214) expectedParam.asWildcard().isExtends() ==> com.github.javaparser.symbolsolver.model.typesystem.Wildcard.isExtends()
  Line 151) MethodResolutionLogic.solveMethodInType(interfaceDeclaration.getTypeDeclaration(), name, argumentsTypes, staticOnly, typeSolver) ==> com.github.javaparser.symbolsolver.resolution.MethodResolutionLogic.solveMethodInType(com.github.javaparser.symbolsolver.model.declarations.TypeDeclaration, java.lang.String, java.util.List<com.github.javaparser.symbolsolver.model.typesystem.Type>, boolean, com.github.javaparser.symbolsolver.model.resolution.TypeSolver)
  Line 214) expectedParam.asWildcard() ==> com.github.javaparser.symbolsolver.model.typesystem.Type.asWildcard()
  Line 176) type.isVoid() ==> com.github.javaparser.symbolsolver.model.typesystem.Type.isVoid()
  Line 263) node.getClass() ==> java.lang.Object.getClass()
  Line 178) type.isConstraint() ==> com.github.javaparser.symbolsolver.model.typesystem.Type.isConstraint()
  Line 146) astTypeDeclaration.isPresent() ==> java.util.Optional.isPresent()
  Line 92) SignatureAttribute.toMethodSignature(ctConstructor.getGenericSignature()) ==> javassist.bytecode.SignatureAttribute.toMethodSignature(java.lang.String)
  Line 92) ctConstructor.getGenericSignature() ==> javassist.CtBehavior.getGenericSignature()
  Line 151) interfaceDeclaration.getTypeDeclaration() ==> com.github.javaparser.symbolsolver.model.typesystem.ReferenceType.getTypeDeclaration()
  Line 179) LambdaConstraintType.bound(placeInferenceVariables(type.asConstraintType().getBound())) ==> com.github.javaparser.symbolsolver.model.typesystem.LambdaConstraintType.bound(com.github.javaparser.symbolsolver.model.typesystem.Type)
  Line 179) placeInferenceVariables(type.asConstraintType().getBound()) ==> com.github.javaparser.symbolsolver.logic.InferenceContext.placeInferenceVariables(com.github.javaparser.symbolsolver.model.typesystem.Type)
  Line 179) type.asConstraintType().getBound() ==> com.github.javaparser.symbolsolver.model.typesystem.LambdaConstraintType.getBound()
  Line 179) type.asConstraintType() ==> com.github.javaparser.symbolsolver.model.typesystem.Type.asConstraintType()
  Line 152) ref.isSolved() ==> com.github.javaparser.symbolsolver.model.resolution.SymbolReference.isSolved()
  Line 183) type.describe() ==> com.github.javaparser.symbolsolver.model.typesystem.Type.describe()
  Line 93) methodSignature.getParameterTypes() ==> javassist.bytecode.SignatureAttribute.MethodSignature.getParameterTypes()
  Line 153) methods.add(ref.getCorrespondingDeclaration()) ==> java.util.List.add(E)
  Line 153) ref.getCorrespondingDeclaration() ==> com.github.javaparser.symbolsolver.model.resolution.SymbolReference.getCorrespondingDeclaration()
  Line 190) inferenceVariableType.equivalentType() ==> com.github.javaparser.symbolsolver.logic.InferenceVariableType.equivalentType()
  Line 191) type.isReferenceType() ==> com.github.javaparser.symbolsolver.model.typesystem.Type.isReferenceType()
  Line 192) type.asReferenceType().transformTypeParameters(tp -> resolve(tp)) ==> com.github.javaparser.symbolsolver.model.typesystem.ReferenceType.transformTypeParameters(com.github.javaparser.symbolsolver.model.typesystem.TypeTransformer)
  Line 192) type.asReferenceType() ==> com.github.javaparser.symbolsolver.model.typesystem.Type.asReferenceType()
  Line 192) resolve(tp) ==> com.github.javaparser.symbolsolver.logic.InferenceContext.resolve(com.github.javaparser.symbolsolver.model.typesystem.Type)
  Line 94) JavassistUtils.signatureTypeToType(signatureType, typeSolver, this) ==> com.github.javaparser.symbolsolver.javassistmodel.JavassistUtils.signatureTypeToType(javassist.bytecode.SignatureAttribute.Type, com.github.javaparser.symbolsolver.model.resolution.TypeSolver, com.github.javaparser.symbolsolver.model.declarations.TypeParametrizable)
  Line 193) type.isNull() ==> com.github.javaparser.symbolsolver.model.typesystem.Type.isNull()
  Line 193) type.isPrimitive() ==> com.github.javaparser.symbolsolver.model.typesystem.Type.isPrimitive()
  Line 193) type.isVoid() ==> com.github.javaparser.symbolsolver.model.typesystem.Type.isVoid()
  Line 215) isAssignableMatchTypeParameters(expectedParam.asWildcard().getBoundedType(), actual, matchedParameters) ==> com.github.javaparser.symbolsolver.resolution.MethodResolutionLogic.isAssignableMatchTypeParameters(com.github.javaparser.symbolsolver.model.typesystem.Type, com.github.javaparser.symbolsolver.model.typesystem.Type, java.util.Map<java.lang.String, com.github.javaparser.symbolsolver.model.typesystem.Type>)
  Line 195) type.isArray() ==> com.github.javaparser.symbolsolver.model.typesystem.Type.isArray()
  Line 215) expectedParam.asWildcard().getBoundedType() ==> com.github.javaparser.symbolsolver.model.typesystem.Wildcard.getBoundedType()
  Line 215) expectedParam.asWildcard() ==> com.github.javaparser.symbolsolver.model.typesystem.Type.asWildcard()
  Line 196) resolve(type.asArrayType().getComponentType()) ==> com.github.javaparser.symbolsolver.logic.InferenceContext.resolve(com.github.javaparser.symbolsolver.model.typesystem.Type)
  Line 196) type.asArrayType().getComponentType() ==> com.github.javaparser.symbolsolver.model.typesystem.ArrayType.getComponentType()
  Line 220) expectedParam.describe() ==> com.github.javaparser.symbolsolver.model.typesystem.Type.describe()
  Line 196) type.asArrayType() ==> com.github.javaparser.symbolsolver.model.typesystem.Type.asArrayType()
  Line 96) ctConstructor.getParameterTypes() ==> javassist.CtBehavior.getParameterTypes()
  Line 197) type.isWildcard() ==> com.github.javaparser.symbolsolver.model.typesystem.Type.isWildcard()
  Line 198) type.asWildcard().isExtends() ==> com.github.javaparser.symbolsolver.model.typesystem.Wildcard.isExtends()
  Line 227) type.isTypeVariable() ==> com.github.javaparser.symbolsolver.model.typesystem.Type.isTypeVariable()
  Line 108) ctConstructor.getGenericSignature() ==> javassist.CtBehavior.getGenericSignature()
  Line 109) Collections.emptyList() ==> java.util.Collections.emptyList()
  Line 198) type.asWildcard() ==> com.github.javaparser.symbolsolver.model.typesystem.Type.asWildcard()
  Line 111) SignatureAttribute.toMethodSignature(ctConstructor.getGenericSignature()) ==> javassist.bytecode.SignatureAttribute.toMethodSignature(java.lang.String)
  Line 111) ctConstructor.getGenericSignature() ==> javassist.CtBehavior.getGenericSignature()
  Line 156) MethodResolutionLogic.findMostApplicable(methods, name, argumentsTypes, typeSolver) ==> com.github.javaparser.symbolsolver.resolution.MethodResolutionLogic.findMostApplicable(java.util.List<com.github.javaparser.symbolsolver.model.declarations.MethodDeclaration>, java.lang.String, java.util.List<com.github.javaparser.symbolsolver.model.typesystem.Type>, com.github.javaparser.symbolsolver.model.resolution.TypeSolver)
  Line 162) getId() ==> com.github.javaparser.symbolsolver.model.declarations.TypeDeclaration.getId()
  Line 228) type.describe().equals(tp.getName()) ==> java.lang.String.equals(java.lang.Object)
  Line 228) type.describe() ==> com.github.javaparser.symbolsolver.model.typesystem.Type.describe()
  Line 199) Wildcard.extendsBound(resolve(type.asWildcard().getBoundedType())) ==> com.github.javaparser.symbolsolver.model.typesystem.Wildcard.extendsBound(com.github.javaparser.symbolsolver.model.typesystem.Type)
  Line 199) resolve(type.asWildcard().getBoundedType()) ==> com.github.javaparser.symbolsolver.logic.InferenceContext.resolve(com.github.javaparser.symbolsolver.model.typesystem.Type)
  Line 228) tp.getName() ==> com.github.javaparser.symbolsolver.model.declarations.TypeParameterDeclaration.getName()
  Line 199) type.asWildcard().getBoundedType() ==> com.github.javaparser.symbolsolver.model.typesystem.Wildcard.getBoundedType()
  Line 268) node.getClass().getCanonicalName() ==> java.lang.Class.getCanonicalName()
  Line 292) findAllNodesOfGivenClassHelper(child, clazz, collector) ==> com.github.javaparser.symbolsolver.javaparser.Navigator.findAllNodesOfGivenClassHelper(com.github.javaparser.ast.Node, java.lang.Class<N>, java.util.List<N>)
  Line 199) type.asWildcard() ==> com.github.javaparser.symbolsolver.model.typesystem.Type.asWildcard()
  Line 229) tp.getBounds(typeSolver) ==> com.github.javaparser.symbolsolver.model.declarations.TypeParameterDeclaration.getBounds(com.github.javaparser.symbolsolver.model.resolution.TypeSolver)
  Line 86) JavaParserFacade.get(typeSolver) ==> com.github.javaparser.symbolsolver.javaparsermodel.JavaParserFacade.get(com.github.javaparser.symbolsolver.model.resolution.TypeSolver)
  Line 268) node.getClass() ==> java.lang.Object.getClass()
  Line 235) ancestors.stream().map(a -> typeParametersMap().replaceAll(a).asReferenceType()) ==> java.util.stream.Stream.map(java.util.function.Function<? super T, ? extends R>)
  Line 200) type.asWildcard().isSuper() ==> com.github.javaparser.symbolsolver.model.typesystem.Wildcard.isSuper()
  Line 200) type.asWildcard() ==> com.github.javaparser.symbolsolver.model.typesystem.Type.asWildcard()
  Line 87) name.startsWith(String.format("%s.", localType.getName())) ==> java.lang.String.startsWith(java.lang.String)
  Line 87) String.format("%s.", localType.getName()) ==> java.lang.String.format(java.lang.String, java.lang.Object...)
  Line 87) localType.getName() ==> com.github.javaparser.ast.body.TypeDeclaration.getName()
  Line 273) node.getClass().getCanonicalName() ==> java.lang.Class.getCanonicalName()
  Line 273) node.getClass() ==> java.lang.Object.getClass()
  Line 230) bounds.size() ==> java.util.List.size()
  Line 232) bounds.size() ==> java.util.List.size()
  Line 235) ancestors.stream() ==> java.util.Collection.stream()
  Line 201) Wildcard.superBound(resolve(type.asWildcard().getBoundedType())) ==> com.github.javaparser.symbolsolver.model.typesystem.Wildcard.superBound(com.github.javaparser.symbolsolver.model.typesystem.Type)
  Line 201) resolve(type.asWildcard().getBoundedType()) ==> com.github.javaparser.symbolsolver.logic.InferenceContext.resolve(com.github.javaparser.symbolsolver.model.typesystem.Type)
  Line 201) type.asWildcard().getBoundedType() ==> com.github.javaparser.symbolsolver.model.typesystem.Wildcard.getBoundedType()
  Line 201) type.asWildcard() ==> com.github.javaparser.symbolsolver.model.typesystem.Type.asWildcard()
  Line 233) bounds.get(0).getType() ==> com.github.javaparser.symbolsolver.model.declarations.TypeParameterDeclaration.Bound.getType()
  Line 206) type.describe() ==> com.github.javaparser.symbolsolver.model.typesystem.Type.describe()
  Line 233) bounds.get(0) ==> java.util.List.get(int)
  Line 278) node.getClass().getCanonicalName() ==> java.lang.Class.getCanonicalName()
  Line 235) typeSolver.solveType(Object.class.getCanonicalName()) ==> com.github.javaparser.symbolsolver.model.resolution.TypeSolver.solveType(java.lang.String)
  Line 112) Arrays.stream(methodSignature.getTypeParameters()).map((jasTp) -> new JavassistTypeParameter(jasTp, this, typeSolver)).collect(Collectors.toList()) ==> java.util.stream.Stream.collect(java.util.stream.Collector<? super T, A, R>)
  Line 236) typeParametersMap().replaceAll(a).asReferenceType() ==> com.github.javaparser.symbolsolver.model.typesystem.Type.asReferenceType()
