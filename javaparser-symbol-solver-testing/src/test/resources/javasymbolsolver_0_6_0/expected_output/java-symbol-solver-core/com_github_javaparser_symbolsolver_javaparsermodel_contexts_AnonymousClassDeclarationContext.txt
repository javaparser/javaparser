  Line 253) bounds.get(0) ==> java.util.List.get(int)
  Line 126) equivalentTypes.stream().filter(t -> !t.isTypeVariable() && !hasInferenceVariables(t)) ==> java.util.stream.Stream.filter(java.util.function.Predicate<? super T>)
  Line 126) equivalentTypes.stream() ==> java.util.Collection.stream()
  Line 178) getTypeParameters().get(i) ==> java.util.List.get(int)
  Line 178) getTypeParameters() ==> com.github.javaparser.symbolsolver.reflectionmodel.ReflectionClassDeclaration.getTypeParameters()
  Line 179) typeParameterValues.get(i) ==> java.util.List.get(int)
  Line 308) node.getClass().getCanonicalName() ==> java.lang.Class.getCanonicalName()
  Line 127) t.isTypeVariable() ==> com.github.javaparser.symbolsolver.model.typesystem.Type.isTypeVariable()
  Line 127) hasInferenceVariables(t) ==> com.github.javaparser.symbolsolver.logic.InferenceVariableType.hasInferenceVariables(com.github.javaparser.symbolsolver.model.typesystem.Type)
  Line 255) typeSolver.solveType(Object.class.getCanonicalName()) ==> com.github.javaparser.symbolsolver.model.resolution.TypeSolver.solveType(java.lang.String)
  Line 255) Object.class.getCanonicalName() ==> java.lang.Class.getCanonicalName()
  Line 97) ancestors.add(superClassTypeUsage.asReferenceType()) ==> java.util.List.add(E)
  Line 97) superClassTypeUsage.asReferenceType() ==> com.github.javaparser.symbolsolver.model.typesystem.Type.asReferenceType()
  Line 260) type.getClass().getCanonicalName() ==> java.lang.Class.getCanonicalName()
  Line 260) type.getClass() ==> java.lang.Object.getClass()
  Line 265) method.getName().equals(name) ==> java.lang.String.equals(java.lang.Object)
  Line 265) method.getName() ==> com.github.javaparser.symbolsolver.model.methods.MethodUsage.getName()
  Line 101) ctClass.getInterfaces() ==> javassist.CtClass.getInterfaces()
  Line 250) Collectors.toList() ==> java.util.stream.Collectors.toList()
  Line 180) methodUsage.replaceTypeParameter(tpToReplace, newValue) ==> com.github.javaparser.symbolsolver.model.methods.MethodUsage.replaceTypeParameter(com.github.javaparser.symbolsolver.model.declarations.TypeParameterDeclaration, com.github.javaparser.symbolsolver.model.typesystem.Type)
  Line 269) method.getNoParams() ==> com.github.javaparser.symbolsolver.model.methods.MethodUsage.getNoParams()
  Line 308) node.getClass() ==> java.lang.Object.getClass()
  Line 128) Collectors.toSet() ==> java.util.stream.Collectors.toSet()
  Line 129) notTypeVariables.size() ==> java.util.Set.size()
  Line 182) methods.add(methodUsage) ==> java.util.List.add(E)
  Line 130) notTypeVariables.iterator().next() ==> java.util.Iterator.next()
  Line 184) getSuperClass() ==> com.github.javaparser.symbolsolver.reflectionmodel.ReflectionClassDeclaration.getSuperClass()
  Line 130) notTypeVariables.iterator() ==> java.util.Set.iterator()
  Line 131) notTypeVariables.size() ==> java.util.Set.size()
  Line 269) argumentsTypes.size() ==> java.util.List.size()
  Line 131) superTypes.isEmpty() ==> java.util.Set.isEmpty()
  Line 272) method.getNoParams() ==> com.github.javaparser.symbolsolver.model.methods.MethodUsage.getNoParams()
  Line 132) superTypes.size() ==> java.util.Set.size()
  Line 185) getSuperClass().getTypeDeclaration() ==> com.github.javaparser.symbolsolver.model.typesystem.ReferenceType.getTypeDeclaration()
  Line 185) getSuperClass() ==> com.github.javaparser.symbolsolver.reflectionmodel.ReflectionClassDeclaration.getSuperClass()
  Line 102) JavassistFactory.typeUsageFor(interfaze, typeSolver) ==> com.github.javaparser.symbolsolver.javassistmodel.JavassistFactory.typeUsageFor(javassist.CtClass, com.github.javaparser.symbolsolver.model.resolution.TypeSolver)
  Line 58) memberClass.isAssignableFrom(node.getClass()) ==> ERROR
  Line 133) superTypes.iterator().next() ==> java.util.Iterator.next()
  Line 133) superTypes.iterator() ==> java.util.Set.iterator()
  Line 147) type.isReferenceType() ==> com.github.javaparser.symbolsolver.model.typesystem.Type.isReferenceType()
  Line 148) type.asReferenceType() ==> com.github.javaparser.symbolsolver.model.typesystem.Type.asReferenceType()
  Line 149) refType.typeParametersValues() ==> com.github.javaparser.symbolsolver.model.typesystem.ReferenceType.typeParametersValues()
  Line 58) node.getClass() ==> ERROR
  Line 60) Collectors.toList() ==> java.util.stream.Collectors.toList()
  Line 150) hasInferenceVariables(t) ==> com.github.javaparser.symbolsolver.logic.InferenceVariableType.hasInferenceVariables(com.github.javaparser.symbolsolver.model.typesystem.Type)
  Line 157) type.isWildcard() ==> com.github.javaparser.symbolsolver.model.typesystem.Type.isWildcard()
  Line 158) type.asWildcard() ==> com.github.javaparser.symbolsolver.model.typesystem.Type.asWildcard()
  Line 313) node.getClass().getCanonicalName() ==> java.lang.Class.getCanonicalName()
  Line 65) typeSolver.solveType(Object.class.getCanonicalName()) ==> com.github.javaparser.symbolsolver.model.resolution.TypeSolver.solveType(java.lang.String)
  Line 65) Object.class.getCanonicalName() ==> java.lang.Class.getCanonicalName()
  Line 273) method.getParamType(i) ==> com.github.javaparser.symbolsolver.model.methods.MethodUsage.getParamType(int)
  Line 275) method.getParamType(i) ==> com.github.javaparser.symbolsolver.model.methods.MethodUsage.getParamType(int)
  Line 70) superTypeDeclaration.asReferenceType() ==> com.github.javaparser.symbolsolver.model.declarations.TypeDeclaration.asReferenceType()
  Line 276) argumentsTypes.get(i) ==> java.util.List.get(int)
  Line 278) method.getDeclaration().getTypeParameters() ==> com.github.javaparser.symbolsolver.model.declarations.TypeParametrizable.getTypeParameters()
  Line 76) superTypeDeclaration.asReferenceType().getAncestors().stream().filter(type -> type.getTypeDeclaration().isInterface()).collect(Collectors.toList()) ==> ERROR
  Line 278) method.getDeclaration() ==> com.github.javaparser.symbolsolver.model.methods.MethodUsage.getDeclaration()
  Line 76) superTypeDeclaration.asReferenceType().getAncestors().stream().filter(type -> type.getTypeDeclaration().isInterface()) ==> java.util.stream.Stream.filter(java.util.function.Predicate<? super T>)
  Line 76) superTypeDeclaration.asReferenceType().getAncestors().stream() ==> java.util.Collection.stream()
  Line 76) superTypeDeclaration.asReferenceType().getAncestors() ==> com.github.javaparser.symbolsolver.model.declarations.ReferenceTypeDeclaration.getAncestors()
  Line 76) superTypeDeclaration.asReferenceType() ==> com.github.javaparser.symbolsolver.model.declarations.TypeDeclaration.asReferenceType()
  Line 186) ContextHelper.solveMethodAsUsage(superClass, name, argumentsTypes, typeSolver, invokationContext, typeParameterValues) ==> com.github.javaparser.symbolsolver.javaparsermodel.contexts.ContextHelper.solveMethodAsUsage(com.github.javaparser.symbolsolver.model.declarations.TypeDeclaration, java.lang.String, java.util.List<com.github.javaparser.symbolsolver.model.typesystem.Type>, com.github.javaparser.symbolsolver.model.resolution.TypeSolver, com.github.javaparser.symbolsolver.core.resolution.Context, java.util.List<com.github.javaparser.symbolsolver.model.typesystem.Type>)
  Line 187) ref.isPresent() ==> java.util.Optional.isPresent()
  Line 79) type.getTypeDeclaration().isInterface() ==> com.github.javaparser.symbolsolver.model.declarations.TypeDeclaration.isInterface()
  Line 79) type.getTypeDeclaration() ==> com.github.javaparser.symbolsolver.model.typesystem.ReferenceType.getTypeDeclaration()
  Line 188) methods.add(ref.get()) ==> java.util.List.add(E)
  Line 80) Collectors.toList() ==> java.util.stream.Collectors.toList()
  Line 188) ref.get() ==> java.util.Optional.get()
  Line 191) getInterfaces() ==> com.github.javaparser.symbolsolver.reflectionmodel.ReflectionClassDeclaration.getInterfaces()
  Line 313) node.getClass() ==> java.lang.Object.getClass()
  Line 159) hasInferenceVariables(wildcardType.getBoundedType()) ==> com.github.javaparser.symbolsolver.logic.InferenceVariableType.hasInferenceVariables(com.github.javaparser.symbolsolver.model.typesystem.Type)
  Line 159) wildcardType.getBoundedType() ==> com.github.javaparser.symbolsolver.model.typesystem.Wildcard.getBoundedType()
  Line 318) node.getClass().getCanonicalName() ==> java.lang.Class.getCanonicalName()
  Line 279) typeParameters.addAll(method.declaringType().getTypeParameters()) ==> java.util.List.addAll(java.util.Collection<? extends E>)
  Line 104) interfazeTypeUsage.isReferenceType() ==> com.github.javaparser.symbolsolver.model.typesystem.Type.isReferenceType()
  Line 37) Preconditions.checkArgument(node.getAnonymousClassBody().isPresent(), "An anonymous class must have a body") ==> com.google.common.base.Preconditions.checkArgument(boolean, java.lang.Object)
  Line 254) getAllAncestors().stream().filter(it -> it.getTypeDeclaration().isClass()).collect(Collectors.toList()) ==> java.util.stream.Stream.collect(java.util.stream.Collector<? super T, A, R>)
  Line 192) ContextHelper.solveMethodAsUsage(interfaceDeclaration.getTypeDeclaration(), name, argumentsTypes, typeSolver, invokationContext, typeParameterValues) ==> com.github.javaparser.symbolsolver.javaparsermodel.contexts.ContextHelper.solveMethodAsUsage(com.github.javaparser.symbolsolver.model.declarations.TypeDeclaration, java.lang.String, java.util.List<com.github.javaparser.symbolsolver.model.typesystem.Type>, com.github.javaparser.symbolsolver.model.resolution.TypeSolver, com.github.javaparser.symbolsolver.core.resolution.Context, java.util.List<com.github.javaparser.symbolsolver.model.typesystem.Type>)
  Line 86) findMembersOfKind(com.github.javaparser.ast.body.ConstructorDeclaration.class).stream().map(ctor -> new JavaParserConstructorDeclaration(this, ctor, typeSolver)).collect(Collectors.toList()) ==> java.util.stream.Stream.collect(java.util.stream.Collector<? super T, A, R>)
