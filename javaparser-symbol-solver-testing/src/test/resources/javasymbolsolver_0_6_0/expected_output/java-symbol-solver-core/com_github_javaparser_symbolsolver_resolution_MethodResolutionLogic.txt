  Line 91) srcDirectory.getAbsolutePath() ==> java.io.File.getAbsolutePath()
  Line 96) srcDir.exists() ==> java.io.File.exists()
  Line 96) srcDir.isDirectory() ==> java.io.File.isDirectory()
  Line 97) srcDir.getAbsolutePath() ==> java.io.File.getAbsolutePath()
  Line 40) ImmutableList.of(INT, BOOLEAN, LONG, CHAR, FLOAT, DOUBLE, SHORT, BYTE) ==> com.google.common.collect.ImmutableList.of(E, E, E, E, E, E, E, E)
  Line 57) name.toLowerCase() ==> java.lang.String.toLowerCase()
  Line 102) foundTypes.containsKey(name) ==> java.util.Map.containsKey(java.lang.Object)
  Line 135) it.isStatic() ==> com.github.javaparser.symbolsolver.model.declarations.FieldDeclaration.isStatic()
  Line 135) Collectors.toList() ==> java.util.stream.Collectors.toList()
  Line 103) SymbolReference.solved(foundTypes.get(name)) ==> com.github.javaparser.symbolsolver.model.resolution.SymbolReference.solved(S2)
  Line 93) ancestor.getTypeDeclaration() ==> com.github.javaparser.symbolsolver.model.typesystem.ReferenceType.getTypeDeclaration()
  Line 103) foundTypes.get(name) ==> java.util.Map.get(java.lang.Object)
  Line 105) tryToSolveTypeUncached(name) ==> com.github.javaparser.symbolsolver.resolution.typesolvers.JavaParserTypeSolver.tryToSolveTypeUncached(java.lang.String)
  Line 59) ptu.describe().equals(name) ==> java.lang.String.equals(java.lang.Object)
  Line 59) ptu.describe() ==> com.github.javaparser.symbolsolver.model.typesystem.PrimitiveType.describe()
  Line 104) other.isPrimitive() ==> com.github.javaparser.symbolsolver.model.typesystem.Type.isPrimitive()
  Line 106) result.isSolved() ==> com.github.javaparser.symbolsolver.model.resolution.SymbolReference.isSolved()
  Line 105) promotionTypes.contains(other) ==> java.util.List.contains(java.lang.Object)
  Line 106) other.isReferenceType() ==> com.github.javaparser.symbolsolver.model.typesystem.Type.isReferenceType()
  Line 107) foundTypes.put(name, result.getCorrespondingDeclaration()) ==> java.util.Map.put(K, V)
  Line 94) ancestor.getTypeDeclaration().getField(name) ==> com.github.javaparser.symbolsolver.model.declarations.ReferenceTypeDeclaration.getField(java.lang.String)
  Line 107) result.getCorrespondingDeclaration() ==> com.github.javaparser.symbolsolver.model.resolution.SymbolReference.getCorrespondingDeclaration()
  Line 94) ancestor.getTypeDeclaration() ==> com.github.javaparser.symbolsolver.model.typesystem.ReferenceType.getTypeDeclaration()
  Line 177) method.getMethodInfo().getAttribute(SyntheticAttribute.tag) ==> javassist.bytecode.MethodInfo.getAttribute(java.lang.String)
  Line 177) method.getMethodInfo() ==> javassist.CtBehavior.getMethodInfo()
  Line 178) method.getMethodInfo().getAccessFlags() ==> javassist.bytecode.MethodInfo.getAccessFlags()
  Line 178) method.getMethodInfo() ==> javassist.CtBehavior.getMethodInfo()
  Line 124) JavaParserFactory.getContext(notMethod, typeSolver) ==> com.github.javaparser.symbolsolver.javaparsermodel.JavaParserFactory.getContext(com.github.javaparser.ast.Node, com.github.javaparser.symbolsolver.model.resolution.TypeSolver)
  Line 179) method.getName().equals(name) ==> java.lang.String.equals(java.lang.Object)
  Line 83) node.getClass().getCanonicalName() ==> java.lang.Class.getCanonicalName()
  Line 179) method.getName() ==> javassist.CtMethod.getName()
  Line 107) other.asReferenceType().getQualifiedName().equals(boxTypeQName) ==> java.lang.String.equals(java.lang.Object)
  Line 114) name.split("\\.") ==> java.lang.String.split(java.lang.String)
  Line 83) node.getClass() ==> java.lang.Object.getClass()
  Line 107) other.asReferenceType().getQualifiedName() ==> com.github.javaparser.symbolsolver.model.typesystem.ReferenceType.getQualifiedName()
  Line 117) srcDir.getAbsolutePath() ==> java.io.File.getAbsolutePath()
  Line 133) parse(srcFile) ==> com.github.javaparser.symbolsolver.resolution.typesolvers.JavaParserTypeSolver.parse(java.io.File)
  Line 88) node.getClass().getCanonicalName() ==> java.lang.Class.getCanonicalName()
  Line 107) other.asReferenceType() ==> com.github.javaparser.symbolsolver.model.typesystem.Type.asReferenceType()
  Line 111) other.asReferenceType().getQualifiedName().equals(promotion.boxTypeQName) ==> java.lang.String.equals(java.lang.Object)
  Line 111) other.asReferenceType().getQualifiedName() ==> com.github.javaparser.symbolsolver.model.typesystem.ReferenceType.getQualifiedName()
  Line 111) other.asReferenceType() ==> com.github.javaparser.symbolsolver.model.typesystem.Type.asReferenceType()
  Line 116) other.isConstraint() ==> com.github.javaparser.symbolsolver.model.typesystem.Type.isConstraint()
  Line 117) this.isAssignableBy(other.asConstraintType().getBound()) ==> com.github.javaparser.symbolsolver.model.typesystem.PrimitiveType.isAssignableBy(com.github.javaparser.symbolsolver.model.typesystem.Type)
  Line 117) other.asConstraintType().getBound() ==> com.github.javaparser.symbolsolver.model.typesystem.LambdaConstraintType.getBound()
  Line 117) other.asConstraintType() ==> com.github.javaparser.symbolsolver.model.typesystem.Type.asConstraintType()
  Line 179) staticOnlyCheck.test(method) ==> java.util.function.Predicate.test(T)
  Line 142) getAllFields().stream().filter(it -> it.declaringType().getQualifiedName().equals(getQualifiedName())).collect(Collectors.toList()) ==> java.util.stream.Stream.collect(java.util.stream.Collector<? super T, A, R>)
  Line 95) reflectionFieldDeclaration.replaceType(ancestor.getFieldType(name).get()) ==> com.github.javaparser.symbolsolver.reflectionmodel.ReflectionFieldDeclaration.replaceType(com.github.javaparser.symbolsolver.model.typesystem.Type)
  Line 88) node.getClass() ==> java.lang.Object.getClass()
  Line 134) Navigator.findType(compilationUnit, typeName) ==> com.github.javaparser.symbolsolver.javaparser.Navigator.findType(com.github.javaparser.ast.CompilationUnit, java.lang.String)
  Line 132) symbolDeclarator.getSymbolDeclarations().stream().filter(d -> d.getName().equals(name)).map(d -> Value.from(d)).findFirst() ==> java.util.stream.Stream.findFirst()
