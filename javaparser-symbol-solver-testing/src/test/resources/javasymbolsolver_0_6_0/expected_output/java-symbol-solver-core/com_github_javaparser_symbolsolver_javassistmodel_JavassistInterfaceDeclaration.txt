  Line 375) res.isSolved() ==> com.github.javaparser.symbolsolver.model.resolution.SymbolReference.isSolved()
  Line 55) clazz.isPrimitive() ==> java.lang.Class.isPrimitive()
  Line 378) findMostApplicable(methods, name, argumentsTypes, typeSolver, true) ==> com.github.javaparser.symbolsolver.resolution.MethodResolutionLogic.findMostApplicable(java.util.List<com.github.javaparser.symbolsolver.model.declarations.MethodDeclaration>, java.lang.String, java.util.List<com.github.javaparser.symbolsolver.model.typesystem.Type>, com.github.javaparser.symbolsolver.model.resolution.TypeSolver, boolean)
  Line 128) ImmutableList.<FieldDeclaration>builder().addAll(myFields) ==> com.google.common.collect.ImmutableList.Builder.addAll(java.lang.Iterable<? extends E>)
  Line 128) ImmutableList.<FieldDeclaration>builder() ==> com.google.common.collect.ImmutableList.builder()
  Line 58) clazz.isArray() ==> java.lang.Class.isArray()
  Line 61) clazz.isEnum() ==> java.lang.Class.isEnum()
  Line 75) ReflectionFactory.modifiersToAccessLevel(this.clazz.getModifiers()) ==> com.github.javaparser.symbolsolver.reflectionmodel.ReflectionFactory.modifiersToAccessLevel(int)
  Line 75) this.clazz.getModifiers() ==> java.lang.Class.getModifiers()
  Line 80) reflectionClassAdapter.containerType() ==> com.github.javaparser.symbolsolver.reflectionmodel.ReflectionClassAdapter.containerType()
  Line 85) clazz.getPackage() ==> java.lang.Class.getPackage()
  Line 86) clazz.getPackage().getName() ==> java.lang.Package.getName()
  Line 86) clazz.getPackage() ==> java.lang.Class.getPackage()
  Line 93) clazz.getCanonicalName() ==> java.lang.Class.getCanonicalName()
  Line 94) getPackageName() ==> com.github.javaparser.symbolsolver.reflectionmodel.ReflectionEnumDeclaration.getPackageName()
  Line 54) ctClass.getName() ==> javassist.CtClass.getName()
  Line 60) ctClass.isInterface() ==> javassist.CtClass.isInterface()
  Line 394) typeDeclaration.getTypeParameters().stream().map(tp -> typeParametersMap.getValue(tp)) ==> java.util.stream.Stream.map(java.util.function.Function<? super T, ? extends R>)
  Line 394) typeDeclaration.getTypeParameters().stream() ==> java.util.Collection.stream()
  Line 394) typeDeclaration.getTypeParameters() ==> com.github.javaparser.symbolsolver.model.declarations.TypeParametrizable.getTypeParameters()
  Line 61) ctClass.getName() ==> javassist.CtClass.getName()
  Line 139) findMembersOfKind(com.github.javaparser.ast.body.MethodDeclaration.class).stream().map(method -> new JavaParserMethodDeclaration(method, typeSolver)).collect(Collectors.toSet()) ==> java.util.stream.Stream.collect(java.util.stream.Collector<? super T, A, R>)
  Line 395) typeParametersMap.getValue(tp) ==> com.github.javaparser.symbolsolver.model.typesystem.parametrization.TypeParametersMap.getValue(com.github.javaparser.symbolsolver.model.declarations.TypeParameterDeclaration)
  Line 396) Collectors.toList() ==> java.util.stream.Collectors.toList()
  Line 139) findMembersOfKind(com.github.javaparser.ast.body.MethodDeclaration.class).stream().map(method -> new JavaParserMethodDeclaration(method, typeSolver)) ==> java.util.stream.Stream.map(java.util.function.Function<? super T, ? extends R>)
  Line 139) findMembersOfKind(com.github.javaparser.ast.body.MethodDeclaration.class).stream() ==> java.util.Collection.stream()
  Line 404) getQualifiedName().equals(Boolean.class.getCanonicalName()) ==> java.lang.String.equals(java.lang.Object)
  Line 404) getQualifiedName() ==> com.github.javaparser.symbolsolver.model.typesystem.ReferenceType.getQualifiedName()
  Line 404) Boolean.class.getCanonicalName() ==> java.lang.Class.getCanonicalName()
  Line 139) findMembersOfKind(com.github.javaparser.ast.body.MethodDeclaration.class) ==> com.github.javaparser.symbolsolver.javaparsermodel.declarations.JavaParserAnonymousClassDeclaration.findMembersOfKind(java.lang.Class<T>)
  Line 142) Collectors.toSet() ==> java.util.stream.Collectors.toSet()
  Line 95) canonicalName.substring(getPackageName().length() + 1, canonicalName.length()) ==> java.lang.String.substring(int, int)
  Line 95) getPackageName().length() ==> java.lang.String.length()
  Line 95) getPackageName() ==> com.github.javaparser.symbolsolver.reflectionmodel.ReflectionEnumDeclaration.getPackageName()
  Line 95) canonicalName.length() ==> java.lang.String.length()
  Line 406) getQualifiedName().equals(Character.class.getCanonicalName()) ==> java.lang.String.equals(java.lang.Object)
  Line 406) getQualifiedName() ==> com.github.javaparser.symbolsolver.model.typesystem.ReferenceType.getQualifiedName()
  Line 406) Character.class.getCanonicalName() ==> java.lang.Class.getCanonicalName()
  Line 408) getQualifiedName().equals(Byte.class.getCanonicalName()) ==> java.lang.String.equals(java.lang.Object)
  Line 162) Helper.getPackageName(wrappedNode) ==> com.github.javaparser.symbolsolver.javaparsermodel.declarations.Helper.getPackageName(com.github.javaparser.ast.Node)
  Line 408) getQualifiedName() ==> com.github.javaparser.symbolsolver.model.typesystem.ReferenceType.getQualifiedName()
  Line 102) clazz.getCanonicalName() ==> java.lang.Class.getCanonicalName()
  Line 107) reflectionClassAdapter.getAncestors() ==> com.github.javaparser.symbolsolver.reflectionmodel.ReflectionClassAdapter.getAncestors()
  Line 408) Byte.class.getCanonicalName() ==> java.lang.Class.getCanonicalName()
  Line 112) reflectionClassAdapter.getField(name) ==> com.github.javaparser.symbolsolver.reflectionmodel.ReflectionClassAdapter.getField(java.lang.String)
  Line 410) getQualifiedName().equals(Short.class.getCanonicalName()) ==> java.lang.String.equals(java.lang.Object)
  Line 410) getQualifiedName() ==> com.github.javaparser.symbolsolver.model.typesystem.ReferenceType.getQualifiedName()
  Line 410) Short.class.getCanonicalName() ==> java.lang.Class.getCanonicalName()
  Line 412) getQualifiedName().equals(Integer.class.getCanonicalName()) ==> java.lang.String.equals(java.lang.Object)
  Line 412) getQualifiedName() ==> com.github.javaparser.symbolsolver.model.typesystem.ReferenceType.getQualifiedName()
  Line 412) Integer.class.getCanonicalName() ==> java.lang.Class.getCanonicalName()
  Line 414) getQualifiedName().equals(Long.class.getCanonicalName()) ==> java.lang.String.equals(java.lang.Object)
  Line 414) getQualifiedName() ==> com.github.javaparser.symbolsolver.model.typesystem.ReferenceType.getQualifiedName()
  Line 414) Long.class.getCanonicalName() ==> java.lang.Class.getCanonicalName()
  Line 117) reflectionClassAdapter.hasField(name) ==> com.github.javaparser.symbolsolver.reflectionmodel.ReflectionClassAdapter.hasField(java.lang.String)
  Line 122) reflectionClassAdapter.getAllFields() ==> com.github.javaparser.symbolsolver.reflectionmodel.ReflectionClassAdapter.getAllFields()
  Line 127) reflectionClassAdapter.getDeclaredMethods() ==> com.github.javaparser.symbolsolver.reflectionmodel.ReflectionClassAdapter.getDeclaredMethods()
  Line 71) Arrays.stream(ctClass.getInterfaces()).map(i -> new JavassistInterfaceDeclaration(i, typeSolver)).map(i -> new ReferenceTypeImpl(i, typeSolver)).collect(Collectors.toList()) ==> java.util.stream.Stream.collect(java.util.stream.Collector<? super T, A, R>)
  Line 71) Arrays.stream(ctClass.getInterfaces()).map(i -> new JavassistInterfaceDeclaration(i, typeSolver)).map(i -> new ReferenceTypeImpl(i, typeSolver)) ==> java.util.stream.Stream.map(java.util.function.Function<? super T, ? extends R>)
  Line 71) Arrays.stream(ctClass.getInterfaces()).map(i -> new JavassistInterfaceDeclaration(i, typeSolver)) ==> java.util.stream.Stream.map(java.util.function.Function<? super T, ? extends R>)
  Line 71) Arrays.stream(ctClass.getInterfaces()) ==> java.util.Arrays.stream(T[])
  Line 416) getQualifiedName().equals(Float.class.getCanonicalName()) ==> java.lang.String.equals(java.lang.Object)
  Line 416) getQualifiedName() ==> com.github.javaparser.symbolsolver.model.typesystem.ReferenceType.getQualifiedName()
  Line 416) Float.class.getCanonicalName() ==> java.lang.Class.getCanonicalName()
  Line 418) getQualifiedName().equals(Double.class.getCanonicalName()) ==> java.lang.String.equals(java.lang.Object)
  Line 418) getQualifiedName() ==> com.github.javaparser.symbolsolver.model.typesystem.ReferenceType.getQualifiedName()
  Line 418) Double.class.getCanonicalName() ==> java.lang.Class.getCanonicalName()
  Line 382) getMethodsWithoutDuplicates(methods).stream().filter((m) -> isApplicable(m, name, argumentsTypes, typeSolver, wildcardTolerance)).collect(Collectors.toList()) ==> java.util.stream.Stream.collect(java.util.stream.Collector<? super T, A, R>)
  Line 167) Helper.getClassName("", wrappedNode) ==> com.github.javaparser.symbolsolver.javaparsermodel.declarations.Helper.getClassName(java.lang.String, com.github.javaparser.ast.Node)
  Line 382) getMethodsWithoutDuplicates(methods).stream().filter((m) -> isApplicable(m, name, argumentsTypes, typeSolver, wildcardTolerance)) ==> java.util.stream.Stream.filter(java.util.function.Predicate<? super T>)
  Line 382) getMethodsWithoutDuplicates(methods).stream() ==> java.util.Collection.stream()
  Line 382) getMethodsWithoutDuplicates(methods) ==> com.github.javaparser.symbolsolver.resolution.MethodResolutionLogic.getMethodsWithoutDuplicates(java.util.List<com.github.javaparser.symbolsolver.model.declarations.MethodDeclaration>)
  Line 132) reflectionClassAdapter.isAssignableBy(type) ==> com.github.javaparser.symbolsolver.reflectionmodel.ReflectionClassAdapter.isAssignableBy(com.github.javaparser.symbolsolver.model.typesystem.Type)
  Line 71) ctClass.getInterfaces() ==> javassist.CtClass.getInterfaces()
  Line 72) Collectors.toList() ==> java.util.stream.Collectors.toList()
  Line 425) other.equals(this) ==> com.github.javaparser.symbolsolver.model.typesystem.ReferenceType.equals(java.lang.Object)
  Line 80) ctClass.getPackageName() ==> javassist.CtClass.getPackageName()
  Line 85) ctClass.getName().replace('$', '.') ==> java.lang.String.replace(char, char)
  Line 85) ctClass.getName() ==> javassist.CtClass.getName()
  Line 86) getPackageName() ==> com.github.javaparser.symbolsolver.javassistmodel.JavassistInterfaceDeclaration.getPackageName()
  Line 428) this.getQualifiedName().equals(other.getQualifiedName()) ==> java.lang.String.equals(java.lang.Object)
  Line 428) this.getQualifiedName() ==> com.github.javaparser.symbolsolver.model.typesystem.ReferenceType.getQualifiedName()
  Line 428) other.getQualifiedName() ==> com.github.javaparser.symbolsolver.model.typesystem.ReferenceType.getQualifiedName()
  Line 429) this.isRawType() ==> com.github.javaparser.symbolsolver.model.typesystem.ReferenceType.isRawType()
  Line 429) other.isRawType() ==> com.github.javaparser.symbolsolver.model.typesystem.ReferenceType.isRawType()
  Line 137) isAssignableBy(new ReferenceTypeImpl(other, typeSolver)) ==> com.github.javaparser.symbolsolver.reflectionmodel.ReflectionEnumDeclaration.isAssignableBy(com.github.javaparser.symbolsolver.model.typesystem.Type)
  Line 432) this.typeParametersValues().size() ==> java.util.List.size()
  Line 432) this.typeParametersValues() ==> com.github.javaparser.symbolsolver.model.typesystem.ReferenceType.typeParametersValues()
  Line 432) other.typeParametersValues().size() ==> java.util.List.size()
  Line 142) reflectionClassAdapter.hasDirectlyAnnotation(qualifiedName) ==> com.github.javaparser.symbolsolver.reflectionmodel.ReflectionClassAdapter.hasDirectlyAnnotation(java.lang.String)
  Line 432) other.typeParametersValues() ==> com.github.javaparser.symbolsolver.model.typesystem.ReferenceType.typeParametersValues()
  Line 147) clazz.getSimpleName() ==> java.lang.Class.getSimpleName()
  Line 152) reflectionClassAdapter.getTypeParameters() ==> com.github.javaparser.symbolsolver.reflectionmodel.ReflectionClassAdapter.getTypeParameters()
  Line 113) JavaParserFacade.get(typeSolver).getTypeDeclaration(internalType) ==> com.github.javaparser.symbolsolver.javaparsermodel.JavaParserFacade.getTypeDeclaration(com.github.javaparser.ast.body.TypeDeclaration<?>)
  Line 113) JavaParserFacade.get(typeSolver) ==> com.github.javaparser.symbolsolver.javaparsermodel.JavaParserFacade.get(com.github.javaparser.symbolsolver.model.resolution.TypeSolver)
  Line 156) ReflectionMethodResolutionLogic.solveMethod(name, parameterTypes, staticOnly, typeSolver, this, clazz) ==> com.github.javaparser.symbolsolver.reflectionmodel.ReflectionMethodResolutionLogic.solveMethod(java.lang.String, java.util.List<com.github.javaparser.symbolsolver.model.typesystem.Type>, boolean, com.github.javaparser.symbolsolver.model.resolution.TypeSolver, com.github.javaparser.symbolsolver.model.declarations.ReferenceTypeDeclaration, java.lang.Class)
  Line 58) Logger.getLogger(JavaParserFacade.class.getCanonicalName()) ==> java.util.logging.Logger.getLogger(java.lang.String)
  Line 58) JavaParserFacade.class.getCanonicalName() ==> java.lang.Class.getCanonicalName()
  Line 435) typeParametersValues().size() ==> java.util.List.size()
  Line 435) typeParametersValues() ==> com.github.javaparser.symbolsolver.model.typesystem.ReferenceType.typeParametersValues()
  Line 115) exactMatch.isPresent() ==> java.util.Optional.isPresent()
  Line 87) className.substring(getPackageName().length() + 1, className.length()) ==> java.lang.String.substring(int, int)
  Line 87) getPackageName().length() ==> java.lang.String.length()
  Line 116) exactMatch.get() ==> java.util.Optional.get()
  Line 87) getPackageName() ==> com.github.javaparser.symbolsolver.javassistmodel.JavassistInterfaceDeclaration.getPackageName()
  Line 436) typeParametersValues().get(i) ==> java.util.List.get(int)
  Line 436) typeParametersValues() ==> com.github.javaparser.symbolsolver.model.typesystem.ReferenceType.typeParametersValues()
  Line 382) isApplicable(m, name, argumentsTypes, typeSolver, wildcardTolerance) ==> com.github.javaparser.symbolsolver.resolution.MethodResolutionLogic.isApplicable(com.github.javaparser.symbolsolver.model.declarations.MethodDeclaration, java.lang.String, java.util.List<com.github.javaparser.symbolsolver.model.typesystem.Type>, com.github.javaparser.symbolsolver.model.resolution.TypeSolver, boolean)
  Line 382) Collectors.toList() ==> java.util.stream.Collectors.toList()
  Line 61) logger.setLevel(Level.INFO) ==> java.util.logging.Logger.setLevel(java.util.logging.Level)
  Line 87) className.length() ==> java.lang.String.length()
  Line 437) other.typeParametersValues().get(i) ==> java.util.List.get(int)
  Line 437) other.typeParametersValues() ==> com.github.javaparser.symbolsolver.model.typesystem.ReferenceType.typeParametersValues()
  Line 94) ctClass.getName().replace('$', '.') ==> java.lang.String.replace(char, char)
  Line 94) ctClass.getName() ==> javassist.CtClass.getName()
  Line 383) applicableMethods.isEmpty() ==> java.util.List.isEmpty()
  Line 384) SymbolReference.unsolved(MethodDeclaration.class) ==> com.github.javaparser.symbolsolver.model.resolution.SymbolReference.unsolved(java.lang.Class<S2>)
  Line 387) applicableMethods.size() ==> java.util.List.size()
  Line 389) argumentsTypes.size() ==> java.util.List.size()
  Line 63) consoleHandler.setLevel(Level.INFO) ==> java.util.logging.Handler.setLevel(java.util.logging.Level)
  Line 64) logger.addHandler(consoleHandler) ==> java.util.logging.Logger.addHandler(java.util.logging.Handler)
  Line 390) argumentsTypes.get(i).isNull() ==> com.github.javaparser.symbolsolver.model.typesystem.Type.isNull()
  Line 75) typeSolver.getRoot() ==> com.github.javaparser.symbolsolver.model.resolution.TypeSolver.getRoot()
  Line 438) thisParam.equals(otherParam) ==> java.lang.Object.equals(java.lang.Object)
  Line 441) thisParamAsWildcard.isSuper() ==> com.github.javaparser.symbolsolver.model.typesystem.Wildcard.isSuper()
  Line 441) otherParam.isAssignableBy(thisParamAsWildcard.getBoundedType()) ==> com.github.javaparser.symbolsolver.model.typesystem.Type.isAssignableBy(com.github.javaparser.symbolsolver.model.typesystem.Type)
  Line 441) thisParamAsWildcard.getBoundedType() ==> com.github.javaparser.symbolsolver.model.typesystem.Wildcard.getBoundedType()
  Line 390) argumentsTypes.get(i) ==> java.util.List.get(int)
  Line 391) nullParamIndexes.add(i) ==> java.util.List.add(E)
  Line 161) ReflectionMethodResolutionLogic.solveMethodAsUsage(name, parameterTypes, typeSolver, invokationContext, typeParameterValues, this, clazz) ==> com.github.javaparser.symbolsolver.reflectionmodel.ReflectionMethodResolutionLogic.solveMethodAsUsage(java.lang.String, java.util.List<com.github.javaparser.symbolsolver.model.typesystem.Type>, com.github.javaparser.symbolsolver.model.resolution.TypeSolver, com.github.javaparser.symbolsolver.core.resolution.Context, java.util.List<com.github.javaparser.symbolsolver.model.typesystem.Type>, com.github.javaparser.symbolsolver.model.declarations.ReferenceTypeDeclaration, java.lang.Class)
  Line 394) nullParamIndexes.isEmpty() ==> java.util.List.isEmpty()
  Line 120) typeDeclarations.stream().filter(internalType -> name.startsWith(String.format("%s.", internalType.getName()))).findFirst().map(internalType -> JavaParserFactory.getContext(internalType, typeSolver).solveType(name.substring(internalType.getName().getId().length() + 1), typeSolver)) ==> java.util.Optional.map(java.util.function.Function<? super T, ? extends U>)
  Line 120) typeDeclarations.stream().filter(internalType -> name.startsWith(String.format("%s.", internalType.getName()))).findFirst() ==> java.util.stream.Stream.findFirst()
  Line 120) typeDeclarations.stream().filter(internalType -> name.startsWith(String.format("%s.", internalType.getName()))) ==> java.util.stream.Stream.filter(java.util.function.Predicate<? super T>)
  Line 163) res.isPresent() ==> java.util.Optional.isPresent()
  Line 120) typeDeclarations.stream() ==> java.util.Collection.stream()
  Line 101) JavassistUtils.getMethodUsage(ctClass, name, argumentsTypes, typeSolver, invokationContext) ==> com.github.javaparser.symbolsolver.javassistmodel.JavassistUtils.getMethodUsage(javassist.CtClass, java.lang.String, java.util.List<com.github.javaparser.symbolsolver.model.typesystem.Type>, com.github.javaparser.symbolsolver.model.resolution.TypeSolver, com.github.javaparser.symbolsolver.core.resolution.Context)
  Line 107) Modifier.isStatic(m.getModifiers()) ==> java.lang.reflect.Modifier.isStatic(int)
  Line 107) m.getModifiers() ==> javassist.CtBehavior.getModifiers()
  Line 122) name.startsWith(String.format("%s.", internalType.getName())) ==> java.lang.String.startsWith(java.lang.String)
  Line 108) ctClass.getDeclaredMethods() ==> javassist.CtClass.getDeclaredMethods()
  Line 122) String.format("%s.", internalType.getName()) ==> java.lang.String.format(java.lang.String, java.lang.Object...)
  Line 109) method.getMethodInfo().getAttribute(SyntheticAttribute.tag) ==> javassist.bytecode.MethodInfo.getAttribute(java.lang.String)
  Line 109) method.getMethodInfo() ==> javassist.CtBehavior.getMethodInfo()
  Line 443) thisParamAsWildcard.isExtends() ==> com.github.javaparser.symbolsolver.model.typesystem.Wildcard.isExtends()
  Line 110) method.getMethodInfo().getAccessFlags() ==> javassist.bytecode.MethodInfo.getAccessFlags()
  Line 443) thisParamAsWildcard.getBoundedType().isAssignableBy(otherParam) ==> com.github.javaparser.symbolsolver.model.typesystem.Type.isAssignableBy(com.github.javaparser.symbolsolver.model.typesystem.Type)
  Line 110) method.getMethodInfo() ==> javassist.CtBehavior.getMethodInfo()
  Line 443) thisParamAsWildcard.getBoundedType() ==> com.github.javaparser.symbolsolver.model.typesystem.Wildcard.getBoundedType()
  Line 122) internalType.getName() ==> com.github.javaparser.ast.body.TypeDeclaration.getName()
  Line 445) thisParamAsWildcard.isBounded() ==> com.github.javaparser.symbolsolver.model.typesystem.Wildcard.isBounded()
  Line 125) JavaParserFactory.getContext(internalType, typeSolver).solveType(name.substring(internalType.getName().getId().length() + 1), typeSolver) ==> ERROR
  Line 89) instances.computeIfAbsent(typeSolver, JavaParserFacade::new) ==> java.util.Map.computeIfAbsent(K, java.util.function.Function<? super K, ? extends V>)
  Line 96) instances.clear() ==> java.util.Map.clear()
  Line 149) JavaParserFacade.get(typeSolver) ==> com.github.javaparser.symbolsolver.javaparsermodel.JavaParserFacade.get(com.github.javaparser.symbolsolver.model.resolution.TypeSolver)
  Line 100) type.isTypeVariable() ==> com.github.javaparser.symbolsolver.model.typesystem.Type.isTypeVariable()
  Line 399) methDecl.getParam(nullParamIndex.intValue()).getType().isArray() ==> com.github.javaparser.symbolsolver.model.typesystem.Type.isArray()
  Line 399) methDecl.getParam(nullParamIndex.intValue()).getType() ==> com.github.javaparser.symbolsolver.model.declarations.ValueDeclaration.getType()
  Line 399) methDecl.getParam(nullParamIndex.intValue()) ==> com.github.javaparser.symbolsolver.model.declarations.MethodLikeDeclaration.getParam(int)
  Line 399) nullParamIndex.intValue() ==> java.lang.Integer.intValue()
  Line 111) method.getName().equals(name) ==> java.lang.String.equals(java.lang.Object)
  Line 111) method.getName() ==> javassist.CtMethod.getName()
  Line 111) staticOnlyCheck.test(method) ==> java.util.function.Predicate.test(T)
  Line 152) System.err.println("Error resolving call at L" + node.getBegin().get().line + ": " + node) ==> java.io.PrintStream.println(java.lang.String)
  Line 152) node.getBegin().get() ==> java.util.Optional.get()
  Line 101) context.solveGenericType(type.describe(), typeSolver) ==> com.github.javaparser.symbolsolver.core.resolution.Context.solveGenericType(java.lang.String, com.github.javaparser.symbolsolver.model.resolution.TypeSolver)
  Line 152) node.getBegin() ==> com.github.javaparser.ast.nodeTypes.NodeWithRange.getBegin()
  Line 101) type.describe() ==> com.github.javaparser.symbolsolver.model.typesystem.Type.describe()
  Line 153) e.printStackTrace() ==> java.lang.Throwable.printStackTrace()
  Line 166) res.get() ==> java.util.Optional.get()
  Line 170) methodUsage.getParamType(i) ==> com.github.javaparser.symbolsolver.model.methods.MethodUsage.getParamType(int)
  Line 160) methodDeclarationSymbolReference.isSolved() ==> com.github.javaparser.symbolsolver.model.resolution.SymbolReference.isSolved()
  Line 125) JavaParserFactory.getContext(internalType, typeSolver) ==> com.github.javaparser.symbolsolver.javaparsermodel.JavaParserFactory.getContext(com.github.javaparser.ast.Node, com.github.javaparser.symbolsolver.model.resolution.TypeSolver)
  Line 112) candidates.add(new JavassistMethodDeclaration(method, typeSolver)) ==> java.util.List.add(E)
  Line 161) methodDeclarationSymbolReference.getCorrespondingDeclaration().getQualifiedSignature() ==> com.github.javaparser.symbolsolver.model.declarations.MethodLikeDeclaration.getQualifiedSignature()
  Line 161) methodDeclarationSymbolReference.getCorrespondingDeclaration() ==> com.github.javaparser.symbolsolver.model.resolution.SymbolReference.getCorrespondingDeclaration()
  Line 117) ctClass.getSuperclass() ==> javassist.CtClass.getSuperclass()
  Line 400) removeCandidates.add(methDecl) ==> java.util.Set.add(E)
  Line 404) removeCandidates.isEmpty() ==> java.util.Set.isEmpty()
  Line 404) removeCandidates.size() ==> java.util.Set.size()
  Line 119) new JavassistClassDeclaration(superClass, typeSolver).solveMethod(name, argumentsTypes, staticOnly) ==> com.github.javaparser.symbolsolver.javassistmodel.JavassistClassDeclaration.solveMethod(java.lang.String, java.util.List<com.github.javaparser.symbolsolver.model.typesystem.Type>, boolean)
  Line 102) solved.isPresent() ==> java.util.Optional.isPresent()
  Line 103) solved.get() ==> java.util.Optional.get()
  Line 107) type.isWildcard() ==> com.github.javaparser.symbolsolver.model.typesystem.Type.isWildcard()
  Line 127) name.substring(internalType.getName().getId().length() + 1) ==> java.lang.String.substring(int)
  Line 108) type.asWildcard().isExtends() ==> com.github.javaparser.symbolsolver.model.typesystem.Wildcard.isExtends()
  Line 127) internalType.getName().getId().length() ==> java.lang.String.length()
  Line 108) type.asWildcard() ==> com.github.javaparser.symbolsolver.model.typesystem.Type.asWildcard()
  Line 127) internalType.getName().getId() ==> com.github.javaparser.ast.nodeTypes.NodeWithIdentifier.getId()
  Line 108) type.asWildcard().isSuper() ==> com.github.javaparser.symbolsolver.model.typesystem.Wildcard.isSuper()
  Line 452) thisParam.asTypeVariable().asTypeParameter().getBounds(this.typeSolver).stream().map(bound -> bound.getType()).collect(Collectors.toList()) ==> java.util.stream.Stream.collect(java.util.stream.Collector<? super T, A, R>)
  Line 452) thisParam.asTypeVariable().asTypeParameter().getBounds(this.typeSolver).stream().map(bound -> bound.getType()) ==> java.util.stream.Stream.map(java.util.function.Function<? super T, ? extends R>)
  Line 108) type.asWildcard() ==> com.github.javaparser.symbolsolver.model.typesystem.Type.asWildcard()
  Line 452) thisParam.asTypeVariable().asTypeParameter().getBounds(this.typeSolver).stream() ==> java.util.Collection.stream()
  Line 452) thisParam.asTypeVariable().asTypeParameter().getBounds(this.typeSolver) ==> com.github.javaparser.symbolsolver.model.declarations.TypeParameterDeclaration.getBounds(com.github.javaparser.symbolsolver.model.resolution.TypeSolver)
  Line 452) thisParam.asTypeVariable().asTypeParameter() ==> com.github.javaparser.symbolsolver.model.typesystem.TypeVariable.asTypeParameter()
  Line 109) type.asWildcard() ==> com.github.javaparser.symbolsolver.model.typesystem.Type.asWildcard()
  Line 172) Helper.containerName(getParentNode(wrappedNode)) ==> com.github.javaparser.symbolsolver.javaparsermodel.declarations.Helper.containerName(com.github.javaparser.ast.Node)
  Line 404) applicableMethods.size() ==> java.util.List.size()
  Line 169) collectAllNodes(node, nodes) ==> com.github.javaparser.symbolsolver.SourceFileInfoExtractor.collectAllNodes(com.github.javaparser.ast.Node, java.util.List<com.github.javaparser.ast.Node>)
  Line 405) applicableMethods.removeAll(removeCandidates) ==> java.util.List.removeAll(java.util.Collection<? extends java.lang.Object>)
  Line 127) internalType.getName() ==> com.github.javaparser.ast.body.TypeDeclaration.getName()
  Line 409) applicableMethods.size() ==> java.util.List.size()
  Line 170) nodes.sort((n1, n2) -> n1.getBegin().get().compareTo(n2.getBegin().get())) ==> java.util.List.sort(java.util.Comparator<? super E>)
  Line 120) ref.isSolved() ==> com.github.javaparser.symbolsolver.model.resolution.SymbolReference.isSolved()
  Line 173) parameters.add(inferenceContext.addPair(formalType, actualType)) ==> java.util.List.add(E)
  Line 130) recursiveMatch.isPresent() ==> java.util.Optional.isPresent()
  Line 170) n1.getBegin().get().compareTo(n2.getBegin().get()) ==> ERROR
  Line 121) candidates.add(ref.getCorrespondingDeclaration()) ==> java.util.List.add(E)
  Line 173) inferenceContext.addPair(formalType, actualType) ==> com.github.javaparser.symbolsolver.logic.InferenceContext.addPair(com.github.javaparser.symbolsolver.model.typesystem.Type, com.github.javaparser.symbolsolver.model.typesystem.Type)
  Line 410) SymbolReference.solved(applicableMethods.get(0)) ==> com.github.javaparser.symbolsolver.model.resolution.SymbolReference.solved(S2)
  Line 110) solveGenericTypes(wildcardUsage.getBoundedType(), context, typeSolver) ==> com.github.javaparser.symbolsolver.javaparsermodel.JavaParserFacade.solveGenericTypes(com.github.javaparser.symbolsolver.model.typesystem.Type, com.github.javaparser.symbolsolver.core.resolution.Context, com.github.javaparser.symbolsolver.model.resolution.TypeSolver)
  Line 410) applicableMethods.get(0) ==> java.util.List.get(int)
  Line 110) wildcardUsage.getBoundedType() ==> com.github.javaparser.symbolsolver.model.typesystem.Wildcard.getBoundedType()
  Line 131) recursiveMatch.get() ==> java.util.Optional.get()
  Line 111) wildcardUsage.isExtends() ==> com.github.javaparser.symbolsolver.model.typesystem.Wildcard.isExtends()
  Line 412) applicableMethods.get(0) ==> java.util.List.get(int)
  Line 112) Wildcard.extendsBound(boundResolved) ==> com.github.javaparser.symbolsolver.model.typesystem.Wildcard.extendsBound(com.github.javaparser.symbolsolver.model.typesystem.Type)
  Line 415) applicableMethods.size() ==> java.util.List.size()
  Line 114) Wildcard.superBound(boundResolved) ==> com.github.javaparser.symbolsolver.model.typesystem.Wildcard.superBound(com.github.javaparser.symbolsolver.model.typesystem.Type)
  Line 452) thisParam.asTypeVariable() ==> com.github.javaparser.symbolsolver.model.typesystem.Type.asTypeVariable()
  Line 452) bound.getType() ==> com.github.javaparser.symbolsolver.model.declarations.TypeParameterDeclaration.Bound.getType()
  Line 452) Collectors.toList() ==> java.util.stream.Collectors.toList()
  Line 121) ref.getCorrespondingDeclaration() ==> com.github.javaparser.symbolsolver.model.resolution.SymbolReference.getCorrespondingDeclaration()
  Line 416) applicableMethods.get(i) ==> java.util.List.get(int)
  Line 170) n1.getBegin().get() ==> ERROR
  Line 170) n1.getBegin() ==> com.github.javaparser.ast.nodeTypes.NodeWithRange.getBegin()
  Line 417) isMoreSpecific(winningCandidate, other, argumentsTypes, typeSolver) ==> com.github.javaparser.symbolsolver.resolution.MethodResolutionLogic.isMoreSpecific(com.github.javaparser.symbolsolver.model.declarations.MethodDeclaration, com.github.javaparser.symbolsolver.model.declarations.MethodDeclaration, java.util.List<com.github.javaparser.symbolsolver.model.typesystem.Type>, com.github.javaparser.symbolsolver.model.resolution.TypeSolver)
  Line 419) isMoreSpecific(other, winningCandidate, argumentsTypes, typeSolver) ==> com.github.javaparser.symbolsolver.resolution.MethodResolutionLogic.isMoreSpecific(com.github.javaparser.symbolsolver.model.declarations.MethodDeclaration, com.github.javaparser.symbolsolver.model.declarations.MethodDeclaration, java.util.List<com.github.javaparser.symbolsolver.model.typesystem.Type>, com.github.javaparser.symbolsolver.model.resolution.TypeSolver)
  Line 129) ctClass.getInterfaces() ==> javassist.CtClass.getInterfaces()
  Line 177) inferenceContext.addSingle(methodUsage.returnType()) ==> com.github.javaparser.symbolsolver.logic.InferenceContext.addSingle(com.github.javaparser.symbolsolver.model.typesystem.Type)
  Line 177) methodUsage.returnType() ==> com.github.javaparser.symbolsolver.model.methods.MethodUsage.returnType()
  Line 178) parameters.size() ==> java.util.List.size()
  Line 170) n2.getBegin().get() ==> ERROR
  Line 179) methodUsage.replaceParamType(j, inferenceContext.resolve(parameters.get(j))) ==> com.github.javaparser.symbolsolver.model.methods.MethodUsage.replaceParamType(int, com.github.javaparser.symbolsolver.model.typesystem.Type)
  Line 170) n2.getBegin() ==> com.github.javaparser.ast.nodeTypes.NodeWithRange.getBegin()
  Line 130) new JavassistInterfaceDeclaration(interfaze, typeSolver).solveMethod(name, argumentsTypes, staticOnly) ==> com.github.javaparser.symbolsolver.javassistmodel.JavassistInterfaceDeclaration.solveMethod(java.lang.String, java.util.List<com.github.javaparser.symbolsolver.model.typesystem.Type>, boolean)
  Line 126) symbolSolver.solveSymbol(nameExpr.getName().getId(), nameExpr) ==> com.github.javaparser.symbolsolver.resolution.SymbolSolver.solveSymbol(java.lang.String, com.github.javaparser.ast.Node)
  Line 131) ref.isSolved() ==> com.github.javaparser.symbolsolver.model.resolution.SymbolReference.isSolved()
  Line 126) nameExpr.getName().getId() ==> com.github.javaparser.ast.nodeTypes.NodeWithIdentifier.getId()
  Line 126) nameExpr.getName() ==> com.github.javaparser.ast.expr.NameExpr.getName()
  Line 175) nodes.add(node) ==> java.util.List.add(E)
  Line 423) winningCandidate.declaringType().getQualifiedName().equals(other.declaringType().getQualifiedName()) ==> java.lang.String.equals(java.lang.Object)
  Line 423) winningCandidate.declaringType().getQualifiedName() ==> com.github.javaparser.symbolsolver.model.declarations.TypeDeclaration.getQualifiedName()
  Line 132) candidates.add(ref.getCorrespondingDeclaration()) ==> java.util.List.add(E)
  Line 423) winningCandidate.declaringType() ==> com.github.javaparser.symbolsolver.model.declarations.MethodLikeDeclaration.declaringType()
  Line 423) other.declaringType().getQualifiedName() ==> com.github.javaparser.symbolsolver.model.declarations.TypeDeclaration.getQualifiedName()
  Line 172) getParentNode(wrappedNode) ==> com.github.javaparser.symbolsolver.javaparser.Navigator.getParentNode(com.github.javaparser.ast.Node)
  Line 132) ref.getCorrespondingDeclaration() ==> com.github.javaparser.symbolsolver.model.resolution.SymbolReference.getCorrespondingDeclaration()
  Line 179) inferenceContext.resolve(parameters.get(j)) ==> com.github.javaparser.symbolsolver.logic.InferenceContext.resolve(com.github.javaparser.symbolsolver.model.typesystem.Type)
  Line 179) parameters.get(j) ==> java.util.List.get(int)
  Line 181) methodUsage.replaceReturnType(inferenceContext.resolve(returnType)) ==> com.github.javaparser.symbolsolver.model.methods.MethodUsage.replaceReturnType(com.github.javaparser.symbolsolver.model.typesystem.Type)
  Line 176) node.getChildNodes().forEach(c -> collectAllNodes(c, nodes)) ==> java.lang.Iterable.forEach(java.util.function.Consumer<? super T>)
  Line 173) containerName.isEmpty() ==> java.lang.String.isEmpty()
  Line 174) getName() ==> com.github.javaparser.symbolsolver.javaparsermodel.declarations.JavaParserAnonymousClassDeclaration.getName()
  Line 176) getName() ==> com.github.javaparser.symbolsolver.javaparsermodel.declarations.JavaParserAnonymousClassDeclaration.getName()
  Line 176) node.getChildNodes() ==> com.github.javaparser.ast.Node.getChildNodes()
  Line 139) MethodResolutionLogic.findMostApplicable(candidates, name, argumentsTypes, typeSolver) ==> com.github.javaparser.symbolsolver.resolution.MethodResolutionLogic.findMostApplicable(java.util.List<com.github.javaparser.symbolsolver.model.declarations.MethodDeclaration>, java.lang.String, java.util.List<com.github.javaparser.symbolsolver.model.typesystem.Type>, com.github.javaparser.symbolsolver.model.resolution.TypeSolver)
  Line 423) other.declaringType() ==> com.github.javaparser.symbolsolver.model.declarations.MethodLikeDeclaration.declaringType()
  Line 135) wrappedNode.getTypeArguments().map(nodes -> ((NodeWithTypeArguments<?>) nodes).getTypeArguments().orElse(new NodeList<>())).orElse(new NodeList<>()).stream().filter(type -> type.toString().equals(name)).findFirst().map(matchingType -> SymbolReference.solved(new JavaParserTypeParameter(new TypeParameter(matchingType.toString()), typeSolver))) ==> ERROR
  Line 432) isExactMatch(winningCandidate, argumentsTypes) ==> com.github.javaparser.symbolsolver.resolution.MethodResolutionLogic.isExactMatch(com.github.javaparser.symbolsolver.model.declarations.MethodLikeDeclaration, java.util.List<com.github.javaparser.symbolsolver.model.typesystem.Type>)
  Line 135) wrappedNode.getTypeArguments().map(nodes -> ((NodeWithTypeArguments<?>) nodes).getTypeArguments().orElse(new NodeList<>())).orElse(new NodeList<>()).stream().filter(type -> type.toString().equals(name)).findFirst() ==> ERROR
  Line 433) isExactMatch(other, argumentsTypes) ==> com.github.javaparser.symbolsolver.resolution.MethodResolutionLogic.isExactMatch(com.github.javaparser.symbolsolver.model.declarations.MethodLikeDeclaration, java.util.List<com.github.javaparser.symbolsolver.model.typesystem.Type>)
  Line 440) SymbolReference.solved(winningCandidate) ==> com.github.javaparser.symbolsolver.model.resolution.SymbolReference.solved(S2)
  Line 135) wrappedNode.getTypeArguments().map(nodes -> ((NodeWithTypeArguments<?>) nodes).getTypeArguments().orElse(new NodeList<>())).orElse(new NodeList<>()).stream().filter(type -> type.toString().equals(name)) ==> ERROR
  Line 135) wrappedNode.getTypeArguments().map(nodes -> ((NodeWithTypeArguments<?>) nodes).getTypeArguments().orElse(new NodeList<>())).orElse(new NodeList<>()).stream() ==> java.util.Collection.stream()
  Line 135) wrappedNode.getTypeArguments().map(nodes -> ((NodeWithTypeArguments<?>) nodes).getTypeArguments().orElse(new NodeList<>())).orElse(new NodeList<>()) ==> java.util.Optional.orElse(T)
  Line 445) method.getNumberOfParams() ==> com.github.javaparser.symbolsolver.model.declarations.MethodLikeDeclaration.getNumberOfParams()
  Line 135) wrappedNode.getTypeArguments().map(nodes -> ((NodeWithTypeArguments<?>) nodes).getTypeArguments().orElse(new NodeList<>())) ==> java.util.Optional.map(java.util.function.Function<? super T, ? extends U>)
  Line 135) wrappedNode.getTypeArguments() ==> com.github.javaparser.ast.expr.ObjectCreationExpr.getTypeArguments()
  Line 138) ((NodeWithTypeArguments<?>) nodes).getTypeArguments().orElse(new NodeList<>()) ==> java.util.Optional.orElse(T)
  Line 138) ((NodeWithTypeArguments<?>) nodes).getTypeArguments() ==> com.github.javaparser.ast.nodeTypes.NodeWithTypeArguments.getTypeArguments()
  Line 181) inferenceContext.resolve(returnType) ==> com.github.javaparser.symbolsolver.logic.InferenceContext.resolve(com.github.javaparser.symbolsolver.model.typesystem.Type)
  Line 182) Optional.of(methodUsage) ==> java.util.Optional.of(T)
  Line 184) Optional.empty() ==> java.util.Optional.empty()
  Line 142) type.toString().equals(name) ==> ERROR
  Line 130) symbolSolver.solveSymbol(nameExpr.getId(), nameExpr) ==> com.github.javaparser.symbolsolver.resolution.SymbolSolver.solveSymbol(java.lang.String, com.github.javaparser.ast.Node)
  Line 176) collectAllNodes(c, nodes) ==> com.github.javaparser.symbolsolver.SourceFileInfoExtractor.collectAllNodes(com.github.javaparser.ast.Node, java.util.List<com.github.javaparser.ast.Node>)
  Line 446) method.getParam(i).getType().equals(argumentsTypes.get(i)) ==> java.lang.Object.equals(java.lang.Object)
  Line 453) otherParam.asTypeVariable().asTypeParameter().getBounds(other.typeSolver).stream().map(bound -> bound.getType()).collect(Collectors.toList()) ==> java.util.stream.Stream.collect(java.util.stream.Collector<? super T, A, R>)
  Line 149) javassistTypeDeclarationAdapter.getDeclaredFields() ==> com.github.javaparser.symbolsolver.javassistmodel.JavassistTypeDeclarationAdapter.getDeclaredFields()
  Line 183) findMembersOfKind(com.github.javaparser.ast.body.TypeDeclaration.class).stream().map(typeMember -> JavaParserFacade.get(typeSolver).getTypeDeclaration(typeMember)).collect(Collectors.toSet()) ==> java.util.stream.Stream.collect(java.util.stream.Collector<? super T, A, R>)
