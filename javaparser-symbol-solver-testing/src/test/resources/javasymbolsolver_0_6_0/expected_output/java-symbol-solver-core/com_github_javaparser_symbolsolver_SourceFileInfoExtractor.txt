  Line 45) Object.class.getCanonicalName().equals(getQualifiedName()) ==> java.lang.String.equals(java.lang.Object)
  Line 45) Object.class.getCanonicalName() ==> java.lang.Class.getCanonicalName()
  Line 45) getQualifiedName() ==> com.github.javaparser.symbolsolver.model.declarations.TypeDeclaration.getQualifiedName()
  Line 46) getAncestors() ==> com.github.javaparser.symbolsolver.model.declarations.ReferenceTypeDeclaration.getAncestors()
  Line 64) getOuterTypeName(qualifiedName) ==> com.github.javaparser.symbolsolver.javaparser.Navigator.getOuterTypeName(java.lang.String)
  Line 66) Optional.empty() ==> java.util.Optional.empty()
  Line 44) type.isReferenceType() ==> com.github.javaparser.symbolsolver.model.typesystem.Type.isReferenceType()
  Line 44) type.asReferenceType().getTypeDeclaration().isInterface() ==> com.github.javaparser.symbolsolver.model.declarations.TypeDeclaration.isInterface()
  Line 44) type.asReferenceType().getTypeDeclaration() ==> com.github.javaparser.symbolsolver.model.typesystem.ReferenceType.getTypeDeclaration()
  Line 108) constructor.getParam(i).isVariadic() ==> com.github.javaparser.symbolsolver.model.declarations.ParameterDeclaration.isVariadic()
  Line 44) type.asReferenceType() ==> com.github.javaparser.symbolsolver.model.typesystem.Type.asReferenceType()
  Line 108) constructor.getParam(i) ==> com.github.javaparser.symbolsolver.model.declarations.MethodLikeDeclaration.getParam(int)
  Line 109) new ArrayType(expectedType).isAssignableBy(actualType) ==> com.github.javaparser.symbolsolver.model.typesystem.ArrayType.isAssignableBy(com.github.javaparser.symbolsolver.model.typesystem.Type)
  Line 110) expectedType.isReferenceType() ==> com.github.javaparser.symbolsolver.model.typesystem.Type.isReferenceType()
  Line 45) getFunctionalMethod(type.asReferenceType().getTypeDeclaration()) ==> com.github.javaparser.symbolsolver.logic.FunctionalInterfaceLogic.getFunctionalMethod(com.github.javaparser.symbolsolver.model.declarations.ReferenceTypeDeclaration)
  Line 45) type.asReferenceType().getTypeDeclaration() ==> com.github.javaparser.symbolsolver.model.typesystem.ReferenceType.getTypeDeclaration()
  Line 111) actualType.isReferenceType() ==> com.github.javaparser.symbolsolver.model.typesystem.Type.isReferenceType()
  Line 45) type.asReferenceType() ==> com.github.javaparser.symbolsolver.model.typesystem.Type.asReferenceType()
  Line 47) Optional.empty() ==> java.util.Optional.empty()
  Line 38) node.getClass().getCanonicalName() ==> java.lang.Class.getCanonicalName()
  Line 62) Collections.emptyList() ==> java.util.Collections.emptyList()
  Line 106) ctClass.getPackageName() ==> javassist.CtClass.getPackageName()
  Line 54) baseType.hashCode() ==> java.lang.Object.hashCode()
  Line 38) node.getClass() ==> java.lang.Object.getClass()
  Line 47) ancestors.add(ancestor) ==> java.util.List.add(E)
  Line 67) td.getMembers() ==> com.github.javaparser.ast.body.TypeDeclaration.getMembers()
  Line 44) ((JavaParserEnumDeclaration.ValuesMethod) methodDeclaration).resolveTypeVariables(context, parameterTypes) ==> com.github.javaparser.symbolsolver.javaparsermodel.declarations.JavaParserEnumDeclaration.ValuesMethod.resolveTypeVariables(com.github.javaparser.symbolsolver.core.resolution.Context, java.util.List<com.github.javaparser.symbolsolver.model.typesystem.Type>)
  Line 112) MethodResolutionLogic.isAssignableMatchTypeParameters(expectedType.asReferenceType(), actualType.asReferenceType(), matchedParameters) ==> com.github.javaparser.symbolsolver.resolution.MethodResolutionLogic.isAssignableMatchTypeParameters(com.github.javaparser.symbolsolver.model.typesystem.ReferenceType, com.github.javaparser.symbolsolver.model.typesystem.ReferenceType, java.util.Map<java.lang.String, com.github.javaparser.symbolsolver.model.typesystem.Type>)
  Line 56) typeDeclaration.getAllMethods().stream().filter(m -> m.getDeclaration().isAbstract()).filter(m -> !declaredOnObject(m)).collect(Collectors.toSet()) ==> java.util.stream.Stream.collect(java.util.stream.Collector<? super T, A, R>)
