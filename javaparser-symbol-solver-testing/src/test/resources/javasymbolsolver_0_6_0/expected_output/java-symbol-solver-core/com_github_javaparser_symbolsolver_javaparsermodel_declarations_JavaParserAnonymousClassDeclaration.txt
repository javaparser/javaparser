  Line 82) wildcard.getBoundedType() ==> com.github.javaparser.symbolsolver.model.typesystem.Wildcard.getBoundedType()
  Line 84) wildcard.isSuper() ==> com.github.javaparser.symbolsolver.model.typesystem.Wildcard.isSuper()
  Line 283) node.getClass() ==> java.lang.Object.getClass()
  Line 86) inferenceVariableType.superTypes.add(wildcard.getBoundedType()) ==> java.util.Set.add(E)
  Line 236) typeParametersMap() ==> com.github.javaparser.symbolsolver.model.typesystem.ReferenceType.typeParametersMap()
  Line 237) Collectors.toList() ==> java.util.stream.Collectors.toList()
  Line 86) wildcard.getBoundedType() ==> com.github.javaparser.symbolsolver.model.typesystem.Wildcard.getBoundedType()
  Line 37) UUID.randomUUID() ==> java.util.UUID.randomUUID()
  Line 240) ancestors.removeIf(a -> a.getQualifiedName().equals(Object.class.getCanonicalName())) ==> java.util.Collection.removeIf(java.util.function.Predicate<? super E>)
  Line 102) considered.add(inferenceVariableType) ==> java.util.Set.add(E)
  Line 44) JavaParserFactory.getContext(wrappedNode.getParentNode().get(), typeSolver).solveType(wrappedNode.getType().getName().getId(), typeSolver).getCorrespondingDeclaration() ==> com.github.javaparser.symbolsolver.model.resolution.SymbolReference.getCorrespondingDeclaration()
  Line 44) JavaParserFactory.getContext(wrappedNode.getParentNode().get(), typeSolver).solveType(wrappedNode.getType().getName().getId(), typeSolver) ==> com.github.javaparser.symbolsolver.core.resolution.Context.solveType(java.lang.String, com.github.javaparser.symbolsolver.model.resolution.TypeSolver)
  Line 53) ctClass.isEnum() ==> javassist.CtClass.isEnum()
  Line 54) ctClass.toString() ==> javassist.CtClass.toString()
  Line 44) JavaParserFactory.getContext(wrappedNode.getParentNode().get(), typeSolver) ==> com.github.javaparser.symbolsolver.javaparsermodel.JavaParserFactory.getContext(com.github.javaparser.ast.Node, com.github.javaparser.symbolsolver.model.resolution.TypeSolver)
  Line 44) wrappedNode.getParentNode().get() ==> java.util.Optional.get()
  Line 44) wrappedNode.getParentNode() ==> com.github.javaparser.ast.Node.getParentNode()
  Line 45) wrappedNode.getType().getName().getId() ==> com.github.javaparser.ast.nodeTypes.NodeWithIdentifier.getId()
  Line 63) JavassistFactory.modifiersToAccessLevel(ctClass.getModifiers()) ==> com.github.javaparser.symbolsolver.javassistmodel.JavassistFactory.modifiersToAccessLevel(int)
  Line 45) wrappedNode.getType().getName() ==> com.github.javaparser.ast.type.ClassOrInterfaceType.getName()
  Line 240) a.getQualifiedName().equals(Object.class.getCanonicalName()) ==> java.lang.String.equals(java.lang.Object)
  Line 63) ctClass.getModifiers() ==> javassist.CtClass.getModifiers()
  Line 45) wrappedNode.getType() ==> com.github.javaparser.ast.expr.ObjectCreationExpr.getType()
  Line 240) a.getQualifiedName() ==> com.github.javaparser.symbolsolver.model.typesystem.ReferenceType.getQualifiedName()
  Line 240) Object.class.getCanonicalName() ==> java.lang.Class.getCanonicalName()
  Line 288) node.getClass().getCanonicalName() ==> java.lang.Class.getCanonicalName()
  Line 68) ctClass.getPackageName() ==> javassist.CtClass.getPackageName()
  Line 241) typeSolver.solveType(Object.class.getCanonicalName()) ==> com.github.javaparser.symbolsolver.model.resolution.TypeSolver.solveType(java.lang.String)
  Line 241) Object.class.getCanonicalName() ==> java.lang.Class.getCanonicalName()
  Line 242) create(objectType, typeSolver) ==> com.github.javaparser.symbolsolver.model.typesystem.ReferenceType.create(com.github.javaparser.symbolsolver.model.declarations.ReferenceTypeDeclaration, com.github.javaparser.symbolsolver.model.resolution.TypeSolver)
  Line 73) ctClass.getName().replace('$', '.') ==> java.lang.String.replace(char, char)
  Line 73) ctClass.getName() ==> javassist.CtClass.getName()
  Line 243) ancestors.add(objectRef) ==> java.util.List.add(E)
  Line 74) getPackageName() ==> com.github.javaparser.symbolsolver.javassistmodel.JavassistEnumDeclaration.getPackageName()
  Line 288) node.getClass() ==> java.lang.Object.getClass()
  Line 104) result.addAll(inferenceVariableType.equivalentTypes.stream().filter(t -> !t.isTypeVariable() && !(t instanceof InferenceVariableType)).collect(Collectors.toSet())) ==> java.util.Set.addAll(java.util.Collection<? extends E>)
  Line 173) Arrays.stream(clazz.getDeclaredMethods()).filter((m) -> m.getName().equals(name)).sorted(new MethodComparator()) ==> java.util.stream.Stream.sorted(java.util.Comparator<? super T>)
  Line 104) inferenceVariableType.equivalentTypes.stream().filter(t -> !t.isTypeVariable() && !(t instanceof InferenceVariableType)).collect(Collectors.toSet()) ==> java.util.stream.Stream.collect(java.util.stream.Collector<? super T, A, R>)
  Line 173) Arrays.stream(clazz.getDeclaredMethods()).filter((m) -> m.getName().equals(name)) ==> java.util.stream.Stream.filter(java.util.function.Predicate<? super T>)
  Line 104) inferenceVariableType.equivalentTypes.stream().filter(t -> !t.isTypeVariable() && !(t instanceof InferenceVariableType)) ==> java.util.stream.Stream.filter(java.util.function.Predicate<? super T>)
  Line 104) inferenceVariableType.equivalentTypes.stream() ==> java.util.Collection.stream()
  Line 173) Arrays.stream(clazz.getDeclaredMethods()) ==> java.util.Arrays.stream(T[])
  Line 293) node.getClass().getCanonicalName() ==> java.lang.Class.getCanonicalName()
  Line 104) t.isTypeVariable() ==> com.github.javaparser.symbolsolver.model.typesystem.Type.isTypeVariable()
  Line 104) Collectors.toSet() ==> java.util.stream.Collectors.toSet()
  Line 293) node.getClass() ==> java.lang.Object.getClass()
  Line 245) result.transformTypeParameters(typeParam -> replaceTypeParam(typeParam, tp, typeSolver)) ==> com.github.javaparser.symbolsolver.model.typesystem.ReferenceType.transformTypeParameters(com.github.javaparser.symbolsolver.model.typesystem.TypeTransformer)
  Line 298) node.getClass().getCanonicalName() ==> java.lang.Class.getCanonicalName()
  Line 105) inferenceVariableType.equivalentTypes.stream().filter(t -> t instanceof InferenceVariableType).forEach(t -> {
    InferenceVariableType ivt = (InferenceVariableType) t;
    if (!considered.contains(ivt)) {
        result.addAll(concreteEquivalentTypesAlsoIndirectly(considered, ivt));
    }
}) ==> java.util.stream.Stream.forEach(java.util.function.Consumer<? super T>)
  Line 298) node.getClass() ==> java.lang.Object.getClass()
  Line 105) inferenceVariableType.equivalentTypes.stream().filter(t -> t instanceof InferenceVariableType) ==> java.util.stream.Stream.filter(java.util.function.Predicate<? super T>)
  Line 105) inferenceVariableType.equivalentTypes.stream() ==> java.util.Collection.stream()
  Line 107) considered.contains(ivt) ==> java.util.Set.contains(java.lang.Object)
  Line 88) JavaParserFactory.getContext(localType, typeSolver) ==> com.github.javaparser.symbolsolver.javaparsermodel.JavaParserFactory.getContext(com.github.javaparser.ast.Node, com.github.javaparser.symbolsolver.model.resolution.TypeSolver)
  Line 245) replaceTypeParam(typeParam, tp, typeSolver) ==> com.github.javaparser.symbolsolver.resolution.MethodResolutionLogic.replaceTypeParam(com.github.javaparser.symbolsolver.model.typesystem.Type, com.github.javaparser.symbolsolver.model.declarations.TypeParameterDeclaration, com.github.javaparser.symbolsolver.model.resolution.TypeSolver)
  Line 108) result.addAll(concreteEquivalentTypesAlsoIndirectly(considered, ivt)) ==> java.util.Set.addAll(java.util.Collection<? extends E>)
  Line 247) type.isWildcard() ==> com.github.javaparser.symbolsolver.model.typesystem.Type.isWildcard()
  Line 108) concreteEquivalentTypesAlsoIndirectly(considered, ivt) ==> com.github.javaparser.symbolsolver.logic.InferenceVariableType.concreteEquivalentTypesAlsoIndirectly(java.util.Set<com.github.javaparser.symbolsolver.logic.InferenceVariableType>, com.github.javaparser.symbolsolver.logic.InferenceVariableType)
  Line 75) name.substring(getPackageName().length() + 1, name.length()) ==> java.lang.String.substring(int, int)
  Line 75) getPackageName().length() ==> java.lang.String.length()
  Line 75) getPackageName() ==> com.github.javaparser.symbolsolver.javassistmodel.JavassistEnumDeclaration.getPackageName()
  Line 75) name.length() ==> java.lang.String.length()
  Line 248) type.describe().equals(tp.getName()) ==> java.lang.String.equals(java.lang.Object)
  Line 115) concreteEquivalentTypesAlsoIndirectly(new HashSet<>(), this) ==> com.github.javaparser.symbolsolver.logic.InferenceVariableType.concreteEquivalentTypesAlsoIndirectly(java.util.Set<com.github.javaparser.symbolsolver.logic.InferenceVariableType>, com.github.javaparser.symbolsolver.logic.InferenceVariableType)
  Line 248) type.describe() ==> com.github.javaparser.symbolsolver.model.typesystem.Type.describe()
  Line 116) concreteEquivalent.isEmpty() ==> java.util.Set.isEmpty()
  Line 118) objectProvider.object() ==> com.github.javaparser.symbolsolver.logic.ObjectProvider.object()
  Line 123) concreteEquivalent.size() ==> java.util.Set.size()
  Line 124) concreteEquivalent.iterator().next() ==> java.util.Iterator.next()
  Line 124) concreteEquivalent.iterator() ==> java.util.Set.iterator()
  Line 82) ctClass.getName().replace('$', '.') ==> java.lang.String.replace(char, char)
  Line 89) name.substring(localType.getName().getId().length() + 1) ==> java.lang.String.substring(int)
  Line 89) localType.getName().getId().length() ==> java.lang.String.length()
  Line 173) clazz.getDeclaredMethods() ==> java.lang.Class.getDeclaredMethods()
  Line 173) m.getName().equals(name) ==> java.lang.String.equals(java.lang.Object)
  Line 89) localType.getName().getId() ==> com.github.javaparser.ast.nodeTypes.NodeWithIdentifier.getId()
  Line 173) m.getName() ==> java.lang.reflect.Method.getName()
  Line 173) Collectors.toList() ==> java.util.stream.Collectors.toList()
  Line 89) localType.getName() ==> com.github.javaparser.ast.body.TypeDeclaration.getName()
  Line 174) method.isBridge() ==> java.lang.reflect.Method.isBridge()
  Line 248) tp.getName() ==> com.github.javaparser.symbolsolver.model.declarations.TypeParameterDeclaration.getName()
  Line 54) wrappedNode.getAnonymousClassBody().get().stream().filter(node -> memberClass.isAssignableFrom(node.getClass())).map(node -> (T) node).collect(Collectors.toList()) ==> ERROR
  Line 249) tp.getBounds(typeSolver) ==> com.github.javaparser.symbolsolver.model.declarations.TypeParameterDeclaration.getBounds(com.github.javaparser.symbolsolver.model.resolution.TypeSolver)
  Line 250) bounds.size() ==> java.util.List.size()
  Line 252) bounds.size() ==> java.util.List.size()
  Line 93) getParent().solveType(name, typeSolver) ==> com.github.javaparser.symbolsolver.core.resolution.Context.solveType(java.lang.String, com.github.javaparser.symbolsolver.model.resolution.TypeSolver)
  Line 93) getParent() ==> com.github.javaparser.symbolsolver.javaparsermodel.contexts.AbstractJavaParserContext.getParent()
  Line 54) wrappedNode.getAnonymousClassBody().get().stream().filter(node -> memberClass.isAssignableFrom(node.getClass())).map(node -> (T) node) ==> ERROR
  Line 303) node.getClass().getCanonicalName() ==> java.lang.Class.getCanonicalName()
  Line 54) wrappedNode.getAnonymousClassBody().get().stream().filter(node -> memberClass.isAssignableFrom(node.getClass())) ==> ERROR
  Line 54) wrappedNode.getAnonymousClassBody().get().stream() ==> java.util.Collection.stream()
  Line 54) wrappedNode.getAnonymousClassBody().get() ==> java.util.Optional.get()
  Line 82) ctClass.getName() ==> javassist.CtClass.getName()
  Line 174) method.isSynthetic() ==> java.lang.reflect.Method.isSynthetic()
  Line 177) getTypeParameters().size() ==> java.util.List.size()
  Line 177) getTypeParameters() ==> com.github.javaparser.symbolsolver.reflectionmodel.ReflectionClassDeclaration.getTypeParameters()
  Line 91) ctClass.getSuperclass() ==> javassist.CtClass.getSuperclass()
  Line 99) getParent().solveMethod(name, argumentsTypes, false, typeSolver) ==> com.github.javaparser.symbolsolver.core.resolution.Context.solveMethod(java.lang.String, java.util.List<com.github.javaparser.symbolsolver.model.typesystem.Type>, boolean, com.github.javaparser.symbolsolver.model.resolution.TypeSolver)
  Line 99) getParent() ==> com.github.javaparser.symbolsolver.javaparsermodel.contexts.AbstractJavaParserContext.getParent()
  Line 94) JavassistFactory.typeUsageFor(superClass, typeSolver) ==> com.github.javaparser.symbolsolver.javassistmodel.JavassistFactory.typeUsageFor(javassist.CtClass, com.github.javaparser.symbolsolver.model.resolution.TypeSolver)
  Line 248) getAllAncestors().stream().filter(it -> it.getTypeDeclaration().isInterface()).collect(Collectors.toList()) ==> java.util.stream.Stream.collect(java.util.stream.Collector<? super T, A, R>)
  Line 248) getAllAncestors().stream().filter(it -> it.getTypeDeclaration().isInterface()) ==> java.util.stream.Stream.filter(java.util.function.Predicate<? super T>)
  Line 248) getAllAncestors().stream() ==> java.util.Collection.stream()
  Line 248) getAllAncestors() ==> com.github.javaparser.symbolsolver.model.typesystem.ReferenceType.getAllAncestors()
  Line 249) it.getTypeDeclaration().isInterface() ==> com.github.javaparser.symbolsolver.model.declarations.TypeDeclaration.isInterface()
  Line 303) node.getClass() ==> java.lang.Object.getClass()
  Line 253) bounds.get(0).getType() ==> com.github.javaparser.symbolsolver.model.declarations.TypeParameterDeclaration.Bound.getType()
  Line 126) equivalentTypes.stream().filter(t -> !t.isTypeVariable() && !hasInferenceVariables(t)).collect(Collectors.toSet()) ==> java.util.stream.Stream.collect(java.util.stream.Collector<? super T, A, R>)
  Line 54) wrappedNode.getAnonymousClassBody() ==> com.github.javaparser.ast.expr.ObjectCreationExpr.getAnonymousClassBody()
  Line 177) typeParameterValues.size() ==> java.util.List.size()
  Line 96) superClassTypeUsage.isReferenceType() ==> com.github.javaparser.symbolsolver.model.typesystem.Type.isReferenceType()
  Line 249) it.getTypeDeclaration() ==> com.github.javaparser.symbolsolver.model.typesystem.ReferenceType.getTypeDeclaration()
