  Line 58) wrappedNode.getParameters() ==> com.github.javaparser.ast.expr.LambdaExpr.getParameters()
  Line 59) JavaParserFactory.getSymbolDeclarator(parameter, typeSolver) ==> com.github.javaparser.symbolsolver.javaparsermodel.JavaParserFactory.getSymbolDeclarator(com.github.javaparser.ast.Node, com.github.javaparser.symbolsolver.model.resolution.TypeSolver)
  Line 61) sb.getSymbolDeclarations() ==> com.github.javaparser.symbolsolver.resolution.SymbolDeclarator.getSymbolDeclarations()
  Line 480) JavaParserFactory.getContext(node, typeSolver) ==> com.github.javaparser.symbolsolver.javaparsermodel.JavaParserFactory.getContext(com.github.javaparser.ast.Node, com.github.javaparser.symbolsolver.model.resolution.TypeSolver)
  Line 62) decl.getName().equals(name) ==> java.lang.String.equals(java.lang.Object)
  Line 62) decl.getName() ==> com.github.javaparser.symbolsolver.model.declarations.Declaration.getName()
  Line 484) convertToUsage(type, context) ==> com.github.javaparser.symbolsolver.javaparsermodel.JavaParserFacade.convertToUsage(com.github.javaparser.ast.type.Type, com.github.javaparser.symbolsolver.core.resolution.Context)
  Line 489) call.getArguments() ==> com.github.javaparser.ast.expr.MethodCallExpr.getArguments()
  Line 63) getParentNode(wrappedNode) ==> com.github.javaparser.symbolsolver.javaparser.Navigator.getParentNode(com.github.javaparser.ast.Node)
  Line 490) call.getArguments() ==> com.github.javaparser.ast.expr.MethodCallExpr.getArguments()
  Line 493) params.add(getType(param, false)) ==> java.util.List.add(E)
  Line 64) getParentNode(wrappedNode) ==> com.github.javaparser.symbolsolver.javaparser.Navigator.getParentNode(com.github.javaparser.ast.Node)
  Line 65) JavaParserFacade.get(typeSolver).solveMethodAsUsage(methodCallExpr) ==> com.github.javaparser.symbolsolver.javaparsermodel.JavaParserFacade.solveMethodAsUsage(com.github.javaparser.ast.expr.MethodCallExpr)
  Line 65) JavaParserFacade.get(typeSolver) ==> com.github.javaparser.symbolsolver.javaparsermodel.JavaParserFacade.get(com.github.javaparser.symbolsolver.model.resolution.TypeSolver)
  Line 493) getType(param, false) ==> com.github.javaparser.symbolsolver.javaparsermodel.JavaParserFacade.getType(com.github.javaparser.ast.Node, boolean)
  Line 495) String.format("Error calculating the type of parameter %s of method call %s", param, call) ==> java.lang.String.format(java.lang.String, java.lang.Object...)
  Line 66) pos(methodCallExpr, wrappedNode) ==> com.github.javaparser.symbolsolver.javaparsermodel.contexts.LambdaExprContext.pos(com.github.javaparser.ast.expr.MethodCallExpr, com.github.javaparser.ast.expr.Expression)
  Line 67) methodUsage.getParamTypes().get(i) ==> java.util.List.get(int)
  Line 67) methodUsage.getParamTypes() ==> com.github.javaparser.symbolsolver.model.methods.MethodUsage.getParamTypes()
  Line 70) FunctionalInterfaceLogic.getFunctionalMethod(lambdaType) ==> com.github.javaparser.symbolsolver.logic.FunctionalInterfaceLogic.getFunctionalMethod(com.github.javaparser.symbolsolver.model.typesystem.Type)
  Line 500) JavaParserFactory.getContext(call, typeSolver) ==> com.github.javaparser.symbolsolver.javaparsermodel.JavaParserFactory.getContext(com.github.javaparser.ast.Node, com.github.javaparser.symbolsolver.model.resolution.TypeSolver)
  Line 71) functionalMethodOpt.isPresent() ==> java.util.Optional.isPresent()
  Line 72) functionalMethodOpt.get() ==> java.util.Optional.get()
  Line 501) context.solveMethodAsUsage(call.getName().getId(), params, typeSolver) ==> com.github.javaparser.symbolsolver.core.resolution.Context.solveMethodAsUsage(java.lang.String, java.util.List<com.github.javaparser.symbolsolver.model.typesystem.Type>, com.github.javaparser.symbolsolver.model.resolution.TypeSolver)
  Line 501) call.getName().getId() ==> com.github.javaparser.ast.nodeTypes.NodeWithIdentifier.getId()
  Line 501) call.getName() ==> com.github.javaparser.ast.expr.MethodCallExpr.getName()
  Line 502) methodUsage.isPresent() ==> java.util.Optional.isPresent()
  Line 503) call.getName() ==> com.github.javaparser.ast.expr.MethodCallExpr.getName()
  Line 504) call.getRange().get() ==> java.util.Optional.get()
  Line 504) call.getRange() ==> com.github.javaparser.ast.Node.getRange()
  Line 506) methodUsage.get() ==> java.util.Optional.get()
  Line 77) inferenceContext.addPair(lambdaType, new ReferenceTypeImpl(lambdaType.asReferenceType().getTypeDeclaration(), typeSolver)) ==> com.github.javaparser.symbolsolver.logic.InferenceContext.addPair(com.github.javaparser.symbolsolver.model.typesystem.Type, com.github.javaparser.symbolsolver.model.typesystem.Type)
  Line 77) lambdaType.asReferenceType().getTypeDeclaration() ==> com.github.javaparser.symbolsolver.model.typesystem.ReferenceType.getTypeDeclaration()
  Line 77) lambdaType.asReferenceType() ==> com.github.javaparser.symbolsolver.model.typesystem.Type.asReferenceType()
  Line 82) wrappedNode.getParameters().size() ==> com.github.javaparser.ast.NodeList.size()
  Line 82) wrappedNode.getParameters() ==> com.github.javaparser.ast.expr.LambdaExpr.getParameters()
  Line 83) wrappedNode.getParameter(lambdaParamIndex).getName().getIdentifier().equals(name) ==> java.lang.String.equals(java.lang.Object)
  Line 83) wrappedNode.getParameter(lambdaParamIndex).getName().getIdentifier() ==> com.github.javaparser.ast.expr.SimpleName.getIdentifier()
  Line 83) wrappedNode.getParameter(lambdaParamIndex).getName() ==> com.github.javaparser.ast.body.Parameter.getName()
  Line 83) wrappedNode.getParameter(lambdaParamIndex) ==> com.github.javaparser.ast.nodeTypes.NodeWithParameters.getParameter(int)
  Line 88) Optional.empty() ==> java.util.Optional.empty()
  Line 91) inferenceContext.resolve(inferenceContext.addSingle(functionalMethod.getParamType(lambdaParamIndex))) ==> com.github.javaparser.symbolsolver.logic.InferenceContext.resolve(com.github.javaparser.symbolsolver.model.typesystem.Type)
  Line 91) inferenceContext.addSingle(functionalMethod.getParamType(lambdaParamIndex)) ==> com.github.javaparser.symbolsolver.logic.InferenceContext.addSingle(com.github.javaparser.symbolsolver.model.typesystem.Type)
  Line 91) functionalMethod.getParamType(lambdaParamIndex) ==> com.github.javaparser.symbolsolver.model.methods.MethodUsage.getParamType(int)
  Line 94) argType.isWildcard() ==> com.github.javaparser.symbolsolver.model.typesystem.Type.isWildcard()
  Line 95) LambdaConstraintType.bound(argType.asWildcard().getBoundedType()) ==> com.github.javaparser.symbolsolver.model.typesystem.LambdaConstraintType.bound(com.github.javaparser.symbolsolver.model.typesystem.Type)
  Line 95) argType.asWildcard().getBoundedType() ==> com.github.javaparser.symbolsolver.model.typesystem.Wildcard.getBoundedType()
  Line 95) argType.asWildcard() ==> com.github.javaparser.symbolsolver.model.typesystem.Type.asWildcard()
  Line 97) LambdaConstraintType.bound(argType) ==> com.github.javaparser.symbolsolver.model.typesystem.LambdaConstraintType.bound(com.github.javaparser.symbolsolver.model.typesystem.Type)
  Line 100) Optional.of(value) ==> java.util.Optional.of(T)
  Line 102) Optional.empty() ==> java.util.Optional.empty()
  Line 510) JavaParserFactory.toTypeDeclaration(classOrInterfaceDeclaration, typeSolver) ==> com.github.javaparser.symbolsolver.javaparsermodel.JavaParserFactory.toTypeDeclaration(com.github.javaparser.ast.Node, com.github.javaparser.symbolsolver.model.resolution.TypeSolver)
  Line 104) getParentNode(wrappedNode) ==> com.github.javaparser.symbolsolver.javaparser.Navigator.getParentNode(com.github.javaparser.ast.Node)
  Line 62) getParentNode(wrappedNode) ==> com.github.javaparser.symbolsolver.javaparser.Navigator.getParentNode(com.github.javaparser.ast.Node)
  Line 105) getParentNode(wrappedNode) ==> com.github.javaparser.symbolsolver.javaparser.Navigator.getParentNode(com.github.javaparser.ast.Node)
  Line 68) JavaParserFacade.get(typeSolver).convert(wrappedNode.getType(), getContext()) ==> com.github.javaparser.symbolsolver.javaparsermodel.JavaParserFacade.convert(com.github.javaparser.ast.type.Type, com.github.javaparser.symbolsolver.core.resolution.Context)
  Line 106) JavaParserFacade.get(typeSolver).convertToUsageVariableType(variableDeclarator) ==> com.github.javaparser.symbolsolver.javaparsermodel.JavaParserFacade.convertToUsageVariableType(com.github.javaparser.ast.body.VariableDeclarator)
  Line 68) JavaParserFacade.get(typeSolver) ==> com.github.javaparser.symbolsolver.javaparsermodel.JavaParserFacade.get(com.github.javaparser.symbolsolver.model.resolution.TypeSolver)
  Line 106) JavaParserFacade.get(typeSolver) ==> com.github.javaparser.symbolsolver.javaparsermodel.JavaParserFacade.get(com.github.javaparser.symbolsolver.model.resolution.TypeSolver)
  Line 107) FunctionalInterfaceLogic.getFunctionalMethod(t) ==> com.github.javaparser.symbolsolver.logic.FunctionalInterfaceLogic.getFunctionalMethod(com.github.javaparser.symbolsolver.model.typesystem.Type)
  Line 68) wrappedNode.getType() ==> com.github.javaparser.ast.body.MethodDeclaration.getType()
  Line 68) getContext() ==> com.github.javaparser.symbolsolver.javaparsermodel.declarations.JavaParserMethodDeclaration.getContext()
  Line 108) functionalMethod.isPresent() ==> java.util.Optional.isPresent()
  Line 73) wrappedNode.getParameters().size() ==> com.github.javaparser.ast.NodeList.size()
  Line 73) wrappedNode.getParameters() ==> com.github.javaparser.ast.body.CallableDeclaration.getParameters()
  Line 78) getNumberOfParams() ==> com.github.javaparser.symbolsolver.javaparsermodel.declarations.JavaParserMethodDeclaration.getNumberOfParams()
  Line 109) functionalMethod.get().getParamType(index) ==> com.github.javaparser.symbolsolver.model.methods.MethodUsage.getParamType(int)
  Line 79) String.format("No param with index %d. Number of params: %d", i, getNumberOfParams()) ==> java.lang.String.format(java.lang.String, java.lang.Object...)
  Line 79) getNumberOfParams() ==> com.github.javaparser.symbolsolver.javaparsermodel.declarations.JavaParserMethodDeclaration.getNumberOfParams()
  Line 109) functionalMethod.get() ==> java.util.Optional.get()
  Line 113) lambdaType.isReferenceType() ==> com.github.javaparser.symbolsolver.model.typesystem.Type.isReferenceType()
  Line 81) wrappedNode.getParameters().get(i) ==> com.github.javaparser.ast.NodeList.get(int)
  Line 114) lambdaType.asReferenceType().getTypeParametersMap() ==> com.github.javaparser.symbolsolver.model.typesystem.ReferenceType.getTypeParametersMap()
  Line 114) lambdaType.asReferenceType() ==> com.github.javaparser.symbolsolver.model.typesystem.Type.asReferenceType()
  Line 81) wrappedNode.getParameters() ==> com.github.javaparser.ast.body.CallableDeclaration.getParameters()
  Line 89) new MethodDeclarationCommonLogic(this, typeSolver).resolveTypeVariables(context, parameterTypes) ==> com.github.javaparser.symbolsolver.declarations.common.MethodDeclarationCommonLogic.resolveTypeVariables(com.github.javaparser.symbolsolver.core.resolution.Context, java.util.List<com.github.javaparser.symbolsolver.model.typesystem.Type>)
  Line 115) entry._2.isTypeVariable() ==> com.github.javaparser.symbolsolver.model.typesystem.Type.isTypeVariable()
  Line 115) entry._2.asTypeParameter().declaredOnType() ==> com.github.javaparser.symbolsolver.model.declarations.TypeParameterDeclaration.declaredOnType()
  Line 115) entry._2.asTypeParameter() ==> com.github.javaparser.symbolsolver.model.typesystem.Type.asTypeParameter()
  Line 116) t.asReferenceType().typeParametersMap().getValue(entry._1) ==> com.github.javaparser.symbolsolver.model.typesystem.parametrization.TypeParametersMap.getValue(com.github.javaparser.symbolsolver.model.declarations.TypeParameterDeclaration)
  Line 116) t.asReferenceType().typeParametersMap() ==> com.github.javaparser.symbolsolver.model.typesystem.ReferenceType.typeParametersMap()
  Line 116) t.asReferenceType() ==> com.github.javaparser.symbolsolver.model.typesystem.Type.asReferenceType()
  Line 519) getTypeDeclaration((ClassOrInterfaceDeclaration) node) ==> com.github.javaparser.symbolsolver.javaparsermodel.JavaParserFacade.getTypeDeclaration(com.github.javaparser.ast.body.ClassOrInterfaceDeclaration)
  Line 117) lambdaType.replaceTypeVariables(entry._1, ot, inferredTypes) ==> com.github.javaparser.symbolsolver.model.typesystem.Type.replaceTypeVariables(com.github.javaparser.symbolsolver.model.declarations.TypeParameterDeclaration, com.github.javaparser.symbolsolver.model.typesystem.Type, java.util.Map<com.github.javaparser.symbolsolver.model.declarations.TypeParameterDeclaration, com.github.javaparser.symbolsolver.model.typesystem.Type>)
  Line 120) lambdaType.isTypeVariable() ==> com.github.javaparser.symbolsolver.model.typesystem.Type.isTypeVariable()
  Line 120) lambdaType.asTypeParameter().declaredOnType() ==> com.github.javaparser.symbolsolver.model.declarations.TypeParameterDeclaration.declaredOnType()
  Line 120) lambdaType.asTypeParameter() ==> com.github.javaparser.symbolsolver.model.typesystem.Type.asTypeParameter()
  Line 524) getTypeOfThisIn(getParentNode(node)) ==> com.github.javaparser.symbolsolver.javaparsermodel.JavaParserFacade.getTypeOfThisIn(com.github.javaparser.ast.Node)
  Line 121) t.asReferenceType().typeParametersMap().getValue(lambdaType.asTypeParameter()) ==> com.github.javaparser.symbolsolver.model.typesystem.parametrization.TypeParametersMap.getValue(com.github.javaparser.symbolsolver.model.declarations.TypeParameterDeclaration)
  Line 121) t.asReferenceType().typeParametersMap() ==> com.github.javaparser.symbolsolver.model.typesystem.ReferenceType.typeParametersMap()
  Line 121) t.asReferenceType() ==> com.github.javaparser.symbolsolver.model.typesystem.Type.asReferenceType()
  Line 121) lambdaType.asTypeParameter() ==> com.github.javaparser.symbolsolver.model.typesystem.Type.asTypeParameter()
  Line 125) Optional.of(value) ==> java.util.Optional.of(T)
  Line 138) getParent().solveSymbolAsValue(name, typeSolver) ==> com.github.javaparser.symbolsolver.core.resolution.Context.solveSymbolAsValue(java.lang.String, com.github.javaparser.symbolsolver.model.resolution.TypeSolver)
  Line 138) getParent() ==> com.github.javaparser.symbolsolver.javaparsermodel.contexts.AbstractJavaParserContext.getParent()
  Line 143) wrappedNode.getParameters() ==> com.github.javaparser.ast.expr.LambdaExpr.getParameters()
  Line 93) JavaParserFactory.getContext(wrappedNode, typeSolver) ==> com.github.javaparser.symbolsolver.javaparsermodel.JavaParserFactory.getContext(com.github.javaparser.ast.Node, com.github.javaparser.symbolsolver.model.resolution.TypeSolver)
  Line 98) wrappedNode.getBody().isPresent() ==> java.util.Optional.isPresent()
  Line 524) getParentNode(node) ==> com.github.javaparser.symbolsolver.javaparser.Navigator.getParentNode(com.github.javaparser.ast.Node)
  Line 98) wrappedNode.getBody() ==> com.github.javaparser.ast.body.MethodDeclaration.getBody()
  Line 144) JavaParserFactory.getSymbolDeclarator(parameter, typeSolver) ==> com.github.javaparser.symbolsolver.javaparsermodel.JavaParserFactory.getSymbolDeclarator(com.github.javaparser.ast.Node, com.github.javaparser.symbolsolver.model.resolution.TypeSolver)
  Line 145) solveWith(sb, name) ==> com.github.javaparser.symbolsolver.javaparsermodel.contexts.AbstractJavaParserContext.solveWith(com.github.javaparser.symbolsolver.resolution.SymbolDeclarator, java.lang.String)
  Line 146) symbolReference.isSolved() ==> com.github.javaparser.symbolsolver.model.resolution.SymbolReference.isSolved()
  Line 152) getParent().solveSymbol(name, typeSolver) ==> com.github.javaparser.symbolsolver.core.resolution.Context.solveSymbol(java.lang.String, com.github.javaparser.symbolsolver.model.resolution.TypeSolver)
  Line 152) getParent() ==> com.github.javaparser.symbolsolver.javaparsermodel.contexts.AbstractJavaParserContext.getParent()
  Line 157) getParent().solveType(name, typeSolver) ==> com.github.javaparser.symbolsolver.core.resolution.Context.solveType(java.lang.String, com.github.javaparser.symbolsolver.model.resolution.TypeSolver)
  Line 157) getParent() ==> com.github.javaparser.symbolsolver.javaparsermodel.contexts.AbstractJavaParserContext.getParent()
  Line 103) wrappedNode.getName().getId() ==> com.github.javaparser.ast.nodeTypes.NodeWithIdentifier.getId()
  Line 103) wrappedNode.getName() ==> com.github.javaparser.ast.body.CallableDeclaration.getName()
  Line 163) getParent().solveMethod(name, argumentsTypes, false, typeSolver) ==> com.github.javaparser.symbolsolver.core.resolution.Context.solveMethod(java.lang.String, java.util.List<com.github.javaparser.symbolsolver.model.typesystem.Type>, boolean, com.github.javaparser.symbolsolver.model.resolution.TypeSolver)
  Line 163) getParent() ==> com.github.javaparser.symbolsolver.javaparsermodel.contexts.AbstractJavaParserContext.getParent()
  Line 171) symbolDeclarator.getSymbolDeclarations() ==> com.github.javaparser.symbolsolver.resolution.SymbolDeclarator.getSymbolDeclarations()
  Line 172) decl.getName().equals(name) ==> java.lang.String.equals(java.lang.Object)
  Line 123) this.wrappedNode.getTypeParameters().stream().map((astTp) -> new JavaParserTypeParameter(astTp, typeSolver)).collect(Collectors.toList()) ==> ERROR
  Line 172) decl.getName() ==> com.github.javaparser.symbolsolver.model.declarations.Declaration.getName()
  Line 177) Optional.empty() ==> java.util.Optional.empty()
  Line 123) this.wrappedNode.getTypeParameters().stream().map((astTp) -> new JavaParserTypeParameter(astTp, typeSolver)) ==> ERROR
  Line 123) this.wrappedNode.getTypeParameters().stream() ==> java.util.Collection.stream()
  Line 123) this.wrappedNode.getTypeParameters() ==> com.github.javaparser.ast.body.CallableDeclaration.getTypeParameters()
  Line 123) Collectors.toList() ==> java.util.stream.Collectors.toList()
  Line 186) callExpr.getArguments() ==> com.github.javaparser.ast.expr.MethodCallExpr.getArguments()
