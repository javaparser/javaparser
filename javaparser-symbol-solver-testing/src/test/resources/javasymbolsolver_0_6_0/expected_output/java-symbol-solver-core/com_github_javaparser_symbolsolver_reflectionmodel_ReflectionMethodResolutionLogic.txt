  Line 160) ((JavaParserInterfaceDeclaration) typeDeclaration).solveType(name, typeSolver) ==> com.github.javaparser.symbolsolver.javaparsermodel.declarations.JavaParserInterfaceDeclaration.solveType(java.lang.String, com.github.javaparser.symbolsolver.model.resolution.TypeSolver)
  Line 162) SymbolReference.unsolved(ReferenceTypeDeclaration.class) ==> com.github.javaparser.symbolsolver.model.resolution.SymbolReference.unsolved(java.lang.Class<S2>)
  Line 85) ref.isPresent() ==> java.util.Optional.isPresent()
  Line 93) Optional.empty() ==> java.util.Optional.empty()
  Line 98) signature.contains("<") ==> java.lang.String.contains(java.lang.CharSequence)
  Line 99) signature.substring(signature.indexOf('<') + 1) ==> java.lang.String.substring(int)
  Line 99) signature.indexOf('<') ==> java.lang.String.indexOf(int)
  Line 100) signature.endsWith(">") ==> java.lang.String.endsWith(java.lang.String)
  Line 103) signature.substring(0, signature.length() - 1) ==> java.lang.String.substring(int, int)
  Line 103) signature.length() ==> java.lang.String.length()
  Line 308) this.wrappedNode.getTypeParameters().stream().map((tp) -> new JavaParserTypeParameter(tp, typeSolver)) ==> ERROR
  Line 308) this.wrappedNode.getTypeParameters().stream() ==> java.util.Collection.stream()
  Line 308) this.wrappedNode.getTypeParameters() ==> com.github.javaparser.ast.body.ClassOrInterfaceDeclaration.getTypeParameters()
  Line 310) Collectors.toList() ==> java.util.stream.Collectors.toList()
  Line 104) signature.contains(",") ==> java.lang.String.contains(java.lang.CharSequence)
  Line 324) Helper.toAccessLevel(wrappedNode.getModifiers()) ==> com.github.javaparser.symbolsolver.javaparsermodel.declarations.Helper.toAccessLevel(java.util.EnumSet<com.github.javaparser.ast.Modifier>)
  Line 107) signature.contains("<") ==> java.lang.String.contains(java.lang.CharSequence)
  Line 110) signature.contains(">") ==> java.lang.String.contains(java.lang.CharSequence)
  Line 49) Modifier.isStatic(m.getModifiers()) ==> java.lang.reflect.Modifier.isStatic(int)
  Line 49) m.getModifiers() ==> java.lang.reflect.Method.getModifiers()
  Line 50) clazz.getMethods() ==> java.lang.Class.getMethods()
  Line 51) method.isBridge() ==> java.lang.reflect.Method.isBridge()
  Line 324) wrappedNode.getModifiers() ==> com.github.javaparser.ast.body.TypeDeclaration.getModifiers()
  Line 333) typeSolver.solveType(Object.class.getCanonicalName()) ==> com.github.javaparser.symbolsolver.model.resolution.TypeSolver.solveType(java.lang.String)
  Line 114) types.add(new SymbolSolver(typeSolver).solveTypeUsage(signature, invokationContext)) ==> java.util.List.add(E)
  Line 333) Object.class.getCanonicalName() ==> java.lang.Class.getCanonicalName()
  Line 114) new SymbolSolver(typeSolver).solveTypeUsage(signature, invokationContext) ==> com.github.javaparser.symbolsolver.resolution.SymbolSolver.solveTypeUsage(java.lang.String, com.github.javaparser.symbolsolver.core.resolution.Context)
  Line 117) Collections.emptyList() ==> java.util.Collections.emptyList()
  Line 51) method.isSynthetic() ==> java.lang.reflect.Method.isSynthetic()
  Line 51) method.getName().equals(name) ==> java.lang.String.equals(java.lang.Object)
  Line 51) method.getName() ==> java.lang.reflect.Method.getName()
  Line 51) staticOnlyCheck.test(method) ==> java.util.function.Predicate.test(T)
  Line 124) classType.getTypeArguments() ==> javassist.bytecode.SignatureAttribute.ClassType.getTypeArguments()
  Line 124) Collections.emptyList() ==> java.util.Collections.emptyList()
  Line 53) methods.add(methodDeclaration) ==> java.util.List.add(E)
  Line 56) scopeType.getAncestors() ==> com.github.javaparser.symbolsolver.model.declarations.ReferenceTypeDeclaration.getAncestors()
  Line 339) this.wrappedNode.getMembers() ==> com.github.javaparser.ast.body.TypeDeclaration.getMembers()
  Line 57) MethodResolutionLogic.solveMethodInType(ancestor.getTypeDeclaration(), name, parameterTypes, staticOnly, typeSolver) ==> com.github.javaparser.symbolsolver.resolution.MethodResolutionLogic.solveMethodInType(com.github.javaparser.symbolsolver.model.declarations.TypeDeclaration, java.lang.String, java.util.List<com.github.javaparser.symbolsolver.model.typesystem.Type>, boolean, com.github.javaparser.symbolsolver.model.resolution.TypeSolver)
  Line 57) ancestor.getTypeDeclaration() ==> com.github.javaparser.symbolsolver.model.typesystem.ReferenceType.getTypeDeclaration()
  Line 58) ref.isSolved() ==> com.github.javaparser.symbolsolver.model.resolution.SymbolReference.isSolved()
  Line 59) methods.add(ref.getCorrespondingDeclaration()) ==> java.util.List.add(E)
  Line 124) Arrays.stream(classType.getTypeArguments()).map(ta -> typeArgumentToType(ta, typeSolver, typeParametrizable)).collect(Collectors.toList()) ==> java.util.stream.Stream.collect(java.util.stream.Collector<? super T, A, R>)
  Line 59) ref.getCorrespondingDeclaration() ==> com.github.javaparser.symbolsolver.model.resolution.SymbolReference.getCorrespondingDeclaration()
  Line 124) Arrays.stream(classType.getTypeArguments()).map(ta -> typeArgumentToType(ta, typeSolver, typeParametrizable)) ==> java.util.stream.Stream.map(java.util.function.Function<? super T, ? extends R>)
  Line 124) Arrays.stream(classType.getTypeArguments()) ==> java.util.Arrays.stream(T[])
  Line 63) scopeType.getAncestors().isEmpty() ==> java.util.List.isEmpty()
  Line 124) classType.getTypeArguments() ==> javassist.bytecode.SignatureAttribute.ClassType.getTypeArguments()
  Line 63) scopeType.getAncestors() ==> com.github.javaparser.symbolsolver.model.declarations.ReferenceTypeDeclaration.getAncestors()
  Line 124) typeArgumentToType(ta, typeSolver, typeParametrizable) ==> com.github.javaparser.symbolsolver.javassistmodel.JavassistUtils.typeArgumentToType(javassist.bytecode.SignatureAttribute.TypeArgument, com.github.javaparser.symbolsolver.model.resolution.TypeSolver, com.github.javaparser.symbolsolver.model.declarations.TypeParametrizable)
  Line 124) Collectors.toList() ==> java.util.stream.Collectors.toList()
  Line 126) classType.getDeclaringClass() ==> javassist.bytecode.SignatureAttribute.ClassType.getDeclaringClass()
  Line 127) classType.getDeclaringClass().getName() ==> javassist.bytecode.SignatureAttribute.ClassType.getName()
  Line 127) classType.getDeclaringClass() ==> javassist.bytecode.SignatureAttribute.ClassType.getDeclaringClass()
  Line 127) classType.getName() ==> javassist.bytecode.SignatureAttribute.ClassType.getName()
  Line 128) classType.getName() ==> javassist.bytecode.SignatureAttribute.ClassType.getName()
  Line 129) typeSolver.solveType(internalNameToCanonicalName(typeName)) ==> com.github.javaparser.symbolsolver.model.resolution.TypeSolver.solveType(java.lang.String)
  Line 130) internalNameToCanonicalName(typeName) ==> com.github.javaparser.symbolsolver.javassistmodel.JavassistUtils.internalNameToCanonicalName(java.lang.String)
  Line 65) MethodResolutionLogic.solveMethodInType(objectClass.getTypeDeclaration(), name, parameterTypes, staticOnly, typeSolver) ==> com.github.javaparser.symbolsolver.resolution.MethodResolutionLogic.solveMethodInType(com.github.javaparser.symbolsolver.model.declarations.TypeDeclaration, java.lang.String, java.util.List<com.github.javaparser.symbolsolver.model.typesystem.Type>, boolean, com.github.javaparser.symbolsolver.model.resolution.TypeSolver)
  Line 65) objectClass.getTypeDeclaration() ==> com.github.javaparser.symbolsolver.model.typesystem.ReferenceType.getTypeDeclaration()
  Line 66) ref.isSolved() ==> com.github.javaparser.symbolsolver.model.resolution.SymbolReference.isSolved()
  Line 134) typeParametrizable.findTypeParameter(typeVariableSignature.getName()) ==> com.github.javaparser.symbolsolver.model.declarations.TypeParametrizable.findTypeParameter(java.lang.String)
  Line 134) typeVariableSignature.getName() ==> javassist.bytecode.SignatureAttribute.TypeVariable.getName()
  Line 135) typeParameterDeclarationOpt.isPresent() ==> java.util.Optional.isPresent()
  Line 138) typeParameterDeclarationOpt.get() ==> java.util.Optional.get()
  Line 67) methods.add(ref.getCorrespondingDeclaration()) ==> java.util.List.add(E)
  Line 67) ref.getCorrespondingDeclaration() ==> com.github.javaparser.symbolsolver.model.resolution.SymbolReference.getCorrespondingDeclaration()
  Line 141) signatureType.getClass().getCanonicalName() ==> java.lang.Class.getCanonicalName()
  Line 141) signatureType.getClass() ==> java.lang.Object.getClass()
  Line 146) typeName.replaceAll("\\$", ".") ==> java.lang.String.replaceAll(java.lang.String, java.lang.String)
  Line 70) MethodResolutionLogic.findMostApplicable(methods, name, parameterTypes, typeSolver) ==> com.github.javaparser.symbolsolver.resolution.MethodResolutionLogic.findMostApplicable(java.util.List<com.github.javaparser.symbolsolver.model.declarations.MethodDeclaration>, java.lang.String, java.util.List<com.github.javaparser.symbolsolver.model.typesystem.Type>, com.github.javaparser.symbolsolver.model.resolution.TypeSolver)
  Line 76) typeParameterValues.size() ==> java.util.List.size()
  Line 76) scopeType.getTypeParameters().size() ==> java.util.List.size()
  Line 150) typeArgument.jvmTypeName() ==> javassist.bytecode.SignatureAttribute.Type.jvmTypeName()
  Line 76) scopeType.getTypeParameters() ==> com.github.javaparser.symbolsolver.model.declarations.TypeParametrizable.getTypeParameters()
  Line 78) scopeType.getTypeParameters().isEmpty() ==> java.util.List.isEmpty()
  Line 151) getGenericParameterByName(typeName, typeParametrizable) ==> com.github.javaparser.symbolsolver.javassistmodel.JavassistUtils.getGenericParameterByName(java.lang.String, com.github.javaparser.symbolsolver.model.declarations.TypeParametrizable)
  Line 152) type.orElseGet(() -> new ReferenceTypeImpl(typeSolver.solveType(internalNameToCanonicalName(typeName)), typeSolver)) ==> java.util.Optional.orElseGet(java.util.function.Supplier<? extends T>)
  Line 78) scopeType.getTypeParameters() ==> com.github.javaparser.symbolsolver.model.declarations.TypeParametrizable.getTypeParameters()
  Line 81) scopeType.getTypeParameters().size() ==> java.util.List.size()
  Line 81) scopeType.getTypeParameters() ==> com.github.javaparser.symbolsolver.model.declarations.TypeParametrizable.getTypeParameters()
  Line 82) typeParameterValues.add(new ReferenceTypeImpl(new ReflectionClassDeclaration(Object.class, typeSolver), typeSolver)) ==> java.util.List.add(E)
  Line 87) clazz.getMethods() ==> java.lang.Class.getMethods()
  Line 88) method.getName().equals(name) ==> java.lang.String.equals(java.lang.Object)
  Line 88) method.getName() ==> java.lang.reflect.Method.getName()
  Line 88) method.isBridge() ==> java.lang.reflect.Method.isBridge()
  Line 88) method.isSynthetic() ==> java.lang.reflect.Method.isSynthetic()
  Line 153) typeSolver.solveType(internalNameToCanonicalName(typeName)) ==> com.github.javaparser.symbolsolver.model.resolution.TypeSolver.solveType(java.lang.String)
  Line 153) internalNameToCanonicalName(typeName) ==> com.github.javaparser.symbolsolver.javassistmodel.JavassistUtils.internalNameToCanonicalName(java.lang.String)
  Line 158) typeParametrizable.findTypeParameter(typeName) ==> com.github.javaparser.symbolsolver.model.declarations.TypeParametrizable.findTypeParameter(java.lang.String)
  Line 90) replaceParams(typeParameterValues, scopeType, methodDeclaration) ==> com.github.javaparser.symbolsolver.reflectionmodel.ReflectionMethodResolutionLogic.replaceParams(java.util.List<com.github.javaparser.symbolsolver.model.typesystem.Type>, com.github.javaparser.symbolsolver.model.declarations.ReferenceTypeDeclaration, com.github.javaparser.symbolsolver.model.declarations.MethodDeclaration)
  Line 91) methods.add(methodUsage) ==> java.util.List.add(E)
  Line 159) tp.map(TypeVariable::new) ==> java.util.Optional.map(java.util.function.Function<? super T, ? extends U>)
  Line 96) scopeType.getAncestors() ==> com.github.javaparser.symbolsolver.model.declarations.ReferenceTypeDeclaration.getAncestors()
  Line 163) typeArgument.isWildcard() ==> javassist.bytecode.SignatureAttribute.TypeArgument.isWildcard()
  Line 164) typeArgument.getType() ==> javassist.bytecode.SignatureAttribute.TypeArgument.getType()
  Line 166) typeArgument.getKind() ==> javassist.bytecode.SignatureAttribute.TypeArgument.getKind()
  Line 97) MethodResolutionLogic.solveMethodInType(ancestor.getTypeDeclaration(), name, argumentsTypes, typeSolver) ==> com.github.javaparser.symbolsolver.resolution.MethodResolutionLogic.solveMethodInType(com.github.javaparser.symbolsolver.model.declarations.TypeDeclaration, java.lang.String, java.util.List<com.github.javaparser.symbolsolver.model.typesystem.Type>, com.github.javaparser.symbolsolver.model.resolution.TypeSolver)
  Line 97) ancestor.getTypeDeclaration() ==> com.github.javaparser.symbolsolver.model.typesystem.ReferenceType.getTypeDeclaration()
  Line 98) ref.isSolved() ==> com.github.javaparser.symbolsolver.model.resolution.SymbolReference.isSolved()
  Line 99) ref.getCorrespondingDeclaration() ==> com.github.javaparser.symbolsolver.model.resolution.SymbolReference.getCorrespondingDeclaration()
  Line 167) Wildcard.extendsBound(objectTypeArgumentToType(typeArgument.getType(), typeSolver, typeParametrizable)) ==> com.github.javaparser.symbolsolver.model.typesystem.Wildcard.extendsBound(com.github.javaparser.symbolsolver.model.typesystem.Type)
  Line 167) objectTypeArgumentToType(typeArgument.getType(), typeSolver, typeParametrizable) ==> com.github.javaparser.symbolsolver.javassistmodel.JavassistUtils.objectTypeArgumentToType(javassist.bytecode.SignatureAttribute.ObjectType, com.github.javaparser.symbolsolver.model.resolution.TypeSolver, com.github.javaparser.symbolsolver.model.declarations.TypeParametrizable)
  Line 167) typeArgument.getType() ==> javassist.bytecode.SignatureAttribute.TypeArgument.getType()
  Line 168) typeArgument.getKind() ==> javassist.bytecode.SignatureAttribute.TypeArgument.getKind()
  Line 100) replaceParams(typeParameterValues, ancestor.getTypeDeclaration(), correspondingDeclaration) ==> com.github.javaparser.symbolsolver.reflectionmodel.ReflectionMethodResolutionLogic.replaceParams(java.util.List<com.github.javaparser.symbolsolver.model.typesystem.Type>, com.github.javaparser.symbolsolver.model.declarations.ReferenceTypeDeclaration, com.github.javaparser.symbolsolver.model.declarations.MethodDeclaration)
  Line 100) ancestor.getTypeDeclaration() ==> com.github.javaparser.symbolsolver.model.typesystem.ReferenceType.getTypeDeclaration()
  Line 101) methods.add(methodUsage) ==> java.util.List.add(E)
  Line 169) Wildcard.superBound(objectTypeArgumentToType(typeArgument.getType(), typeSolver, typeParametrizable)) ==> com.github.javaparser.symbolsolver.model.typesystem.Wildcard.superBound(com.github.javaparser.symbolsolver.model.typesystem.Type)
  Line 169) objectTypeArgumentToType(typeArgument.getType(), typeSolver, typeParametrizable) ==> com.github.javaparser.symbolsolver.javassistmodel.JavassistUtils.objectTypeArgumentToType(javassist.bytecode.SignatureAttribute.ObjectType, com.github.javaparser.symbolsolver.model.resolution.TypeSolver, com.github.javaparser.symbolsolver.model.declarations.TypeParametrizable)
  Line 169) typeArgument.getType() ==> javassist.bytecode.SignatureAttribute.TypeArgument.getType()
  Line 174) objectTypeArgumentToType(typeArgument.getType(), typeSolver, typeParametrizable) ==> com.github.javaparser.symbolsolver.javassistmodel.JavassistUtils.objectTypeArgumentToType(javassist.bytecode.SignatureAttribute.ObjectType, com.github.javaparser.symbolsolver.model.resolution.TypeSolver, com.github.javaparser.symbolsolver.model.declarations.TypeParametrizable)
  Line 174) typeArgument.getType() ==> javassist.bytecode.SignatureAttribute.TypeArgument.getType()
  Line 105) scopeType.getAncestors().isEmpty() ==> java.util.List.isEmpty()
  Line 105) scopeType.getAncestors() ==> com.github.javaparser.symbolsolver.model.declarations.ReferenceTypeDeclaration.getAncestors()
  Line 107) MethodResolutionLogic.solveMethodInType(objectClass.getTypeDeclaration(), name, argumentsTypes, typeSolver) ==> com.github.javaparser.symbolsolver.resolution.MethodResolutionLogic.solveMethodInType(com.github.javaparser.symbolsolver.model.declarations.TypeDeclaration, java.lang.String, java.util.List<com.github.javaparser.symbolsolver.model.typesystem.Type>, com.github.javaparser.symbolsolver.model.resolution.TypeSolver)
  Line 107) objectClass.getTypeDeclaration() ==> com.github.javaparser.symbolsolver.model.typesystem.ReferenceType.getTypeDeclaration()
  Line 108) ref.isSolved() ==> com.github.javaparser.symbolsolver.model.resolution.SymbolReference.isSolved()
  Line 109) replaceParams(typeParameterValues, objectClass.getTypeDeclaration(), ref.getCorrespondingDeclaration()) ==> com.github.javaparser.symbolsolver.reflectionmodel.ReflectionMethodResolutionLogic.replaceParams(java.util.List<com.github.javaparser.symbolsolver.model.typesystem.Type>, com.github.javaparser.symbolsolver.model.declarations.ReferenceTypeDeclaration, com.github.javaparser.symbolsolver.model.declarations.MethodDeclaration)
  Line 109) objectClass.getTypeDeclaration() ==> com.github.javaparser.symbolsolver.model.typesystem.ReferenceType.getTypeDeclaration()
  Line 109) ref.getCorrespondingDeclaration() ==> com.github.javaparser.symbolsolver.model.resolution.SymbolReference.getCorrespondingDeclaration()
  Line 110) methods.add(usage) ==> java.util.List.add(E)
  Line 341) res.add(JavaParserFacade.get(typeSolver).getTypeDeclaration((com.github.javaparser.ast.body.TypeDeclaration) member)) ==> java.util.Set.add(E)
  Line 115) argumentsTypes.stream().map((pt) -> {
    int i = 0;
    for (TypeParameterDeclaration tp : scopeType.getTypeParameters()) {
        pt = pt.replaceTypeVariables(tp, finalTypeParameterValues.get(i));
        i++;
    }
    return pt;
}).collect(Collectors.toList()) ==> java.util.stream.Stream.collect(java.util.stream.Collector<? super T, A, R>)
  Line 115) argumentsTypes.stream().map((pt) -> {
    int i = 0;
    for (TypeParameterDeclaration tp : scopeType.getTypeParameters()) {
        pt = pt.replaceTypeVariables(tp, finalTypeParameterValues.get(i));
        i++;
    }
    return pt;
}) ==> java.util.stream.Stream.map(java.util.function.Function<? super T, ? extends R>)
  Line 115) argumentsTypes.stream() ==> java.util.Collection.stream()
  Line 117) scopeType.getTypeParameters() ==> com.github.javaparser.symbolsolver.model.declarations.TypeParametrizable.getTypeParameters()
  Line 118) pt.replaceTypeVariables(tp, finalTypeParameterValues.get(i)) ==> com.github.javaparser.symbolsolver.model.typesystem.Type.replaceTypeVariables(com.github.javaparser.symbolsolver.model.declarations.TypeParameterDeclaration, com.github.javaparser.symbolsolver.model.typesystem.Type)
  Line 118) finalTypeParameterValues.get(i) ==> java.util.List.get(int)
  Line 122) Collectors.toList() ==> java.util.stream.Collectors.toList()
  Line 123) MethodResolutionLogic.findMostApplicableUsage(methods, name, argumentsTypes, typeSolver) ==> com.github.javaparser.symbolsolver.resolution.MethodResolutionLogic.findMostApplicableUsage(java.util.List<com.github.javaparser.symbolsolver.model.methods.MethodUsage>, java.lang.String, java.util.List<com.github.javaparser.symbolsolver.model.typesystem.Type>, com.github.javaparser.symbolsolver.model.resolution.TypeSolver)
  Line 131) typeParameterValues.size() ==> java.util.List.size()
  Line 131) typeParametrizable.getTypeParameters().size() ==> java.util.List.size()
  Line 131) typeParametrizable.getTypeParameters() ==> com.github.javaparser.symbolsolver.model.declarations.TypeParametrizable.getTypeParameters()
  Line 132) typeParametrizable.getTypeParameters() ==> com.github.javaparser.symbolsolver.model.declarations.TypeParametrizable.getTypeParameters()
  Line 133) methodUsage.replaceTypeParameter(tp, typeParameterValues.get(i)) ==> com.github.javaparser.symbolsolver.model.methods.MethodUsage.replaceTypeParameter(com.github.javaparser.symbolsolver.model.declarations.TypeParameterDeclaration, com.github.javaparser.symbolsolver.model.typesystem.Type)
  Line 133) typeParameterValues.get(i) ==> java.util.List.get(int)
  Line 138) methodDeclaration.getTypeParameters() ==> com.github.javaparser.symbolsolver.model.declarations.TypeParametrizable.getTypeParameters()
  Line 139) methodUsage.replaceTypeParameter(methodTypeParameter, new TypeVariable(methodTypeParameter)) ==> com.github.javaparser.symbolsolver.model.methods.MethodUsage.replaceTypeParameter(com.github.javaparser.symbolsolver.model.declarations.TypeParameterDeclaration, com.github.javaparser.symbolsolver.model.typesystem.Type)
