  Line 59) ctClass.isAnnotation() ==> javassist.CtClass.isAnnotation()
  Line 80) groupVariadicParamValues(argumentsTypes, pos, constructor.getLastParam().getType()) ==> com.github.javaparser.symbolsolver.resolution.ConstructorResolutionLogic.groupVariadicParamValues(java.util.List<com.github.javaparser.symbolsolver.model.typesystem.Type>, int, com.github.javaparser.symbolsolver.model.typesystem.Type)
  Line 81) constructor.getLastParam().getType() ==> com.github.javaparser.symbolsolver.model.declarations.ValueDeclaration.getType()
  Line 81) constructor.getLastParam() ==> com.github.javaparser.symbolsolver.model.declarations.MethodLikeDeclaration.getLastParam()
  Line 59) ctClass.isPrimitive() ==> javassist.CtClass.isPrimitive()
  Line 86) argumentsTypes.size() ==> java.util.List.size()
  Line 59) ctClass.isEnum() ==> javassist.CtClass.isEnum()
  Line 90) groupVariadicParamValues(argumentsTypes, pos, constructor.getLastParam().getType()) ==> com.github.javaparser.symbolsolver.resolution.ConstructorResolutionLogic.groupVariadicParamValues(java.util.List<com.github.javaparser.symbolsolver.model.typesystem.Type>, int, com.github.javaparser.symbolsolver.model.typesystem.Type)
  Line 90) constructor.getLastParam().getType() ==> com.github.javaparser.symbolsolver.model.declarations.ValueDeclaration.getType()
  Line 90) constructor.getLastParam() ==> com.github.javaparser.symbolsolver.model.declarations.MethodLikeDeclaration.getLastParam()
  Line 94) constructor.getNumberOfParams() ==> com.github.javaparser.symbolsolver.model.declarations.MethodLikeDeclaration.getNumberOfParams()
  Line 94) argumentsTypes.size() ==> java.util.List.size()
  Line 99) constructor.getNumberOfParams() ==> com.github.javaparser.symbolsolver.model.declarations.MethodLikeDeclaration.getNumberOfParams()
  Line 60) ctClass.toString() ==> javassist.CtClass.toString()
  Line 100) constructor.getParam(i).getType() ==> com.github.javaparser.symbolsolver.model.declarations.ValueDeclaration.getType()
  Line 100) constructor.getParam(i) ==> com.github.javaparser.symbolsolver.model.declarations.MethodLikeDeclaration.getParam(int)
  Line 101) argumentsTypes.get(i) ==> java.util.List.get(int)
  Line 102) expectedType.isTypeVariable() ==> com.github.javaparser.symbolsolver.model.typesystem.Type.isTypeVariable()
  Line 102) expectedType.isWildcard() ==> com.github.javaparser.symbolsolver.model.typesystem.Type.isWildcard()
  Line 69) typeSolver.solveType(Object.class.getCanonicalName()) ==> com.github.javaparser.symbolsolver.model.resolution.TypeSolver.solveType(java.lang.String)
  Line 69) Object.class.getCanonicalName() ==> java.lang.Class.getCanonicalName()
  Line 79) javassistTypeDeclarationAdapter.getDeclaredMethods() ==> com.github.javaparser.symbolsolver.javassistmodel.JavassistTypeDeclarationAdapter.getDeclaredMethods()
  Line 52) object() ==> com.github.javaparser.symbolsolver.logic.AbstractClassDeclaration.object()
  Line 60) getInterfaces() ==> com.github.javaparser.symbolsolver.model.declarations.ClassDeclaration.getInterfaces()
  Line 61) interfaces.add(interfaceDeclaration) ==> java.util.List.add(E)
  Line 69) e.nextElement() ==> java.util.Enumeration.nextElement()
  Line 70) entry.isDirectory() ==> java.util.zip.ZipEntry.isDirectory()
  Line 62) interfaces.addAll(interfaceDeclaration.getAllInterfacesAncestors()) ==> java.util.List.addAll(java.util.Collection<? extends E>)
  Line 62) interfaceDeclaration.getAllInterfacesAncestors() ==> com.github.javaparser.symbolsolver.model.typesystem.ReferenceType.getAllInterfacesAncestors()
  Line 42) typeDeclaration.getTypeParameters().stream().map(tp -> new TypeVariable(tp)) ==> java.util.stream.Stream.map(java.util.function.Function<? super T, ? extends R>)
  Line 42) typeDeclaration.getTypeParameters().stream() ==> java.util.Collection.stream()
  Line 64) this.getSuperClass() ==> com.github.javaparser.symbolsolver.model.declarations.ClassDeclaration.getSuperClass()
  Line 42) typeDeclaration.getTypeParameters() ==> com.github.javaparser.symbolsolver.model.declarations.TypeParametrizable.getTypeParameters()
  Line 61) Value.from(ref.getCorrespondingDeclaration()) ==> com.github.javaparser.symbolsolver.model.resolution.Value.from(com.github.javaparser.symbolsolver.model.declarations.ValueDeclaration)
  Line 61) ref.getCorrespondingDeclaration() ==> com.github.javaparser.symbolsolver.model.resolution.SymbolReference.getCorrespondingDeclaration()
  Line 62) Optional.of(value) ==> java.util.Optional.of(T)
  Line 64) Optional.empty() ==> java.util.Optional.empty()
  Line 66) interfaces.addAll(superClass.getAllInterfacesAncestors()) ==> java.util.List.addAll(java.util.Collection<? extends E>)
  Line 66) superClass.getAllInterfacesAncestors() ==> com.github.javaparser.symbolsolver.model.typesystem.ReferenceType.getAllInterfacesAncestors()
  Line 89) solveMethod(name, argumentsTypes, false, typeSolver) ==> com.github.javaparser.symbolsolver.core.resolution.Context.solveMethod(java.lang.String, java.util.List<com.github.javaparser.symbolsolver.model.typesystem.Type>, boolean, com.github.javaparser.symbolsolver.model.resolution.TypeSolver)
  Line 25) type.isTypeVariable() ==> com.github.javaparser.symbolsolver.model.typesystem.Type.isTypeVariable()
  Line 44) Collectors.toList() ==> java.util.stream.Collectors.toList()
  Line 103) expectedType.asTypeParameter().declaredOnMethod() ==> com.github.javaparser.symbolsolver.model.declarations.TypeParameterDeclaration.declaredOnMethod()
  Line 70) entry.getName().endsWith(".class") ==> java.lang.String.endsWith(java.lang.String)
  Line 84) isAssignableBy(new ReferenceTypeImpl(other, typeSolver)) ==> com.github.javaparser.symbolsolver.javassistmodel.JavassistClassDeclaration.isAssignableBy(com.github.javaparser.symbolsolver.model.typesystem.Type)
  Line 13) o1.getName().compareTo(o2.getName()) ==> java.lang.String.compareTo(java.lang.String)
