  Line 120) getSuperClass().getTypeDeclaration() ==> com.github.javaparser.symbolsolver.model.typesystem.ReferenceType.getTypeDeclaration()
  Line 120) getSuperClass() ==> com.github.javaparser.symbolsolver.javaparsermodel.declarations.JavaParserAnonymousClassDeclaration.getSuperClass()
  Line 381) Optional.of(ancestor.typeParametersMap().getValue(typeParameterDeclaration)) ==> java.util.Optional.of(T)
  Line 381) ancestor.typeParametersMap().getValue(typeParameterDeclaration) ==> com.github.javaparser.symbolsolver.model.typesystem.parametrization.TypeParametersMap.getValue(com.github.javaparser.symbolsolver.model.declarations.TypeParameterDeclaration)
  Line 381) ancestor.typeParametersMap() ==> com.github.javaparser.symbolsolver.model.typesystem.ReferenceType.typeParametersMap()
  Line 384) Optional.empty() ==> java.util.Optional.empty()
  Line 418) node.getClass() ==> java.lang.Object.getClass()
  Line 423) node.getClass().getCanonicalName() ==> java.lang.Class.getCanonicalName()
  Line 322) tp.getBounds(typeSolver) ==> com.github.javaparser.symbolsolver.model.declarations.TypeParameterDeclaration.getBounds(com.github.javaparser.symbolsolver.model.resolution.TypeSolver)
  Line 323) bound.isExtends() ==> com.github.javaparser.symbolsolver.model.declarations.TypeParameterDeclaration.Bound.isExtends()
  Line 107) typeDeclarations.stream().filter(internalType -> internalType.getName().getId().equals(name)).findFirst() ==> java.util.stream.Stream.findFirst()
  Line 107) typeDeclarations.stream().filter(internalType -> internalType.getName().getId().equals(name)) ==> java.util.stream.Stream.filter(java.util.function.Predicate<? super T>)
  Line 324) expectedType2.replaceTypeVariables(tp, bound.getType()) ==> com.github.javaparser.symbolsolver.model.typesystem.Type.replaceTypeVariables(com.github.javaparser.symbolsolver.model.declarations.TypeParameterDeclaration, com.github.javaparser.symbolsolver.model.typesystem.Type)
  Line 324) bound.getType() ==> com.github.javaparser.symbolsolver.model.declarations.TypeParameterDeclaration.Bound.getType()
  Line 423) node.getClass() ==> java.lang.Object.getClass()
  Line 33) ctClazz.isArray() ==> javassist.CtClass.isArray()
  Line 107) typeDeclarations.stream() ==> java.util.Collection.stream()
  Line 428) node.getClass().getCanonicalName() ==> java.lang.Class.getCanonicalName()
  Line 428) node.getClass() ==> java.lang.Object.getClass()
  Line 326) expectedType2.replaceTypeVariables(tp, new ReferenceTypeImpl(typeSolver.solveType(Object.class.getCanonicalName()), typeSolver)) ==> com.github.javaparser.symbolsolver.model.typesystem.Type.replaceTypeVariables(com.github.javaparser.symbolsolver.model.declarations.TypeParameterDeclaration, com.github.javaparser.symbolsolver.model.typesystem.Type)
  Line 109) internalType.getName().getId().equals(name) ==> java.lang.String.equals(java.lang.Object)
  Line 326) typeSolver.solveType(Object.class.getCanonicalName()) ==> com.github.javaparser.symbolsolver.model.resolution.TypeSolver.solveType(java.lang.String)
  Line 109) internalType.getName().getId() ==> com.github.javaparser.ast.nodeTypes.NodeWithIdentifier.getId()
  Line 109) internalType.getName() ==> com.github.javaparser.ast.body.TypeDeclaration.getName()
  Line 77) parent.getCorrespondingDeclaration().internalTypes().stream().filter(it -> it.getName().equals(childName)) ==> java.util.stream.Stream.filter(java.util.function.Predicate<? super T>)
  Line 77) parent.getCorrespondingDeclaration().internalTypes().stream() ==> java.util.Collection.stream()
  Line 77) parent.getCorrespondingDeclaration().internalTypes() ==> com.github.javaparser.symbolsolver.model.declarations.TypeDeclaration.internalTypes()
  Line 77) parent.getCorrespondingDeclaration() ==> com.github.javaparser.symbolsolver.model.resolution.SymbolReference.getCorrespondingDeclaration()
  Line 433) node.getClass().getCanonicalName() ==> java.lang.Class.getCanonicalName()
  Line 78) it.getName().equals(childName) ==> java.lang.String.equals(java.lang.Object)
  Line 78) it.getName() ==> com.github.javaparser.symbolsolver.model.declarations.Declaration.getName()
  Line 79) innerClass.isPresent() ==> java.util.Optional.isPresent()
  Line 34) typeUsageFor(ctClazz.getComponentType(), typeSolver) ==> com.github.javaparser.symbolsolver.javassistmodel.JavassistFactory.typeUsageFor(javassist.CtClass, com.github.javaparser.symbolsolver.model.resolution.TypeSolver)
  Line 34) ctClazz.getComponentType() ==> javassist.CtClass.getComponentType()
  Line 80) SymbolReference.solved(innerClass.get()) ==> com.github.javaparser.symbolsolver.model.resolution.SymbolReference.solved(S2)
  Line 80) innerClass.get() ==> java.util.Optional.get()
  Line 35) ctClazz.isPrimitive() ==> javassist.CtClass.isPrimitive()
  Line 433) node.getClass() ==> java.lang.Object.getClass()
  Line 326) Object.class.getCanonicalName() ==> java.lang.Class.getCanonicalName()
  Line 332) expectedType.isAssignableBy(actualType) ==> com.github.javaparser.symbolsolver.model.typesystem.Type.isAssignableBy(com.github.javaparser.symbolsolver.model.typesystem.Type)
  Line 333) expectedType2.isAssignableBy(actualType) ==> com.github.javaparser.symbolsolver.model.typesystem.Type.isAssignableBy(com.github.javaparser.symbolsolver.model.typesystem.Type)
  Line 329) Arrays.stream(this.clazz.getDeclaredClasses()).map(ic -> ReflectionFactory.typeDeclarationFor(ic, typeSolver)) ==> java.util.stream.Stream.map(java.util.function.Function<? super T, ? extends R>)
  Line 329) Arrays.stream(this.clazz.getDeclaredClasses()) ==> java.util.Arrays.stream(T[])
  Line 329) this.clazz.getDeclaredClasses() ==> java.lang.Class.getDeclaredClasses()
  Line 438) node.getClass().getCanonicalName() ==> java.lang.Class.getCanonicalName()
  Line 334) expectedTypeWithInference.isAssignableBy(actualType) ==> com.github.javaparser.symbolsolver.model.typesystem.Type.isAssignableBy(com.github.javaparser.symbolsolver.model.typesystem.Type)
  Line 330) ReflectionFactory.typeDeclarationFor(ic, typeSolver) ==> com.github.javaparser.symbolsolver.reflectionmodel.ReflectionFactory.typeDeclarationFor(java.lang.Class<?>, com.github.javaparser.symbolsolver.model.resolution.TypeSolver)
  Line 331) Collectors.toSet() ==> java.util.stream.Collectors.toSet()
  Line 36) ctClazz.getName().equals("void") ==> java.lang.String.equals(java.lang.Object)
  Line 82) SymbolReference.unsolved(ReferenceTypeDeclaration.class) ==> com.github.javaparser.symbolsolver.model.resolution.SymbolReference.unsolved(java.lang.Class<S2>)
  Line 36) ctClazz.getName() ==> javassist.CtClass.getName()
  Line 85) SymbolReference.unsolved(ReferenceTypeDeclaration.class) ==> com.github.javaparser.symbolsolver.model.resolution.SymbolReference.unsolved(java.lang.Class<S2>)
  Line 90) SymbolReference.unsolved(ReferenceTypeDeclaration.class) ==> com.github.javaparser.symbolsolver.model.resolution.SymbolReference.unsolved(java.lang.Class<S2>)
  Line 438) node.getClass() ==> java.lang.Object.getClass()
  Line 123) getInterfaces().stream().flatMap(inteface -> inteface.getTypeDeclaration().getAllFields().stream()).collect(Collectors.toList()) ==> java.util.stream.Stream.collect(java.util.stream.Collector<? super T, A, R>)
  Line 335) expectedTypeWithoutSubstitutions.isAssignableBy(actualType) ==> com.github.javaparser.symbolsolver.model.typesystem.Type.isAssignableBy(com.github.javaparser.symbolsolver.model.typesystem.Type)
  Line 39) PrimitiveType.byName(ctClazz.getName()) ==> com.github.javaparser.symbolsolver.model.typesystem.PrimitiveType.byName(java.lang.String)
  Line 123) getInterfaces().stream().flatMap(inteface -> inteface.getTypeDeclaration().getAllFields().stream()) ==> java.util.stream.Stream.flatMap(java.util.function.Function<? super T, ? extends java.util.stream.Stream<? extends R>>)
  Line 123) getInterfaces().stream() ==> java.util.Collection.stream()
  Line 39) ctClazz.getName() ==> javassist.CtClass.getName()
  Line 123) getInterfaces() ==> com.github.javaparser.symbolsolver.javaparsermodel.declarations.JavaParserAnonymousClassDeclaration.getInterfaces()
  Line 42) ctClazz.isInterface() ==> javassist.CtClass.isInterface()
  Line 340) typeSolver.solveType(Object.class.getCanonicalName()) ==> com.github.javaparser.symbolsolver.model.resolution.TypeSolver.solveType(java.lang.String)
  Line 340) Object.class.getCanonicalName() ==> java.lang.Class.getCanonicalName()
  Line 45) ctClazz.isEnum() ==> javassist.CtClass.isEnum()
  Line 124) inteface.getTypeDeclaration().getAllFields().stream() ==> java.util.Collection.stream()
  Line 124) inteface.getTypeDeclaration().getAllFields() ==> com.github.javaparser.symbolsolver.model.declarations.ReferenceTypeDeclaration.getAllFields()
  Line 59) ctClazz.isInterface() ==> javassist.CtClass.isInterface()
  Line 443) node.getClass().getCanonicalName() ==> java.lang.Class.getCanonicalName()
  Line 124) inteface.getTypeDeclaration() ==> com.github.javaparser.symbolsolver.model.typesystem.ReferenceType.getTypeDeclaration()
