  Line 319) tp.getBounds(typeSolver) ==> com.github.javaparser.symbolsolver.model.declarations.TypeParameterDeclaration.getBounds(com.github.javaparser.symbolsolver.model.resolution.TypeSolver)
  Line 359) typeParametersMap() ==> com.github.javaparser.symbolsolver.model.typesystem.ReferenceType.typeParametersMap()
  Line 89) res.isSolved() ==> com.github.javaparser.symbolsolver.model.resolution.SymbolReference.isSolved()
  Line 360) value.isPresent() ==> java.util.Optional.isPresent()
  Line 360) value.get().isTypeVariable() ==> com.github.javaparser.symbolsolver.model.typesystem.Type.isTypeVariable()
  Line 90) candidateMethods.add(res.getCorrespondingDeclaration()) ==> java.util.List.add(E)
  Line 90) res.getCorrespondingDeclaration() ==> com.github.javaparser.symbolsolver.model.resolution.SymbolReference.getCorrespondingDeclaration()
  Line 360) value.get() ==> java.util.Optional.get()
  Line 393) node.getClass() ==> java.lang.Object.getClass()
  Line 360) value.get().asTypeVariable().qualifiedName().equals(name) ==> java.lang.String.equals(java.lang.Object)
  Line 360) value.get().asTypeVariable().qualifiedName() ==> com.github.javaparser.symbolsolver.model.typesystem.TypeVariable.qualifiedName()
  Line 360) value.get().asTypeVariable() ==> com.github.javaparser.symbolsolver.model.typesystem.Type.asTypeVariable()
  Line 360) value.get() ==> java.util.Optional.get()
  Line 218) this.internalTypes().stream().filter(f -> f.getName().endsWith(name)) ==> java.util.stream.Stream.filter(java.util.function.Predicate<? super T>)
  Line 218) this.internalTypes().stream() ==> java.util.Collection.stream()
  Line 398) node.getClass().getCanonicalName() ==> java.lang.Class.getCanonicalName()
  Line 218) this.internalTypes() ==> com.github.javaparser.symbolsolver.javassistmodel.JavassistEnumDeclaration.internalTypes()
  Line 55) name.startsWith("java.") ==> java.lang.String.startsWith(java.lang.String)
  Line 55) name.startsWith("javax.") ==> java.lang.String.startsWith(java.lang.String)
  Line 57) ReflectionTypeSolver.class.getClassLoader() ==> java.lang.Class.getClassLoader()
  Line 398) node.getClass() ==> java.lang.Object.getClass()
  Line 65) classLoader.loadClass(name) ==> java.lang.ClassLoader.loadClass(java.lang.String)
  Line 403) node.getClass().getCanonicalName() ==> java.lang.Class.getCanonicalName()
  Line 66) SymbolReference.solved(ReflectionFactory.typeDeclarationFor(clazz, getRoot())) ==> com.github.javaparser.symbolsolver.model.resolution.SymbolReference.solved(S2)
  Line 403) node.getClass() ==> java.lang.Object.getClass()
  Line 372) typeParameterDeclaration.declaredOnMethod() ==> com.github.javaparser.symbolsolver.model.declarations.TypeParameterDeclaration.declaredOnMethod()
  Line 66) ReflectionFactory.typeDeclarationFor(clazz, getRoot()) ==> com.github.javaparser.symbolsolver.reflectionmodel.ReflectionFactory.typeDeclarationFor(java.lang.Class<?>, com.github.javaparser.symbolsolver.model.resolution.TypeSolver)
  Line 66) getRoot() ==> com.github.javaparser.symbolsolver.model.resolution.TypeSolver.getRoot()
  Line 375) this.getTypeDeclaration().getId() ==> com.github.javaparser.symbolsolver.model.declarations.TypeDeclaration.getId()
  Line 375) this.getTypeDeclaration() ==> com.github.javaparser.symbolsolver.model.typesystem.ReferenceType.getTypeDeclaration()
  Line 218) f.getName().endsWith(name) ==> java.lang.String.endsWith(java.lang.String)
  Line 69) name.lastIndexOf('.') ==> java.lang.String.lastIndexOf(int)
  Line 111) findMembersOfKind(com.github.javaparser.ast.body.FieldDeclaration.class).stream().flatMap(field -> field.getVariables().stream().map(variable -> new JavaParserFieldDeclaration(variable, typeSolver))) ==> java.util.stream.Stream.flatMap(java.util.function.Function<? super T, ? extends java.util.stream.Stream<? extends R>>)
  Line 111) findMembersOfKind(com.github.javaparser.ast.body.FieldDeclaration.class).stream() ==> java.util.Collection.stream()
  Line 71) SymbolReference.unsolved(ReferenceTypeDeclaration.class) ==> com.github.javaparser.symbolsolver.model.resolution.SymbolReference.unsolved(java.lang.Class<S2>)
  Line 73) name.substring(0, lastDot) ==> java.lang.String.substring(int, int)
  Line 111) findMembersOfKind(com.github.javaparser.ast.body.FieldDeclaration.class) ==> com.github.javaparser.symbolsolver.javaparsermodel.declarations.JavaParserAnonymousClassDeclaration.findMembersOfKind(java.lang.Class<T>)
  Line 74) name.substring(lastDot + 1) ==> java.lang.String.substring(int)
  Line 320) expectedType2.replaceTypeVariables(tp, new ReferenceTypeImpl(typeSolver.solveType(Object.class.getCanonicalName()), typeSolver)) ==> com.github.javaparser.symbolsolver.model.typesystem.Type.replaceTypeVariables(com.github.javaparser.symbolsolver.model.declarations.TypeParameterDeclaration, com.github.javaparser.symbolsolver.model.typesystem.Type)
  Line 94) MethodResolutionLogic.findMostApplicable(candidateMethods, name, argumentsTypes, typeSolver) ==> com.github.javaparser.symbolsolver.resolution.MethodResolutionLogic.findMostApplicable(java.util.List<com.github.javaparser.symbolsolver.model.declarations.MethodDeclaration>, java.lang.String, java.util.List<com.github.javaparser.symbolsolver.model.typesystem.Type>, com.github.javaparser.symbolsolver.model.resolution.TypeSolver)
  Line 408) node.getClass().getCanonicalName() ==> java.lang.Class.getCanonicalName()
  Line 408) node.getClass() ==> java.lang.Object.getClass()
  Line 218) f.getName() ==> com.github.javaparser.symbolsolver.model.declarations.Declaration.getName()
  Line 219) type.orElseThrow(() -> new UnsolvedSymbolException("Internal type not found: " + name)) ==> java.util.Optional.orElseThrow(java.util.function.Supplier<? extends X>)
  Line 103) myDeclaration.findMembersOfKind(com.github.javaparser.ast.body.TypeDeclaration.class) ==> com.github.javaparser.symbolsolver.javaparsermodel.declarations.JavaParserAnonymousClassDeclaration.findMembersOfKind(java.lang.Class<T>)
  Line 376) typeId.equals(typeParameterDeclaration.getContainerId()) ==> java.lang.String.equals(java.lang.Object)
  Line 229) this.internalTypes().stream().anyMatch(f -> f.getName().endsWith(name)) ==> java.util.stream.Stream.anyMatch(java.util.function.Predicate<? super T>)
  Line 229) this.internalTypes().stream() ==> java.util.Collection.stream()
  Line 376) typeParameterDeclaration.getContainerId() ==> com.github.javaparser.symbolsolver.model.declarations.TypeParameterDeclaration.getContainerId()
  Line 320) typeSolver.solveType(Object.class.getCanonicalName()) ==> com.github.javaparser.symbolsolver.model.resolution.TypeSolver.solveType(java.lang.String)
  Line 320) Object.class.getCanonicalName() ==> java.lang.Class.getCanonicalName()
  Line 229) this.internalTypes() ==> com.github.javaparser.symbolsolver.javassistmodel.JavassistEnumDeclaration.internalTypes()
  Line 377) Optional.of(this.typeParametersMap().getValue(typeParameterDeclaration)) ==> java.util.Optional.of(T)
  Line 75) tryToSolveType(parentName) ==> com.github.javaparser.symbolsolver.resolution.typesolvers.ReflectionTypeSolver.tryToSolveType(java.lang.String)
  Line 377) this.typeParametersMap().getValue(typeParameterDeclaration) ==> com.github.javaparser.symbolsolver.model.typesystem.parametrization.TypeParametersMap.getValue(com.github.javaparser.symbolsolver.model.declarations.TypeParameterDeclaration)
  Line 377) this.typeParametersMap() ==> com.github.javaparser.symbolsolver.model.typesystem.ReferenceType.typeParametersMap()
  Line 379) this.getAllAncestors() ==> com.github.javaparser.symbolsolver.model.typesystem.ReferenceType.getAllAncestors()
  Line 380) ancestor.getId().equals(typeParameterDeclaration.getContainerId()) ==> java.lang.String.equals(java.lang.Object)
  Line 321) tp.getBounds(typeSolver).size() ==> java.util.List.size()
  Line 76) parent.isSolved() ==> com.github.javaparser.symbolsolver.model.resolution.SymbolReference.isSolved()
  Line 321) tp.getBounds(typeSolver) ==> com.github.javaparser.symbolsolver.model.declarations.TypeParameterDeclaration.getBounds(com.github.javaparser.symbolsolver.model.resolution.TypeSolver)
  Line 114) field.getVariables().stream().map(variable -> new JavaParserFieldDeclaration(variable, typeSolver)) ==> ERROR
  Line 229) f.getName().endsWith(name) ==> java.lang.String.endsWith(java.lang.String)
  Line 413) node.getClass().getCanonicalName() ==> java.lang.Class.getCanonicalName()
  Line 229) f.getName() ==> com.github.javaparser.symbolsolver.model.declarations.Declaration.getName()
  Line 114) field.getVariables().stream() ==> ERROR
  Line 413) node.getClass() ==> java.lang.Object.getClass()
  Line 114) field.getVariables() ==> com.github.javaparser.ast.body.FieldDeclaration.getVariables()
  Line 117) Collectors.toList() ==> java.util.stream.Collectors.toList()
  Line 380) ancestor.getId() ==> com.github.javaparser.symbolsolver.model.typesystem.ReferenceType.getId()
  Line 120) getSuperClass().getTypeDeclaration().getAllFields() ==> com.github.javaparser.symbolsolver.model.declarations.ReferenceTypeDeclaration.getAllFields()
  Line 380) typeParameterDeclaration.getContainerId() ==> com.github.javaparser.symbolsolver.model.declarations.TypeParameterDeclaration.getContainerId()
  Line 418) node.getClass().getCanonicalName() ==> java.lang.Class.getCanonicalName()
  Line 322) tp.getBounds(typeSolver).get(0) ==> java.util.List.get(int)
  Line 107) typeDeclarations.stream().filter(internalType -> internalType.getName().getId().equals(name)).findFirst().map(internalType -> SymbolReference.solved(JavaParserFacade.get(typeSolver).getTypeDeclaration(internalType))) ==> java.util.Optional.map(java.util.function.Function<? super T, ? extends U>)
  Line 77) parent.getCorrespondingDeclaration().internalTypes().stream().filter(it -> it.getName().equals(childName)).findFirst() ==> java.util.stream.Stream.findFirst()
  Line 329) Arrays.stream(this.clazz.getDeclaredClasses()).map(ic -> ReflectionFactory.typeDeclarationFor(ic, typeSolver)).collect(Collectors.toSet()) ==> java.util.stream.Stream.collect(java.util.stream.Collector<? super T, A, R>)
