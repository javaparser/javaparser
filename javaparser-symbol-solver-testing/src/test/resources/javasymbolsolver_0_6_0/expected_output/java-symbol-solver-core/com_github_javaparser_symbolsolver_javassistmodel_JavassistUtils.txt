  Line 101) ref.isSolved() ==> com.github.javaparser.symbolsolver.model.resolution.SymbolReference.isSolved()
  Line 273) name.substring(prefix.length()) ==> java.lang.String.substring(int)
  Line 103) method.getParameterTypes() ==> java.lang.reflect.Method.getParameterTypes()
  Line 103) method.getGenericParameterTypes() ==> java.lang.reflect.Method.getGenericParameterTypes()
  Line 188) node.getClassExpr().isPresent() ==> java.util.Optional.isPresent()
  Line 188) node.getClassExpr() ==> com.github.javaparser.ast.expr.ThisExpr.getClassExpr()
  Line 273) prefix.length() ==> java.lang.String.length()
  Line 276) getContext().getParent().solveType(name, typeSolver) ==> com.github.javaparser.symbolsolver.core.resolution.Context.solveType(java.lang.String, com.github.javaparser.symbolsolver.model.resolution.TypeSolver)
  Line 276) getContext().getParent() ==> com.github.javaparser.symbolsolver.core.resolution.Context.getParent()
  Line 276) getContext() ==> com.github.javaparser.symbolsolver.javaparsermodel.declarations.JavaParserClassDeclaration.getContext()
  Line 44) ctClass.getDeclaredMethods() ==> javassist.CtClass.getDeclaredMethods()
  Line 282) getSuperClass() ==> com.github.javaparser.symbolsolver.javaparsermodel.declarations.JavaParserClassDeclaration.getSuperClass()
  Line 284) ancestors.add(superclass) ==> java.util.List.add(E)
  Line 45) method.getName().equals(name) ==> java.lang.String.equals(java.lang.Object)
  Line 190) node.getClassExpr().get().toString() ==> com.github.javaparser.ast.Node.toString()
  Line 190) node.getClassExpr().get() ==> java.util.Optional.get()
  Line 190) node.getClassExpr() ==> com.github.javaparser.ast.expr.ThisExpr.getClassExpr()
  Line 45) method.getName() ==> javassist.CtMethod.getName()
  Line 102) JavaParserFactory.getContext(type, typeSolver) ==> com.github.javaparser.symbolsolver.javaparsermodel.JavaParserFactory.getContext(com.github.javaparser.ast.Node, com.github.javaparser.symbolsolver.model.resolution.TypeSolver)
  Line 48) argumentsTypes.size() ==> java.util.List.size()
  Line 104) ref.getCorrespondingDeclaration() ==> com.github.javaparser.symbolsolver.model.resolution.SymbolReference.getCorrespondingDeclaration()
  Line 106) type.getClass().getCanonicalName() ==> java.lang.Class.getCanonicalName()
  Line 48) methodUsage.getNoParams() ==> com.github.javaparser.symbolsolver.model.methods.MethodUsage.getNoParams()
  Line 53) method.getGenericSignature() ==> javassist.CtBehavior.getGenericSignature()
  Line 106) type.getClass() ==> java.lang.Object.getClass()
  Line 111) context.solveGenericType(name, typeSolver) ==> com.github.javaparser.symbolsolver.core.resolution.Context.solveGenericType(java.lang.String, com.github.javaparser.symbolsolver.model.resolution.TypeSolver)
  Line 286) wrappedNode.getImplementedTypes() ==> com.github.javaparser.ast.body.ClassOrInterfaceDeclaration.getImplementedTypes()
  Line 112) genericType.isPresent() ==> java.util.Optional.isPresent()
  Line 54) SignatureAttribute.toMethodSignature(method.getGenericSignature()) ==> javassist.bytecode.SignatureAttribute.toMethodSignature(java.lang.String)
  Line 113) genericType.get() ==> java.util.Optional.get()
  Line 192) typeSolver.tryToSolveType(className) ==> com.github.javaparser.symbolsolver.model.resolution.TypeSolver.tryToSolveType(java.lang.String)
  Line 193) clazz.isSolved() ==> com.github.javaparser.symbolsolver.model.resolution.SymbolReference.isSolved()
  Line 194) SymbolReference.solved(clazz.getCorrespondingDeclaration()) ==> com.github.javaparser.symbolsolver.model.resolution.SymbolReference.solved(S2)
  Line 194) clazz.getCorrespondingDeclaration() ==> com.github.javaparser.symbolsolver.model.resolution.SymbolReference.getCorrespondingDeclaration()
  Line 115) typeSolver.solveType(name) ==> com.github.javaparser.symbolsolver.model.resolution.TypeSolver.solveType(java.lang.String)
  Line 128) ((JavaParserClassDeclaration) typeDeclaration).getContext() ==> com.github.javaparser.symbolsolver.javaparsermodel.declarations.JavaParserClassDeclaration.getContext()
  Line 129) ctx.solveSymbol(name, typeSolver) ==> com.github.javaparser.symbolsolver.core.resolution.Context.solveSymbol(java.lang.String, com.github.javaparser.symbolsolver.model.resolution.TypeSolver)
  Line 132) ((JavaParserInterfaceDeclaration) typeDeclaration).getContext() ==> com.github.javaparser.symbolsolver.javaparsermodel.declarations.JavaParserInterfaceDeclaration.getContext()
  Line 54) method.getGenericSignature() ==> javassist.CtBehavior.getGenericSignature()
  Line 287) wrappedNode.getImplementedTypes() ==> com.github.javaparser.ast.body.ClassOrInterfaceDeclaration.getImplementedTypes()
  Line 55) parseTypeParameters(classSignature.getReturnType().toString(), typeSolver, invokationContext) ==> com.github.javaparser.symbolsolver.javassistmodel.JavassistUtils.parseTypeParameters(java.lang.String, com.github.javaparser.symbolsolver.model.resolution.TypeSolver, com.github.javaparser.symbolsolver.core.resolution.Context)
  Line 55) classSignature.getReturnType().toString() ==> java.lang.Object.toString()
  Line 55) classSignature.getReturnType() ==> javassist.bytecode.SignatureAttribute.MethodSignature.getReturnType()
  Line 56) methodUsage.returnType() ==> com.github.javaparser.symbolsolver.model.methods.MethodUsage.returnType()
  Line 197) node.getAncestorOfType(CompilationUnit.class) ==> com.github.javaparser.HasParentNode.getAncestorOfType(java.lang.Class<N>)
  Line 133) ctx.solveSymbol(name, typeSolver) ==> com.github.javaparser.symbolsolver.core.resolution.Context.solveSymbol(java.lang.String, com.github.javaparser.symbolsolver.model.resolution.TypeSolver)
  Line 108) Arrays.stream(method.getTypeParameters()).map((refTp) -> new ReflectionTypeParameter(refTp, false, typeSolver)).collect(Collectors.toList()) ==> java.util.stream.Stream.collect(java.util.stream.Collector<? super T, A, R>)
  Line 136) ((JavaParserEnumDeclaration) typeDeclaration).getContext() ==> com.github.javaparser.symbolsolver.javaparsermodel.declarations.JavaParserEnumDeclaration.getContext()
  Line 108) Arrays.stream(method.getTypeParameters()).map((refTp) -> new ReflectionTypeParameter(refTp, false, typeSolver)) ==> java.util.stream.Stream.map(java.util.function.Function<? super T, ? extends R>)
  Line 108) Arrays.stream(method.getTypeParameters()) ==> java.util.Arrays.stream(T[])
  Line 108) method.getTypeParameters() ==> java.lang.reflect.Method.getTypeParameters()
  Line 108) Collectors.toList() ==> java.util.stream.Collectors.toList()
  Line 112) new MethodDeclarationCommonLogic(this, typeSolver).resolveTypeVariables(context, parameterTypes) ==> com.github.javaparser.symbolsolver.declarations.common.MethodDeclarationCommonLogic.resolveTypeVariables(com.github.javaparser.symbolsolver.core.resolution.Context, java.util.List<com.github.javaparser.symbolsolver.model.typesystem.Type>)
  Line 59) newReturnType.asReferenceType().transformTypeParameters(tp -> parametersOfReturnType.remove(0)) ==> com.github.javaparser.symbolsolver.model.typesystem.ReferenceType.transformTypeParameters(com.github.javaparser.symbolsolver.model.typesystem.TypeTransformer)
  Line 59) newReturnType.asReferenceType() ==> com.github.javaparser.symbolsolver.model.typesystem.Type.asReferenceType()
  Line 288) toReferenceType(implemented) ==> com.github.javaparser.symbolsolver.javaparsermodel.declarations.JavaParserClassDeclaration.toReferenceType(com.github.javaparser.ast.type.ClassOrInterfaceType)
  Line 289) ancestors.add(ancestor) ==> java.util.List.add(E)
  Line 59) parametersOfReturnType.remove(0) ==> java.util.List.remove(int)
  Line 61) methodUsage.replaceReturnType(newReturnType) ==> com.github.javaparser.symbolsolver.model.methods.MethodUsage.replaceReturnType(com.github.javaparser.symbolsolver.model.typesystem.Type)
  Line 63) Optional.of(methodUsage) ==> java.util.Optional.of(T)
  Line 137) ctx.solveSymbol(name, typeSolver) ==> com.github.javaparser.symbolsolver.core.resolution.Context.solveSymbol(java.lang.String, com.github.javaparser.symbolsolver.model.resolution.TypeSolver)
  Line 198) cu.isPresent() ==> java.util.Optional.isPresent()
  Line 140) ((ReflectionClassDeclaration) typeDeclaration).solveSymbol(name, typeSolver) ==> com.github.javaparser.symbolsolver.reflectionmodel.ReflectionClassDeclaration.solveSymbol(java.lang.String, com.github.javaparser.symbolsolver.model.resolution.TypeSolver)
  Line 199) cu.get().getClassByName(className) ==> com.github.javaparser.ast.CompilationUnit.getClassByName(java.lang.String)
  Line 199) cu.get() ==> java.util.Optional.get()
  Line 143) ((ReflectionInterfaceDeclaration) typeDeclaration).solveSymbol(name, typeSolver) ==> com.github.javaparser.symbolsolver.reflectionmodel.ReflectionInterfaceDeclaration.solveSymbol(java.lang.String, com.github.javaparser.symbolsolver.model.resolution.TypeSolver)
  Line 298) wrappedNode.getMembers() ==> com.github.javaparser.ast.body.TypeDeclaration.getMembers()
  Line 71) ctClass.getSuperclass() ==> javassist.CtClass.getSuperclass()
  Line 200) classByName.isPresent() ==> java.util.Optional.isPresent()
  Line 300) methods.add(new JavaParserMethodDeclaration((com.github.javaparser.ast.body.MethodDeclaration) member, typeSolver)) ==> java.util.Set.add(E)
  Line 73) new JavassistClassDeclaration(superClass, typeSolver).solveMethodAsUsage(name, argumentsTypes, typeSolver, invokationContext, null) ==> com.github.javaparser.symbolsolver.javassistmodel.JavassistClassDeclaration.solveMethodAsUsage(java.lang.String, java.util.List<com.github.javaparser.symbolsolver.model.typesystem.Type>, com.github.javaparser.symbolsolver.model.resolution.TypeSolver, com.github.javaparser.symbolsolver.core.resolution.Context, java.util.List<com.github.javaparser.symbolsolver.model.typesystem.Type>)
  Line 74) ref.isPresent() ==> java.util.Optional.isPresent()
  Line 83) ctClass.getInterfaces() ==> javassist.CtClass.getInterfaces()
  Line 117) Modifier.isAbstract(method.getModifiers()) ==> java.lang.reflect.Modifier.isAbstract(int)
  Line 117) method.getModifiers() ==> java.lang.reflect.Method.getModifiers()
  Line 122) method.isDefault() ==> java.lang.reflect.Method.isDefault()
  Line 146) ((JavassistClassDeclaration) typeDeclaration).solveSymbol(name, typeSolver) ==> com.github.javaparser.symbolsolver.javassistmodel.JavassistClassDeclaration.solveSymbol(java.lang.String, com.github.javaparser.symbolsolver.model.resolution.TypeSolver)
  Line 127) Modifier.isStatic(method.getModifiers()) ==> java.lang.reflect.Modifier.isStatic(int)
  Line 127) method.getModifiers() ==> java.lang.reflect.Method.getModifiers()
  Line 148) SymbolReference.unsolved(ValueDeclaration.class) ==> com.github.javaparser.symbolsolver.model.resolution.SymbolReference.unsolved(java.lang.Class<S2>)
  Line 132) ReflectionFactory.modifiersToAccessLevel(this.method.getModifiers()) ==> com.github.javaparser.symbolsolver.reflectionmodel.ReflectionFactory.modifiersToAccessLevel(int)
  Line 132) this.method.getModifiers() ==> java.lang.reflect.Method.getModifiers()
  Line 157) ((JavaParserClassDeclaration) typeDeclaration).solveType(name, typeSolver) ==> com.github.javaparser.symbolsolver.javaparsermodel.declarations.JavaParserClassDeclaration.solveType(java.lang.String, com.github.javaparser.symbolsolver.model.resolution.TypeSolver)
  Line 84) new JavassistInterfaceDeclaration(interfaze, typeSolver).solveMethodAsUsage(name, argumentsTypes, typeSolver, invokationContext, null) ==> com.github.javaparser.symbolsolver.javassistmodel.JavassistInterfaceDeclaration.solveMethodAsUsage(java.lang.String, java.util.List<com.github.javaparser.symbolsolver.model.typesystem.Type>, com.github.javaparser.symbolsolver.model.resolution.TypeSolver, com.github.javaparser.symbolsolver.core.resolution.Context, java.util.List<com.github.javaparser.symbolsolver.model.typesystem.Type>)
  Line 308) this.wrappedNode.getTypeParameters().stream().map((tp) -> new JavaParserTypeParameter(tp, typeSolver)).collect(Collectors.toList()) ==> ERROR
