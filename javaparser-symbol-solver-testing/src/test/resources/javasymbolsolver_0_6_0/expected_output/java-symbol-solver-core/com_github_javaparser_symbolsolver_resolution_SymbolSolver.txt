  Line 156) Optional.of(methodUsage) ==> java.util.Optional.of(T)
  Line 158) Optional.empty() ==> java.util.Optional.empty()
  Line 168) isFunctionalInterface() ==> com.github.javaparser.symbolsolver.logic.AbstractTypeDeclaration.isFunctionalInterface()
  Line 99) typeSolver.solveType(typeName) ==> com.github.javaparser.symbolsolver.model.resolution.TypeSolver.solveType(java.lang.String)
  Line 100) new SymbolSolver(typeSolver).solveSymbolInType(importedType, memberName) ==> com.github.javaparser.symbolsolver.resolution.SymbolSolver.solveSymbolInType(com.github.javaparser.symbolsolver.model.declarations.TypeDeclaration, java.lang.String)
  Line 170) other.getQualifiedName().equals(getQualifiedName()) ==> java.lang.String.equals(java.lang.Object)
  Line 107) SymbolReference.unsolved(ValueDeclaration.class) ==> com.github.javaparser.symbolsolver.model.resolution.SymbolReference.unsolved(java.lang.Class<S2>)
  Line 170) other.getQualifiedName() ==> com.github.javaparser.symbolsolver.model.declarations.TypeDeclaration.getQualifiedName()
  Line 170) getQualifiedName() ==> com.github.javaparser.symbolsolver.reflectionmodel.ReflectionInterfaceDeclaration.getQualifiedName()
  Line 173) this.clazz.getSuperclass() ==> java.lang.Class.getSuperclass()
  Line 112) wrappedNode.getTypes() ==> com.github.javaparser.ast.CompilationUnit.getTypes()
  Line 174) new ReflectionInterfaceDeclaration(clazz.getSuperclass(), typeSolver).canBeAssignedTo(other) ==> com.github.javaparser.symbolsolver.reflectionmodel.ReflectionInterfaceDeclaration.canBeAssignedTo(com.github.javaparser.symbolsolver.model.declarations.ReferenceTypeDeclaration)
  Line 174) clazz.getSuperclass() ==> java.lang.Class.getSuperclass()
  Line 166) JavaParserFacade.get(typeSolver) ==> com.github.javaparser.symbolsolver.javaparsermodel.JavaParserFacade.get(com.github.javaparser.symbolsolver.model.resolution.TypeSolver)
  Line 41) Arrays.stream(ctClass.getDeclaredMethods()).map(m -> new JavassistMethodDeclaration(m, typeSolver)) ==> java.util.stream.Stream.map(java.util.function.Function<? super T, ? extends R>)
  Line 41) Arrays.stream(ctClass.getDeclaredMethods()) ==> java.util.Arrays.stream(T[])
  Line 177) clazz.getInterfaces() ==> java.lang.Class.getInterfaces()
  Line 113) wrappedNode.getTypes() ==> com.github.javaparser.ast.CompilationUnit.getTypes()
  Line 166) classNode.getExtendedTypes(0) ==> com.github.javaparser.ast.nodeTypes.NodeWithExtends.getExtendedTypes(int)
  Line 114) type.getName().getId().equals(name) ==> java.lang.String.equals(java.lang.Object)
  Line 41) ctClass.getDeclaredMethods() ==> javassist.CtClass.getDeclaredMethods()
  Line 42) Collectors.toSet() ==> java.util.stream.Collectors.toSet()
  Line 114) type.getName().getId() ==> com.github.javaparser.ast.nodeTypes.NodeWithIdentifier.getId()
  Line 114) type.getName() ==> com.github.javaparser.ast.body.TypeDeclaration.getName()
  Line 178) new ReflectionInterfaceDeclaration(interfaze, typeSolver).canBeAssignedTo(other) ==> com.github.javaparser.symbolsolver.reflectionmodel.ReflectionInterfaceDeclaration.canBeAssignedTo(com.github.javaparser.symbolsolver.model.declarations.ReferenceTypeDeclaration)
  Line 167) classDecl.isReferenceType() ==> com.github.javaparser.symbolsolver.model.typesystem.Type.isReferenceType()
  Line 58) context.solveSymbol(name, typeSolver) ==> com.github.javaparser.symbolsolver.core.resolution.Context.solveSymbol(java.lang.String, com.github.javaparser.symbolsolver.model.resolution.TypeSolver)
  Line 183) other.getQualifiedName().equals(Object.class.getCanonicalName()) ==> java.lang.String.equals(java.lang.Object)
  Line 168) classDecl.asReferenceType().getTypeDeclaration() ==> com.github.javaparser.symbolsolver.model.typesystem.ReferenceType.getTypeDeclaration()
  Line 183) other.getQualifiedName() ==> com.github.javaparser.symbolsolver.model.declarations.TypeDeclaration.getQualifiedName()
  Line 183) Object.class.getCanonicalName() ==> java.lang.Class.getCanonicalName()
  Line 196) isFunctionalInterface() ==> com.github.javaparser.symbolsolver.logic.AbstractTypeDeclaration.isFunctionalInterface()
  Line 198) type.isArray() ==> com.github.javaparser.symbolsolver.model.typesystem.Type.isArray()
  Line 201) type.isPrimitive() ==> com.github.javaparser.symbolsolver.model.typesystem.Type.isPrimitive()
  Line 168) classDecl.asReferenceType() ==> com.github.javaparser.symbolsolver.model.typesystem.Type.asReferenceType()
  Line 190) solveType(annotationExpr.getName().getId(), typeSolver).getCorrespondingDeclaration().getQualifiedName() ==> com.github.javaparser.symbolsolver.model.declarations.TypeDeclaration.getQualifiedName()
  Line 190) solveType(annotationExpr.getName().getId(), typeSolver).getCorrespondingDeclaration() ==> com.github.javaparser.symbolsolver.model.resolution.SymbolReference.getCorrespondingDeclaration()
  Line 190) solveType(annotationExpr.getName().getId(), typeSolver) ==> com.github.javaparser.symbolsolver.javaparsermodel.declarations.JavaParserClassDeclaration.solveType(java.lang.String, com.github.javaparser.symbolsolver.model.resolution.TypeSolver)
  Line 190) annotationExpr.getName().getId() ==> com.github.javaparser.ast.nodeTypes.NodeWithIdentifier.getId()
  Line 190) annotationExpr.getName() ==> com.github.javaparser.ast.expr.AnnotationExpr.getName()
  Line 204) type.describe().equals(getQualifiedName()) ==> java.lang.String.equals(java.lang.Object)
  Line 204) type.describe() ==> com.github.javaparser.symbolsolver.model.typesystem.Type.describe()
  Line 204) getQualifiedName() ==> com.github.javaparser.symbolsolver.reflectionmodel.ReflectionInterfaceDeclaration.getQualifiedName()
  Line 46) Arrays.stream(ctClass.getConstructors()).map(m -> new JavassistConstructorDeclaration(m, typeSolver)).collect(Collectors.toList()) ==> java.util.stream.Stream.collect(java.util.stream.Collector<? super T, A, R>)
  Line 199) wrappedNode.isInterface() ==> com.github.javaparser.ast.body.ClassOrInterfaceDeclaration.isInterface()
  Line 209) otherTypeDeclaration.getTypeDeclaration().canBeAssignedTo(this) ==> com.github.javaparser.symbolsolver.model.declarations.ReferenceTypeDeclaration.canBeAssignedTo(com.github.javaparser.symbolsolver.model.declarations.ReferenceTypeDeclaration)
  Line 46) Arrays.stream(ctClass.getConstructors()).map(m -> new JavassistConstructorDeclaration(m, typeSolver)) ==> java.util.stream.Stream.map(java.util.function.Function<? super T, ? extends R>)
  Line 46) Arrays.stream(ctClass.getConstructors()) ==> java.util.Arrays.stream(T[])
  Line 46) ctClass.getConstructors() ==> javassist.CtClass.getConstructors()
  Line 47) Collectors.toList() ==> java.util.stream.Collectors.toList()
  Line 204) javaParserTypeAdapter.getPackageName() ==> com.github.javaparser.symbolsolver.javaparsermodel.declarations.JavaParserTypeAdapter.getPackageName()
  Line 62) solveSymbol(name, JavaParserFactory.getContext(node, typeSolver)) ==> com.github.javaparser.symbolsolver.resolution.SymbolSolver.solveSymbol(java.lang.String, com.github.javaparser.symbolsolver.core.resolution.Context)
  Line 209) otherTypeDeclaration.getTypeDeclaration() ==> com.github.javaparser.symbolsolver.model.typesystem.ReferenceType.getTypeDeclaration()
  Line 62) JavaParserFactory.getContext(node, typeSolver) ==> com.github.javaparser.symbolsolver.javaparsermodel.JavaParserFactory.getContext(com.github.javaparser.ast.Node, com.github.javaparser.symbolsolver.model.resolution.TypeSolver)
  Line 66) context.solveSymbolAsValue(name, typeSolver) ==> com.github.javaparser.symbolsolver.core.resolution.Context.solveSymbolAsValue(java.lang.String, com.github.javaparser.symbolsolver.model.resolution.TypeSolver)
  Line 222) reflectionClassAdapter.getField(name) ==> com.github.javaparser.symbolsolver.reflectionmodel.ReflectionClassAdapter.getField(java.lang.String)
  Line 209) javaParserTypeAdapter.getClassName() ==> com.github.javaparser.symbolsolver.javaparsermodel.declarations.JavaParserTypeAdapter.getClassName()
  Line 214) javaParserTypeAdapter.getQualifiedName() ==> com.github.javaparser.symbolsolver.javaparsermodel.declarations.JavaParserTypeAdapter.getQualifiedName()
  Line 52) collectDeclaredFields(ctClass, fieldDecls) ==> com.github.javaparser.symbolsolver.javassistmodel.JavassistTypeDeclarationAdapter.collectDeclaredFields(javassist.CtClass, java.util.List<com.github.javaparser.symbolsolver.model.declarations.FieldDeclaration>)
  Line 219) javaParserTypeAdapter.isAssignableBy(other) ==> com.github.javaparser.symbolsolver.javaparsermodel.declarations.JavaParserTypeAdapter.isAssignableBy(com.github.javaparser.symbolsolver.model.declarations.ReferenceTypeDeclaration)
  Line 58) Arrays.stream(ctClass.getDeclaredFields()).forEach(f -> fieldDecls.add(new JavassistFieldDeclaration(f, typeSolver))) ==> java.util.stream.Stream.forEach(java.util.function.Consumer<? super T>)
  Line 58) Arrays.stream(ctClass.getDeclaredFields()) ==> java.util.Arrays.stream(T[])
  Line 70) JavaParserFactory.getContext(node, typeSolver) ==> com.github.javaparser.symbolsolver.javaparsermodel.JavaParserFactory.getContext(com.github.javaparser.ast.Node, com.github.javaparser.symbolsolver.model.resolution.TypeSolver)
  Line 71) solveSymbolAsValue(name, context) ==> com.github.javaparser.symbolsolver.resolution.SymbolSolver.solveSymbolAsValue(java.lang.String, com.github.javaparser.symbolsolver.core.resolution.Context)
  Line 75) context.solveType(name, typeSolver) ==> com.github.javaparser.symbolsolver.core.resolution.Context.solveType(java.lang.String, com.github.javaparser.symbolsolver.model.resolution.TypeSolver)
  Line 224) javaParserTypeAdapter.isAssignableBy(type) ==> com.github.javaparser.symbolsolver.javaparsermodel.declarations.JavaParserTypeAdapter.isAssignableBy(com.github.javaparser.symbolsolver.model.typesystem.Type)
  Line 58) ctClass.getDeclaredFields() ==> javassist.CtClass.getDeclaredFields()
  Line 227) reflectionClassAdapter.getAllFields() ==> com.github.javaparser.symbolsolver.reflectionmodel.ReflectionClassAdapter.getAllFields()
  Line 230) this.getQualifiedName().equals(other.getQualifiedName()) ==> java.lang.String.equals(java.lang.Object)
  Line 59) fieldDecls.add(new JavassistFieldDeclaration(f, typeSolver)) ==> java.util.List.add(E)
  Line 232) clazz.getFields() ==> java.lang.Class.getFields()
  Line 233) field.getName().equals(name) ==> java.lang.String.equals(java.lang.Object)
  Line 233) field.getName() ==> java.lang.reflect.Field.getName()
  Line 234) SymbolReference.solved(new ReflectionFieldDeclaration(field, typeSolver)) ==> com.github.javaparser.symbolsolver.model.resolution.SymbolReference.solved(S2)
  Line 230) this.getQualifiedName() ==> com.github.javaparser.symbolsolver.javaparsermodel.declarations.JavaParserClassDeclaration.getQualifiedName()
  Line 230) other.getQualifiedName() ==> com.github.javaparser.symbolsolver.model.declarations.TypeDeclaration.getQualifiedName()
  Line 237) SymbolReference.unsolved(ValueDeclaration.class) ==> com.github.javaparser.symbolsolver.model.resolution.SymbolReference.unsolved(java.lang.Class<S2>)
  Line 242) reflectionClassAdapter.getAncestors() ==> com.github.javaparser.symbolsolver.reflectionmodel.ReflectionClassAdapter.getAncestors()
  Line 61) collectDeclaredFields(ctClass.getSuperclass(), fieldDecls) ==> com.github.javaparser.symbolsolver.javassistmodel.JavassistTypeDeclarationAdapter.collectDeclaredFields(javassist.CtClass, java.util.List<com.github.javaparser.symbolsolver.model.declarations.FieldDeclaration>)
  Line 247) reflectionClassAdapter.getDeclaredMethods() ==> com.github.javaparser.symbolsolver.reflectionmodel.ReflectionClassAdapter.getDeclaredMethods()
  Line 252) reflectionClassAdapter.hasField(name) ==> com.github.javaparser.symbolsolver.reflectionmodel.ReflectionClassAdapter.hasField(java.lang.String)
  Line 257) clazz.getSimpleName() ==> java.lang.Class.getSimpleName()
  Line 233) getSuperClass().getTypeDeclaration() ==> com.github.javaparser.symbolsolver.model.typesystem.ReferenceType.getTypeDeclaration()
  Line 233) getSuperClass() ==> com.github.javaparser.symbolsolver.javaparsermodel.declarations.JavaParserClassDeclaration.getSuperClass()
  Line 61) ctClass.getSuperclass() ==> javassist.CtClass.getSuperclass()
  Line 236) Object.class.getCanonicalName().equals(superclass.getQualifiedName()) ==> java.lang.String.equals(java.lang.Object)
  Line 236) Object.class.getCanonicalName() ==> java.lang.Class.getCanonicalName()
  Line 236) superclass.getQualifiedName() ==> com.github.javaparser.symbolsolver.model.declarations.TypeDeclaration.getQualifiedName()
  Line 69) ctClass.getGenericSignature() ==> javassist.CtClass.getGenericSignature()
  Line 70) Collections.emptyList() ==> java.util.Collections.emptyList()
  Line 239) superclass.canBeAssignedTo(other) ==> com.github.javaparser.symbolsolver.model.declarations.ReferenceTypeDeclaration.canBeAssignedTo(com.github.javaparser.symbolsolver.model.declarations.ReferenceTypeDeclaration)
  Line 74) SignatureAttribute.toClassSignature(ctClass.getGenericSignature()) ==> javassist.bytecode.SignatureAttribute.toClassSignature(java.lang.String)
  Line 74) ctClass.getGenericSignature() ==> javassist.CtClass.getGenericSignature()
  Line 244) this.wrappedNode.getImplementedTypes() ==> com.github.javaparser.ast.body.ClassOrInterfaceDeclaration.getImplementedTypes()
  Line 268) clazz.getInterfaces() ==> java.lang.Class.getInterfaces()
  Line 79) solveType(name, JavaParserFactory.getContext(node, typeSolver)) ==> com.github.javaparser.symbolsolver.resolution.SymbolSolver.solveType(java.lang.String, com.github.javaparser.symbolsolver.core.resolution.Context)
  Line 269) res.add(new ReferenceTypeImpl(new ReflectionInterfaceDeclaration(i, typeSolver), typeSolver)) ==> java.util.List.add(E)
  Line 276) reflectionClassAdapter.containerType() ==> com.github.javaparser.symbolsolver.reflectionmodel.ReflectionClassAdapter.containerType()
  Line 79) JavaParserFactory.getContext(node, typeSolver) ==> com.github.javaparser.symbolsolver.javaparsermodel.JavaParserFactory.getContext(com.github.javaparser.ast.Node, com.github.javaparser.symbolsolver.model.resolution.TypeSolver)
  Line 245) wrappedNode.getImplementedTypes() ==> com.github.javaparser.ast.body.ClassOrInterfaceDeclaration.getImplementedTypes()
  Line 83) context.solveMethod(methodName, argumentsTypes, false, typeSolver) ==> com.github.javaparser.symbolsolver.core.resolution.Context.solveMethod(java.lang.String, java.util.List<com.github.javaparser.symbolsolver.model.typesystem.Type>, boolean, com.github.javaparser.symbolsolver.model.resolution.TypeSolver)
  Line 84) decl.isSolved() ==> com.github.javaparser.symbolsolver.model.resolution.SymbolReference.isSolved()
  Line 87) decl.getCorrespondingDeclaration() ==> com.github.javaparser.symbolsolver.model.resolution.SymbolReference.getCorrespondingDeclaration()
  Line 171) JavaParserFactory.getContext(classNode, typeSolver).solveType(classNode.getNameAsString(), typeSolver) ==> com.github.javaparser.symbolsolver.core.resolution.Context.solveType(java.lang.String, com.github.javaparser.symbolsolver.model.resolution.TypeSolver)
  Line 75) Arrays.<SignatureAttribute.TypeParameter>stream(classSignature.getParameters()).map((tp) -> new JavassistTypeParameter(tp, JavassistFactory.toTypeDeclaration(ctClass, typeSolver), typeSolver)).collect(Collectors.toList()) ==> java.util.stream.Stream.collect(java.util.stream.Collector<? super T, A, R>)
  Line 75) Arrays.<SignatureAttribute.TypeParameter>stream(classSignature.getParameters()).map((tp) -> new JavassistTypeParameter(tp, JavassistFactory.toTypeDeclaration(ctClass, typeSolver), typeSolver)) ==> java.util.stream.Stream.map(java.util.function.Function<? super T, ? extends R>)
  Line 75) Arrays.<SignatureAttribute.TypeParameter>stream(classSignature.getParameters()) ==> java.util.Arrays.stream(T[])
  Line 75) classSignature.getParameters() ==> javassist.bytecode.SignatureAttribute.ClassSignature.getParameters()
  Line 76) JavassistFactory.toTypeDeclaration(ctClass, typeSolver) ==> com.github.javaparser.symbolsolver.javassistmodel.JavassistFactory.toTypeDeclaration(javassist.CtClass, com.github.javaparser.symbolsolver.model.resolution.TypeSolver)
  Line 77) Collectors.toList() ==> java.util.stream.Collectors.toList()
  Line 246) new SymbolSolver(typeSolver).solveType(type) ==> com.github.javaparser.symbolsolver.resolution.SymbolSolver.solveType(com.github.javaparser.ast.type.Type)
  Line 247) ancestor.canBeAssignedTo(other) ==> com.github.javaparser.symbolsolver.model.declarations.ReferenceTypeDeclaration.canBeAssignedTo(com.github.javaparser.symbolsolver.model.declarations.ReferenceTypeDeclaration)
  Line 86) ctClass.getDeclaringClass() ==> javassist.CtClass.getDeclaringClass()
  Line 91) solveMethod(methodName, argumentsTypes, JavaParserFactory.getContext(node, typeSolver)) ==> com.github.javaparser.symbolsolver.resolution.SymbolSolver.solveMethod(java.lang.String, java.util.List<com.github.javaparser.symbolsolver.model.typesystem.Type>, com.github.javaparser.symbolsolver.core.resolution.Context)
  Line 87) Optional.empty() ==> java.util.Optional.empty()
  Line 91) JavaParserFactory.getContext(node, typeSolver) ==> com.github.javaparser.symbolsolver.javaparsermodel.JavaParserFactory.getContext(com.github.javaparser.ast.Node, com.github.javaparser.symbolsolver.model.resolution.TypeSolver)
  Line 99) ((ClassOrInterfaceType) type).getName().getId() ==> com.github.javaparser.ast.nodeTypes.NodeWithIdentifier.getId()
  Line 99) ((ClassOrInterfaceType) type).getName() ==> com.github.javaparser.ast.type.ClassOrInterfaceType.getName()
  Line 281) Arrays.stream(this.clazz.getDeclaredClasses()).map(ic -> ReflectionFactory.typeDeclarationFor(ic, typeSolver)).collect(Collectors.toSet()) ==> java.util.stream.Stream.collect(java.util.stream.Collector<? super T, A, R>)
  Line 281) Arrays.stream(this.clazz.getDeclaredClasses()).map(ic -> ReflectionFactory.typeDeclarationFor(ic, typeSolver)) ==> java.util.stream.Stream.map(java.util.function.Function<? super T, ? extends R>)
  Line 281) Arrays.stream(this.clazz.getDeclaredClasses()) ==> java.util.Arrays.stream(T[])
  Line 281) this.clazz.getDeclaredClasses() ==> java.lang.Class.getDeclaredClasses()
  Line 282) ReflectionFactory.typeDeclarationFor(ic, typeSolver) ==> com.github.javaparser.symbolsolver.reflectionmodel.ReflectionFactory.typeDeclarationFor(java.lang.Class<?>, com.github.javaparser.symbolsolver.model.resolution.TypeSolver)
  Line 283) Collectors.toSet() ==> java.util.stream.Collectors.toSet()
  Line 263) this.wrappedNode.getName().getId().equals(name) ==> java.lang.String.equals(java.lang.Object)
  Line 263) this.wrappedNode.getName().getId() ==> com.github.javaparser.ast.nodeTypes.NodeWithIdentifier.getId()
  Line 263) this.wrappedNode.getName() ==> com.github.javaparser.ast.body.TypeDeclaration.getName()
  Line 88) Optional.of(JavassistFactory.toTypeDeclaration(ctClass.getDeclaringClass(), typeSolver)) ==> java.util.Optional.of(T)
  Line 264) SymbolReference.solved(this) ==> com.github.javaparser.symbolsolver.model.resolution.SymbolReference.solved(S2)
  Line 293) reflectionClassAdapter.hasDirectlyAnnotation(canonicalName) ==> com.github.javaparser.symbolsolver.reflectionmodel.ReflectionClassAdapter.hasDirectlyAnnotation(java.lang.String)
  Line 298) reflectionClassAdapter.getTypeParameters() ==> com.github.javaparser.symbolsolver.reflectionmodel.ReflectionClassAdapter.getTypeParameters()
  Line 303) ReflectionFactory.modifiersToAccessLevel(this.clazz.getModifiers()) ==> com.github.javaparser.symbolsolver.reflectionmodel.ReflectionFactory.modifiersToAccessLevel(int)
  Line 303) this.clazz.getModifiers() ==> java.lang.Class.getModifiers()
  Line 88) JavassistFactory.toTypeDeclaration(ctClass.getDeclaringClass(), typeSolver) ==> com.github.javaparser.symbolsolver.javassistmodel.JavassistFactory.toTypeDeclaration(javassist.CtClass, com.github.javaparser.symbolsolver.model.resolution.TypeSolver)
  Line 88) ctClass.getDeclaringClass() ==> javassist.CtClass.getDeclaringClass()
  Line 266) javaParserTypeAdapter.solveType(name, typeSolver) ==> com.github.javaparser.symbolsolver.javaparsermodel.declarations.JavaParserTypeAdapter.solveType(java.lang.String, com.github.javaparser.symbolsolver.model.resolution.TypeSolver)
  Line 171) JavaParserFactory.getContext(classNode, typeSolver) ==> com.github.javaparser.symbolsolver.javaparsermodel.JavaParserFactory.getContext(com.github.javaparser.ast.Node, com.github.javaparser.symbolsolver.model.resolution.TypeSolver)
  Line 100) JavaParserFactory.getContext(type, typeSolver).solveType(name, typeSolver) ==> com.github.javaparser.symbolsolver.core.resolution.Context.solveType(java.lang.String, com.github.javaparser.symbolsolver.model.resolution.TypeSolver)
