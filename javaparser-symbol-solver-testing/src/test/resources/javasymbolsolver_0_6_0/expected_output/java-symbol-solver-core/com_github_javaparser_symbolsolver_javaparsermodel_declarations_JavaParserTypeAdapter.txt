  Line 287) source.asWildcard() ==> com.github.javaparser.symbolsolver.model.typesystem.Type.asWildcard()
  Line 287) target.asWildcard().isBounded() ==> com.github.javaparser.symbolsolver.model.typesystem.Wildcard.isBounded()
  Line 287) target.asWildcard() ==> com.github.javaparser.symbolsolver.model.typesystem.Type.asWildcard()
  Line 288) inferTypes(source.asWildcard().getBoundedType(), target.asWildcard().getBoundedType(), mappings) ==> com.github.javaparser.symbolsolver.javaparsermodel.contexts.MethodCallExprContext.inferTypes(com.github.javaparser.symbolsolver.model.typesystem.Type, com.github.javaparser.symbolsolver.model.typesystem.Type, java.util.Map<com.github.javaparser.symbolsolver.model.declarations.TypeParameterDeclaration, com.github.javaparser.symbolsolver.model.typesystem.Type>)
  Line 288) source.asWildcard().getBoundedType() ==> com.github.javaparser.symbolsolver.model.typesystem.Wildcard.getBoundedType()
  Line 288) source.asWildcard() ==> com.github.javaparser.symbolsolver.model.typesystem.Type.asWildcard()
  Line 288) target.asWildcard().getBoundedType() ==> com.github.javaparser.symbolsolver.model.typesystem.Wildcard.getBoundedType()
  Line 288) target.asWildcard() ==> com.github.javaparser.symbolsolver.model.typesystem.Type.asWildcard()
  Line 292) source.isReferenceType() ==> com.github.javaparser.symbolsolver.model.typesystem.Type.isReferenceType()
  Line 292) target.isTypeVariable() ==> com.github.javaparser.symbolsolver.model.typesystem.Type.isTypeVariable()
  Line 293) mappings.put(target.asTypeParameter(), source) ==> java.util.Map.put(K, V)
  Line 293) target.asTypeParameter() ==> com.github.javaparser.symbolsolver.model.typesystem.Type.asTypeParameter()
  Line 296) source.isWildcard() ==> com.github.javaparser.symbolsolver.model.typesystem.Type.isWildcard()
  Line 296) target.isTypeVariable() ==> com.github.javaparser.symbolsolver.model.typesystem.Type.isTypeVariable()
  Line 297) mappings.put(target.asTypeParameter(), source) ==> java.util.Map.put(K, V)
  Line 297) target.asTypeParameter() ==> com.github.javaparser.symbolsolver.model.typesystem.Type.asTypeParameter()
  Line 300) source.isArray() ==> com.github.javaparser.symbolsolver.model.typesystem.Type.isArray()
  Line 300) target.isWildcard() ==> com.github.javaparser.symbolsolver.model.typesystem.Type.isWildcard()
  Line 301) target.asWildcard().isBounded() ==> com.github.javaparser.symbolsolver.model.typesystem.Wildcard.isBounded()
  Line 301) target.asWildcard() ==> com.github.javaparser.symbolsolver.model.typesystem.Type.asWildcard()
  Line 302) inferTypes(source, target.asWildcard().getBoundedType(), mappings) ==> com.github.javaparser.symbolsolver.javaparsermodel.contexts.MethodCallExprContext.inferTypes(com.github.javaparser.symbolsolver.model.typesystem.Type, com.github.javaparser.symbolsolver.model.typesystem.Type, java.util.Map<com.github.javaparser.symbolsolver.model.declarations.TypeParameterDeclaration, com.github.javaparser.symbolsolver.model.typesystem.Type>)
  Line 302) target.asWildcard().getBoundedType() ==> com.github.javaparser.symbolsolver.model.typesystem.Wildcard.getBoundedType()
  Line 302) target.asWildcard() ==> com.github.javaparser.symbolsolver.model.typesystem.Type.asWildcard()
  Line 307) source.isArray() ==> com.github.javaparser.symbolsolver.model.typesystem.Type.isArray()
  Line 307) target.isTypeVariable() ==> com.github.javaparser.symbolsolver.model.typesystem.Type.isTypeVariable()
  Line 39) Helper.getPackageName(wrappedNode) ==> com.github.javaparser.symbolsolver.javaparsermodel.declarations.Helper.getPackageName(com.github.javaparser.ast.Node)
  Line 308) mappings.put(target.asTypeParameter(), source) ==> java.util.Map.put(K, V)
  Line 308) target.asTypeParameter() ==> com.github.javaparser.symbolsolver.model.typesystem.Type.asTypeParameter()
  Line 312) source.isWildcard() ==> com.github.javaparser.symbolsolver.model.typesystem.Type.isWildcard()
  Line 312) target.isReferenceType() ==> com.github.javaparser.symbolsolver.model.typesystem.Type.isReferenceType()
  Line 313) source.asWildcard().isBounded() ==> com.github.javaparser.symbolsolver.model.typesystem.Wildcard.isBounded()
  Line 313) source.asWildcard() ==> com.github.javaparser.symbolsolver.model.typesystem.Type.asWildcard()
  Line 314) inferTypes(source.asWildcard().getBoundedType(), target, mappings) ==> com.github.javaparser.symbolsolver.javaparsermodel.contexts.MethodCallExprContext.inferTypes(com.github.javaparser.symbolsolver.model.typesystem.Type, com.github.javaparser.symbolsolver.model.typesystem.Type, java.util.Map<com.github.javaparser.symbolsolver.model.declarations.TypeParameterDeclaration, com.github.javaparser.symbolsolver.model.typesystem.Type>)
  Line 314) source.asWildcard().getBoundedType() ==> com.github.javaparser.symbolsolver.model.typesystem.Wildcard.getBoundedType()
  Line 314) source.asWildcard() ==> com.github.javaparser.symbolsolver.model.typesystem.Type.asWildcard()
  Line 43) Helper.getClassName("", wrappedNode) ==> com.github.javaparser.symbolsolver.javaparsermodel.declarations.Helper.getClassName(java.lang.String, com.github.javaparser.ast.Node)
  Line 318) source.isConstraint() ==> com.github.javaparser.symbolsolver.model.typesystem.Type.isConstraint()
  Line 318) target.isReferenceType() ==> com.github.javaparser.symbolsolver.model.typesystem.Type.isReferenceType()
  Line 319) inferTypes(source.asConstraintType().getBound(), target, mappings) ==> com.github.javaparser.symbolsolver.javaparsermodel.contexts.MethodCallExprContext.inferTypes(com.github.javaparser.symbolsolver.model.typesystem.Type, com.github.javaparser.symbolsolver.model.typesystem.Type, java.util.Map<com.github.javaparser.symbolsolver.model.declarations.TypeParameterDeclaration, com.github.javaparser.symbolsolver.model.typesystem.Type>)
  Line 319) source.asConstraintType().getBound() ==> com.github.javaparser.symbolsolver.model.typesystem.LambdaConstraintType.getBound()
  Line 319) source.asConstraintType() ==> com.github.javaparser.symbolsolver.model.typesystem.Type.asConstraintType()
  Line 323) source.isConstraint() ==> com.github.javaparser.symbolsolver.model.typesystem.Type.isConstraint()
  Line 323) target.isTypeVariable() ==> com.github.javaparser.symbolsolver.model.typesystem.Type.isTypeVariable()
  Line 324) inferTypes(source.asConstraintType().getBound(), target, mappings) ==> com.github.javaparser.symbolsolver.javaparsermodel.contexts.MethodCallExprContext.inferTypes(com.github.javaparser.symbolsolver.model.typesystem.Type, com.github.javaparser.symbolsolver.model.typesystem.Type, java.util.Map<com.github.javaparser.symbolsolver.model.declarations.TypeParameterDeclaration, com.github.javaparser.symbolsolver.model.typesystem.Type>)
  Line 324) source.asConstraintType().getBound() ==> com.github.javaparser.symbolsolver.model.typesystem.LambdaConstraintType.getBound()
  Line 324) source.asConstraintType() ==> com.github.javaparser.symbolsolver.model.typesystem.Type.asConstraintType()
  Line 327) source.isTypeVariable() ==> com.github.javaparser.symbolsolver.model.typesystem.Type.isTypeVariable()
  Line 327) target.isTypeVariable() ==> com.github.javaparser.symbolsolver.model.typesystem.Type.isTypeVariable()
  Line 328) mappings.put(target.asTypeParameter(), source) ==> java.util.Map.put(K, V)
  Line 328) target.asTypeParameter() ==> com.github.javaparser.symbolsolver.model.typesystem.Type.asTypeParameter()
  Line 331) source.isPrimitive() ==> com.github.javaparser.symbolsolver.model.typesystem.Type.isPrimitive()
  Line 47) Helper.containerName(getParentNode(wrappedNode)) ==> com.github.javaparser.symbolsolver.javaparsermodel.declarations.Helper.containerName(com.github.javaparser.ast.Node)
  Line 331) target.isPrimitive() ==> com.github.javaparser.symbolsolver.model.typesystem.Type.isPrimitive()
  Line 334) source.isNull() ==> com.github.javaparser.symbolsolver.model.typesystem.Type.isNull()
  Line 337) source.describe() ==> com.github.javaparser.symbolsolver.model.typesystem.Type.describe()
  Line 47) getParentNode(wrappedNode) ==> com.github.javaparser.symbolsolver.javaparser.Navigator.getParentNode(com.github.javaparser.ast.Node)
  Line 140) node.getType() ==> com.github.javaparser.ast.expr.CastExpr.getType()
  Line 48) containerName.isEmpty() ==> java.lang.String.isEmpty()
  Line 337) target.describe() ==> com.github.javaparser.symbolsolver.model.typesystem.Type.describe()
  Line 49) wrappedNode.getName().getId() ==> com.github.javaparser.ast.nodeTypes.NodeWithIdentifier.getId()
  Line 343) methodUsage.getDeclaration().hasVariadicParameter() ==> com.github.javaparser.symbolsolver.model.declarations.MethodLikeDeclaration.hasVariadicParameter()
  Line 49) wrappedNode.getName() ==> com.github.javaparser.ast.nodeTypes.NodeWithSimpleName.getName()
  Line 343) methodUsage.getDeclaration() ==> com.github.javaparser.symbolsolver.model.methods.MethodUsage.getDeclaration()
  Line 51) wrappedNode.getName().getId() ==> com.github.javaparser.ast.nodeTypes.NodeWithIdentifier.getId()
  Line 344) actualParamTypes.size() ==> java.util.List.size()
  Line 140) JavaParserFactory.getContext(node, typeSolver) ==> com.github.javaparser.symbolsolver.javaparsermodel.JavaParserFactory.getContext(com.github.javaparser.ast.Node, com.github.javaparser.symbolsolver.model.resolution.TypeSolver)
  Line 344) methodUsage.getDeclaration().getNumberOfParams() ==> com.github.javaparser.symbolsolver.model.declarations.MethodLikeDeclaration.getNumberOfParams()
  Line 146) node.getType() ==> com.github.javaparser.ast.expr.ClassExpr.getType()
  Line 344) methodUsage.getDeclaration() ==> com.github.javaparser.symbolsolver.model.methods.MethodUsage.getDeclaration()
  Line 347) methodUsage.getDeclaration().getLastParam().getType().asArrayType().getComponentType() ==> com.github.javaparser.symbolsolver.model.typesystem.ArrayType.getComponentType()
  Line 347) methodUsage.getDeclaration().getLastParam().getType().asArrayType() ==> com.github.javaparser.symbolsolver.model.typesystem.Type.asArrayType()
  Line 51) wrappedNode.getName() ==> com.github.javaparser.ast.nodeTypes.NodeWithSimpleName.getName()
  Line 347) methodUsage.getDeclaration().getLastParam().getType() ==> com.github.javaparser.symbolsolver.model.declarations.ValueDeclaration.getType()
  Line 347) methodUsage.getDeclaration().getLastParam() ==> com.github.javaparser.symbolsolver.model.declarations.MethodLikeDeclaration.getLastParam()
  Line 347) methodUsage.getDeclaration() ==> com.github.javaparser.symbolsolver.model.methods.MethodUsage.getDeclaration()
  Line 56) other.getAllAncestors() ==> com.github.javaparser.symbolsolver.model.declarations.ReferenceTypeDeclaration.getAllAncestors()
  Line 57) ancestorsOfOther.add(new ReferenceTypeImpl(other, typeSolver)) ==> java.util.List.add(E)
  Line 350) actualParamTypes.get(actualParamTypes.size() - 1).isArray() ==> com.github.javaparser.symbolsolver.model.typesystem.Type.isArray()
  Line 350) actualParamTypes.get(actualParamTypes.size() - 1) ==> java.util.List.get(int)
  Line 350) actualParamTypes.size() ==> java.util.List.size()
  Line 351) actualParamTypes.get(actualParamTypes.size() - 1).asArrayType().getComponentType() ==> com.github.javaparser.symbolsolver.model.typesystem.ArrayType.getComponentType()
  Line 351) actualParamTypes.get(actualParamTypes.size() - 1).asArrayType() ==> com.github.javaparser.symbolsolver.model.typesystem.Type.asArrayType()
  Line 351) actualParamTypes.get(actualParamTypes.size() - 1) ==> java.util.List.get(int)
  Line 59) ancestorOfOther.getQualifiedName().equals(this.getQualifiedName()) ==> java.lang.String.equals(java.lang.Object)
  Line 59) ancestorOfOther.getQualifiedName() ==> com.github.javaparser.symbolsolver.model.typesystem.ReferenceType.getQualifiedName()
  Line 59) this.getQualifiedName() ==> com.github.javaparser.symbolsolver.javaparsermodel.declarations.JavaParserTypeAdapter.getQualifiedName()
  Line 67) type.isNull() ==> com.github.javaparser.symbolsolver.model.typesystem.Type.isNull()
  Line 70) type.isReferenceType() ==> com.github.javaparser.symbolsolver.model.typesystem.Type.isReferenceType()
  Line 71) typeSolver.solveType(type.describe()) ==> com.github.javaparser.symbolsolver.model.resolution.TypeSolver.solveType(java.lang.String)
  Line 71) type.describe() ==> com.github.javaparser.symbolsolver.model.typesystem.Type.describe()
  Line 351) actualParamTypes.size() ==> java.util.List.size()
  Line 352) actualParamTypes.get(actualParamTypes.size() - 1) ==> java.util.List.get(int)
  Line 72) isAssignableBy(other) ==> com.github.javaparser.symbolsolver.javaparsermodel.declarations.JavaParserTypeAdapter.isAssignableBy(com.github.javaparser.symbolsolver.model.declarations.ReferenceTypeDeclaration)
  Line 352) actualParamTypes.size() ==> java.util.List.size()
  Line 353) expectedType.isAssignableBy(actualType) ==> com.github.javaparser.symbolsolver.model.typesystem.Type.isAssignableBy(com.github.javaparser.symbolsolver.model.typesystem.Type)
  Line 79) this.wrappedNode.getTypeParameters() ==> com.github.javaparser.ast.nodeTypes.NodeWithTypeParameters.getTypeParameters()
  Line 354) methodUsage.getDeclaration().getTypeParameters() ==> com.github.javaparser.symbolsolver.model.declarations.TypeParametrizable.getTypeParameters()
  Line 354) methodUsage.getDeclaration() ==> com.github.javaparser.symbolsolver.model.methods.MethodUsage.getDeclaration()
  Line 80) this.wrappedNode.getTypeParameters() ==> com.github.javaparser.ast.nodeTypes.NodeWithTypeParameters.getTypeParameters()
  Line 355) MethodResolutionLogic.replaceTypeParam(expectedType, tp, typeSolver) ==> com.github.javaparser.symbolsolver.resolution.MethodResolutionLogic.replaceTypeParam(com.github.javaparser.symbolsolver.model.typesystem.Type, com.github.javaparser.symbolsolver.model.declarations.TypeParameterDeclaration, com.github.javaparser.symbolsolver.model.resolution.TypeSolver)
  Line 358) expectedType.isAssignableBy(actualType) ==> com.github.javaparser.symbolsolver.model.typesystem.Type.isAssignableBy(com.github.javaparser.symbolsolver.model.typesystem.Type)
  Line 361) String.format("Unable to resolve the type typeParametersValues in a MethodUsage. Expected type: %s, Actual type: %s. Method Declaration: %s. MethodUsage: %s", expectedType, actualType, methodUsage.getDeclaration(), methodUsage) ==> java.lang.String.format(java.lang.String, java.lang.Object...)
  Line 364) methodUsage.getDeclaration() ==> com.github.javaparser.symbolsolver.model.methods.MethodUsage.getDeclaration()
  Line 81) typeParameter.getName().getId().equals(name) ==> java.lang.String.equals(java.lang.Object)
  Line 81) typeParameter.getName().getId() ==> com.github.javaparser.ast.nodeTypes.NodeWithIdentifier.getId()
  Line 81) typeParameter.getName() ==> com.github.javaparser.ast.type.TypeParameter.getName()
  Line 82) SymbolReference.solved(new JavaParserTypeVariableDeclaration(typeParameter, typeSolver)) ==> com.github.javaparser.symbolsolver.model.resolution.SymbolReference.solved(S2)
  Line 368) matchTypeParameters(expectedType, actualType, matchedTypeParameters) ==> com.github.javaparser.symbolsolver.javaparsermodel.contexts.MethodCallExprContext.matchTypeParameters(com.github.javaparser.symbolsolver.model.typesystem.Type, com.github.javaparser.symbolsolver.model.typesystem.Type, java.util.Map<com.github.javaparser.symbolsolver.model.declarations.TypeParameterDeclaration, com.github.javaparser.symbolsolver.model.typesystem.Type>)
  Line 374) methodUsage.getDeclaration().hasVariadicParameter() ==> com.github.javaparser.symbolsolver.model.declarations.MethodLikeDeclaration.hasVariadicParameter()
  Line 88) this.wrappedNode.getMembers() ==> com.github.javaparser.ast.nodeTypes.NodeWithMembers.getMembers()
  Line 374) methodUsage.getDeclaration() ==> com.github.javaparser.symbolsolver.model.methods.MethodUsage.getDeclaration()
  Line 375) actualParamTypes.size() ==> java.util.List.size()
  Line 376) actualParamTypes.size() ==> java.util.List.size()
  Line 91) internalType.getName() ==> com.github.javaparser.ast.body.TypeDeclaration.getName()
  Line 379) methodUsage.getParamType(i) ==> com.github.javaparser.symbolsolver.model.methods.MethodUsage.getParamType(int)
  Line 380) actualParamTypes.get(i) ==> java.util.List.get(int)
  Line 147) facade.convertToUsage(astType, node.getType()) ==> com.github.javaparser.symbolsolver.javaparsermodel.JavaParserFacade.convertToUsage(com.github.javaparser.ast.type.Type, com.github.javaparser.ast.Node)
  Line 147) node.getType() ==> com.github.javaparser.ast.expr.ClassExpr.getType()
  Line 92) internalType.getName().getId().equals(name) ==> java.lang.String.equals(java.lang.Object)
  Line 92) internalType.getName().getId() ==> com.github.javaparser.ast.nodeTypes.NodeWithIdentifier.getId()
  Line 381) matchTypeParameters(expectedType, actualType, matchedTypeParameters) ==> com.github.javaparser.symbolsolver.javaparsermodel.contexts.MethodCallExprContext.matchTypeParameters(com.github.javaparser.symbolsolver.model.typesystem.Type, com.github.javaparser.symbolsolver.model.typesystem.Type, java.util.Map<com.github.javaparser.symbolsolver.model.declarations.TypeParameterDeclaration, com.github.javaparser.symbolsolver.model.typesystem.Type>)
  Line 92) internalType.getName() ==> com.github.javaparser.ast.body.TypeDeclaration.getName()
  Line 94) SymbolReference.solved(new JavaParserClassDeclaration((com.github.javaparser.ast.body.ClassOrInterfaceDeclaration) internalType, typeSolver)) ==> com.github.javaparser.symbolsolver.model.resolution.SymbolReference.solved(S2)
  Line 96) SymbolReference.solved(new JavaParserEnumDeclaration((com.github.javaparser.ast.body.EnumDeclaration) internalType, typeSolver)) ==> com.github.javaparser.symbolsolver.model.resolution.SymbolReference.solved(S2)
  Line 148) ImmutableList.of(jssType) ==> com.google.common.collect.ImmutableList.of(E)
  Line 100) name.startsWith(prefix) ==> java.lang.String.startsWith(java.lang.String)
  Line 383) matchedTypeParameters.keySet() ==> java.util.Map.keySet()
  Line 384) methodUsage.replaceTypeParameter(tp, matchedTypeParameters.get(tp)) ==> com.github.javaparser.symbolsolver.model.methods.MethodUsage.replaceTypeParameter(com.github.javaparser.symbolsolver.model.declarations.TypeParameterDeclaration, com.github.javaparser.symbolsolver.model.typesystem.Type)
  Line 384) matchedTypeParameters.get(tp) ==> java.util.Map.get(java.lang.Object)
  Line 390) expectedType.isTypeVariable() ==> com.github.javaparser.symbolsolver.model.typesystem.Type.isTypeVariable()
  Line 391) actualType.isTypeVariable() ==> com.github.javaparser.symbolsolver.model.typesystem.Type.isTypeVariable()
  Line 391) actualType.isReferenceType() ==> com.github.javaparser.symbolsolver.model.typesystem.Type.isReferenceType()
  Line 392) actualType.getClass().getCanonicalName() ==> java.lang.Class.getCanonicalName()
  Line 392) actualType.getClass() ==> java.lang.Object.getClass()
  Line 100) name.length() ==> java.lang.String.length()
  Line 394) matchedTypeParameters.put(expectedType.asTypeParameter(), actualType) ==> java.util.Map.put(K, V)
  Line 394) expectedType.asTypeParameter() ==> com.github.javaparser.symbolsolver.model.typesystem.Type.asTypeParameter()
  Line 100) prefix.length() ==> java.lang.String.length()
  Line 395) expectedType.isArray() ==> com.github.javaparser.symbolsolver.model.typesystem.Type.isArray()
  Line 396) actualType.isArray() ==> com.github.javaparser.symbolsolver.model.typesystem.Type.isArray()
  Line 397) actualType.getClass().getCanonicalName() ==> java.lang.Class.getCanonicalName()
  Line 153) node.getThenExpr().accept(this, solveLambdas) ==> com.github.javaparser.ast.visitor.Visitable.accept(com.github.javaparser.ast.visitor.GenericVisitor<R, A>, A)
  Line 397) actualType.getClass() ==> java.lang.Object.getClass()
  Line 153) node.getThenExpr() ==> com.github.javaparser.ast.expr.ConditionalExpr.getThenExpr()
  Line 399) matchTypeParameters(expectedType.asArrayType().getComponentType(), actualType.asArrayType().getComponentType(), matchedTypeParameters) ==> com.github.javaparser.symbolsolver.javaparsermodel.contexts.MethodCallExprContext.matchTypeParameters(com.github.javaparser.symbolsolver.model.typesystem.Type, com.github.javaparser.symbolsolver.model.typesystem.Type, java.util.Map<com.github.javaparser.symbolsolver.model.declarations.TypeParameterDeclaration, com.github.javaparser.symbolsolver.model.typesystem.Type>)
  Line 400) expectedType.asArrayType().getComponentType() ==> com.github.javaparser.symbolsolver.model.typesystem.ArrayType.getComponentType()
  Line 400) expectedType.asArrayType() ==> com.github.javaparser.symbolsolver.model.typesystem.Type.asArrayType()
  Line 401) actualType.asArrayType().getComponentType() ==> com.github.javaparser.symbolsolver.model.typesystem.ArrayType.getComponentType()
  Line 401) actualType.asArrayType() ==> com.github.javaparser.symbolsolver.model.typesystem.Type.asArrayType()
  Line 403) expectedType.isReferenceType() ==> com.github.javaparser.symbolsolver.model.typesystem.Type.isReferenceType()
  Line 102) new JavaParserClassDeclaration((com.github.javaparser.ast.body.ClassOrInterfaceDeclaration) internalType, typeSolver).solveType(name.substring(prefix.length()), typeSolver) ==> com.github.javaparser.symbolsolver.javaparsermodel.declarations.JavaParserClassDeclaration.solveType(java.lang.String, com.github.javaparser.symbolsolver.model.resolution.TypeSolver)
  Line 405) actualType.asReferenceType().typeParametersValues().size() ==> java.util.List.size()
  Line 405) actualType.asReferenceType().typeParametersValues() ==> com.github.javaparser.symbolsolver.model.typesystem.ReferenceType.typeParametersValues()
  Line 405) actualType.asReferenceType() ==> com.github.javaparser.symbolsolver.model.typesystem.Type.asReferenceType()
  Line 102) name.substring(prefix.length()) ==> java.lang.String.substring(int)
  Line 102) prefix.length() ==> java.lang.String.length()
  Line 407) expectedType.asReferenceType().typeParametersValues() ==> com.github.javaparser.symbolsolver.model.typesystem.ReferenceType.typeParametersValues()
  Line 407) expectedType.asReferenceType() ==> com.github.javaparser.symbolsolver.model.typesystem.Type.asReferenceType()
  Line 158) node.getInner().accept(this, solveLambdas) ==> com.github.javaparser.ast.visitor.Visitable.accept(com.github.javaparser.ast.visitor.GenericVisitor<R, A>, A)
  Line 104) new SymbolSolver(typeSolver).solveTypeInType(new JavaParserEnumDeclaration((com.github.javaparser.ast.body.EnumDeclaration) internalType, typeSolver), name.substring(prefix.length())) ==> com.github.javaparser.symbolsolver.resolution.SymbolSolver.solveTypeInType(com.github.javaparser.symbolsolver.model.declarations.TypeDeclaration, java.lang.String)
  Line 158) node.getInner() ==> com.github.javaparser.ast.expr.EnclosedExpr.getInner()
  Line 104) name.substring(prefix.length()) ==> java.lang.String.substring(int)
  Line 408) matchTypeParameters(tp, actualType.asReferenceType().typeParametersValues().get(i), matchedTypeParameters) ==> com.github.javaparser.symbolsolver.javaparsermodel.contexts.MethodCallExprContext.matchTypeParameters(com.github.javaparser.symbolsolver.model.typesystem.Type, com.github.javaparser.symbolsolver.model.typesystem.Type, java.util.Map<com.github.javaparser.symbolsolver.model.declarations.TypeParameterDeclaration, com.github.javaparser.symbolsolver.model.typesystem.Type>)
  Line 408) actualType.asReferenceType().typeParametersValues().get(i) ==> java.util.List.get(int)
  Line 408) actualType.asReferenceType().typeParametersValues() ==> com.github.javaparser.symbolsolver.model.typesystem.ReferenceType.typeParametersValues()
  Line 408) actualType.asReferenceType() ==> com.github.javaparser.symbolsolver.model.typesystem.Type.asReferenceType()
  Line 104) prefix.length() ==> java.lang.String.length()
  Line 168) parentType.hasField(node.getName().getId()) ==> com.github.javaparser.symbolsolver.model.declarations.ReferenceTypeDeclaration.hasField(java.lang.String)
  Line 168) node.getName().getId() ==> com.github.javaparser.ast.nodeTypes.NodeWithIdentifier.getId()
  Line 111) SymbolReference.unsolved(TypeDeclaration.class) ==> com.github.javaparser.symbolsolver.model.resolution.SymbolReference.unsolved(java.lang.Class<S2>)
  Line 168) node.getName() ==> com.github.javaparser.ast.expr.FieldAccessExpr.getName()
  Line 413) expectedType.isPrimitive() ==> com.github.javaparser.symbolsolver.model.typesystem.Type.isPrimitive()
  Line 415) expectedType.isWildcard() ==> com.github.javaparser.symbolsolver.model.typesystem.Type.isWildcard()
  Line 418) expectedType.getClass().getCanonicalName() ==> java.lang.Class.getCanonicalName()
  Line 418) expectedType.getClass() ==> java.lang.Object.getClass()
  Line 169) parentType.getField(node.getName().getId()).getType() ==> com.github.javaparser.symbolsolver.model.declarations.ValueDeclaration.getType()
  Line 169) parentType.getField(node.getName().getId()) ==> com.github.javaparser.symbolsolver.model.declarations.ReferenceTypeDeclaration.getField(java.lang.String)
  Line 423) tp.asTypeParameter().getBounds(typeSolver) ==> com.github.javaparser.symbolsolver.model.declarations.TypeParameterDeclaration.getBounds(com.github.javaparser.symbolsolver.model.resolution.TypeSolver)
  Line 169) node.getName().getId() ==> com.github.javaparser.ast.nodeTypes.NodeWithIdentifier.getId()
  Line 423) tp.asTypeParameter() ==> com.github.javaparser.symbolsolver.model.typesystem.TypeVariable.asTypeParameter()
  Line 169) node.getName() ==> com.github.javaparser.ast.expr.FieldAccessExpr.getName()
  Line 170) parentType.hasInternalType(node.getName().getId()) ==> com.github.javaparser.symbolsolver.model.declarations.TypeDeclaration.hasInternalType(java.lang.String)
  Line 170) node.getName().getId() ==> com.github.javaparser.ast.nodeTypes.NodeWithIdentifier.getId()
  Line 170) node.getName() ==> com.github.javaparser.ast.expr.FieldAccessExpr.getName()
  Line 171) parentType.getInternalType(node.getName().getId()) ==> com.github.javaparser.symbolsolver.model.declarations.TypeDeclaration.getInternalType(java.lang.String)
  Line 171) node.getName().getId() ==> com.github.javaparser.ast.nodeTypes.NodeWithIdentifier.getId()
  Line 171) node.getName() ==> com.github.javaparser.ast.expr.FieldAccessExpr.getName()
  Line 115) wrappedNode.getParentNode() ==> com.github.javaparser.ast.Node.getParentNode()
  Line 173) node.getName().getId() ==> com.github.javaparser.ast.nodeTypes.NodeWithIdentifier.getId()
  Line 116) parent.isPresent() ==> java.util.Optional.isPresent()
  Line 173) node.getName() ==> com.github.javaparser.ast.expr.FieldAccessExpr.getName()
  Line 180) node.getScope() ==> com.github.javaparser.ast.expr.FieldAccessExpr.getScope()
  Line 181) node.getScope() ==> com.github.javaparser.ast.expr.FieldAccessExpr.getScope()
  Line 182) node.getScope() ==> com.github.javaparser.ast.expr.FieldAccessExpr.getScope()
  Line 117) Optional.of(JavaParserFactory.toTypeDeclaration(parent.get(), typeSolver)) ==> java.util.Optional.of(T)
  Line 424) solveMethodAsUsage(bound.getType(), name, argumentsTypes, typeSolver, invokationContext) ==> com.github.javaparser.symbolsolver.javaparsermodel.contexts.MethodCallExprContext.solveMethodAsUsage(com.github.javaparser.symbolsolver.model.typesystem.Type, java.lang.String, java.util.List<com.github.javaparser.symbolsolver.model.typesystem.Type>, com.github.javaparser.symbolsolver.model.resolution.TypeSolver, com.github.javaparser.symbolsolver.core.resolution.Context)
  Line 424) bound.getType() ==> com.github.javaparser.symbolsolver.model.declarations.TypeParameterDeclaration.Bound.getType()
  Line 425) methodUsage.isPresent() ==> java.util.Optional.isPresent()
  Line 429) Optional.empty() ==> java.util.Optional.empty()
  Line 434) solveMethodAsUsage((ReferenceType) type, name, argumentsTypes, typeSolver, invokationContext) ==> com.github.javaparser.symbolsolver.javaparsermodel.contexts.MethodCallExprContext.solveMethodAsUsage(com.github.javaparser.symbolsolver.model.typesystem.ReferenceType, java.lang.String, java.util.List<com.github.javaparser.symbolsolver.model.typesystem.Type>, com.github.javaparser.symbolsolver.model.resolution.TypeSolver, com.github.javaparser.symbolsolver.core.resolution.Context)
  Line 117) JavaParserFactory.toTypeDeclaration(parent.get(), typeSolver) ==> com.github.javaparser.symbolsolver.javaparsermodel.JavaParserFactory.toTypeDeclaration(com.github.javaparser.ast.Node, com.github.javaparser.symbolsolver.model.resolution.TypeSolver)
  Line 117) parent.get() ==> java.util.Optional.get()
  Line 183) JavaParserFactory.getContext(node, typeSolver).solveType(staticValue.toString(), typeSolver) ==> com.github.javaparser.symbolsolver.core.resolution.Context.solveType(java.lang.String, com.github.javaparser.symbolsolver.model.resolution.TypeSolver)
  Line 118) Optional.empty() ==> java.util.Optional.empty()
