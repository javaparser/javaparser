  Line 632) sourceRefType.isRawType() ==> com.github.javaparser.symbolsolver.model.typesystem.ReferenceType.isRawType()
  Line 121) ctMethod.getGenericSignature() ==> javassist.CtBehavior.getGenericSignature()
  Line 632) targetRefType.isRawType() ==> com.github.javaparser.symbolsolver.model.typesystem.ReferenceType.isRawType()
  Line 633) sourceRefType.typeParametersValues().size() ==> java.util.List.size()
  Line 122) SignatureAttribute.toMethodSignature(ctMethod.getGenericSignature()) ==> javassist.bytecode.SignatureAttribute.toMethodSignature(java.lang.String)
  Line 633) sourceRefType.typeParametersValues() ==> com.github.javaparser.symbolsolver.model.typesystem.ReferenceType.typeParametersValues()
  Line 122) ctMethod.getGenericSignature() ==> javassist.CtBehavior.getGenericSignature()
  Line 123) methodSignature.getParameterTypes() ==> javassist.bytecode.SignatureAttribute.MethodSignature.getParameterTypes()
  Line 124) JavassistUtils.signatureTypeToType(signatureType, typeSolver, this) ==> com.github.javaparser.symbolsolver.javassistmodel.JavassistUtils.signatureTypeToType(javassist.bytecode.SignatureAttribute.Type, com.github.javaparser.symbolsolver.model.resolution.TypeSolver, com.github.javaparser.symbolsolver.model.declarations.TypeParametrizable)
  Line 161) SymbolReference.unsolved(ConstructorDeclaration.class) ==> com.github.javaparser.symbolsolver.model.resolution.SymbolReference.unsolved(java.lang.Class<S2>)
  Line 126) ctMethod.getParameterTypes() ==> javassist.CtBehavior.getParameterTypes()
  Line 634) inferTypes(sourceRefType.typeParametersValues().get(i), targetRefType.typeParametersValues().get(i), mappings) ==> com.github.javaparser.symbolsolver.resolution.MethodResolutionLogic.inferTypes(com.github.javaparser.symbolsolver.model.typesystem.Type, com.github.javaparser.symbolsolver.model.typesystem.Type, java.util.Map<com.github.javaparser.symbolsolver.model.declarations.TypeParameterDeclaration, com.github.javaparser.symbolsolver.model.typesystem.Type>)
  Line 634) sourceRefType.typeParametersValues().get(i) ==> java.util.List.get(int)
  Line 98) ReflectionMethodResolutionLogic.solveMethod(name, parameterTypes, staticOnly, typeSolver, this, clazz) ==> com.github.javaparser.symbolsolver.reflectionmodel.ReflectionMethodResolutionLogic.solveMethod(java.lang.String, java.util.List<com.github.javaparser.symbolsolver.model.typesystem.Type>, boolean, com.github.javaparser.symbolsolver.model.resolution.TypeSolver, com.github.javaparser.symbolsolver.model.declarations.ReferenceTypeDeclaration, java.lang.Class)
  Line 634) sourceRefType.typeParametersValues() ==> com.github.javaparser.symbolsolver.model.typesystem.ReferenceType.typeParametersValues()
  Line 634) targetRefType.typeParametersValues().get(i) ==> java.util.List.get(int)
  Line 140) new MethodDeclarationCommonLogic(this, typeSolver).resolveTypeVariables(context, parameterTypes) ==> com.github.javaparser.symbolsolver.declarations.common.MethodDeclarationCommonLogic.resolveTypeVariables(com.github.javaparser.symbolsolver.core.resolution.Context, java.util.List<com.github.javaparser.symbolsolver.model.typesystem.Type>)
  Line 634) targetRefType.typeParametersValues() ==> com.github.javaparser.symbolsolver.model.typesystem.ReferenceType.typeParametersValues()
  Line 145) Modifier.isAbstract(ctMethod.getModifiers()) ==> java.lang.reflect.Modifier.isAbstract(int)
  Line 105) clazz.getCanonicalName() ==> java.lang.Class.getCanonicalName()
  Line 640) source.isReferenceType() ==> com.github.javaparser.symbolsolver.model.typesystem.Type.isReferenceType()
  Line 145) ctMethod.getModifiers() ==> javassist.CtBehavior.getModifiers()
  Line 151) ctMethod.getGenericSignature() ==> javassist.CtBehavior.getGenericSignature()
  Line 152) Collections.emptyList() ==> java.util.Collections.emptyList()
  Line 152) wrappedNode.getExtendedTypes() ==> com.github.javaparser.ast.body.ClassOrInterfaceDeclaration.getExtendedTypes()
  Line 153) object() ==> com.github.javaparser.symbolsolver.javaparsermodel.declarations.JavaParserClassDeclaration.object()
  Line 163) optAncestor.get() ==> java.util.Optional.get()
  Line 165) explicitConstructorInvocationStmt.isThis() ==> com.github.javaparser.ast.stmt.ExplicitConstructorInvocationStmt.isThis()
  Line 640) target.isWildcard() ==> com.github.javaparser.symbolsolver.model.typesystem.Type.isWildcard()
  Line 154) SignatureAttribute.toMethodSignature(ctMethod.getGenericSignature()) ==> javassist.bytecode.SignatureAttribute.toMethodSignature(java.lang.String)
  Line 154) ctMethod.getGenericSignature() ==> javassist.CtBehavior.getGenericSignature()
  Line 120) clazz.getCanonicalName().equals(that.clazz.getCanonicalName()) ==> java.lang.String.equals(java.lang.Object)
  Line 120) clazz.getCanonicalName() ==> java.lang.Class.getCanonicalName()
  Line 120) that.clazz.getCanonicalName() ==> java.lang.Class.getCanonicalName()
  Line 122) getTypeParameters().equals(that.getTypeParameters()) ==> java.util.List.equals(java.lang.Object)
  Line 641) target.asWildcard().isBounded() ==> com.github.javaparser.symbolsolver.model.typesystem.Wildcard.isBounded()
  Line 122) getTypeParameters() ==> com.github.javaparser.symbolsolver.reflectionmodel.ReflectionInterfaceDeclaration.getTypeParameters()
  Line 155) toReferenceType(wrappedNode.getExtendedTypes().get(0)) ==> com.github.javaparser.symbolsolver.javaparsermodel.declarations.JavaParserClassDeclaration.toReferenceType(com.github.javaparser.ast.type.ClassOrInterfaceType)
  Line 122) that.getTypeParameters() ==> com.github.javaparser.symbolsolver.reflectionmodel.ReflectionInterfaceDeclaration.getTypeParameters()
  Line 155) wrappedNode.getExtendedTypes().get(0) ==> com.github.javaparser.ast.NodeList.get(int)
  Line 155) wrappedNode.getExtendedTypes() ==> com.github.javaparser.ast.body.ClassOrInterfaceDeclaration.getExtendedTypes()
  Line 131) clazz.hashCode() ==> java.lang.Object.hashCode()
  Line 641) target.asWildcard() ==> com.github.javaparser.symbolsolver.model.typesystem.Type.asWildcard()
  Line 162) wrappedNode.getImplementedTypes() ==> com.github.javaparser.ast.body.ClassOrInterfaceDeclaration.getImplementedTypes()
  Line 642) inferTypes(source, target.asWildcard().getBoundedType(), mappings) ==> com.github.javaparser.symbolsolver.resolution.MethodResolutionLogic.inferTypes(com.github.javaparser.symbolsolver.model.typesystem.Type, com.github.javaparser.symbolsolver.model.typesystem.Type, java.util.Map<com.github.javaparser.symbolsolver.model.declarations.TypeParameterDeclaration, com.github.javaparser.symbolsolver.model.typesystem.Type>)
  Line 642) target.asWildcard().getBoundedType() ==> com.github.javaparser.symbolsolver.model.typesystem.Wildcard.getBoundedType()
  Line 642) target.asWildcard() ==> com.github.javaparser.symbolsolver.model.typesystem.Type.asWildcard()
  Line 647) source.isWildcard() ==> com.github.javaparser.symbolsolver.model.typesystem.Type.isWildcard()
  Line 647) target.isWildcard() ==> com.github.javaparser.symbolsolver.model.typesystem.Type.isWildcard()
  Line 650) source.isReferenceType() ==> com.github.javaparser.symbolsolver.model.typesystem.Type.isReferenceType()
  Line 49) name.contains(".") ==> java.lang.String.contains(java.lang.CharSequence)
  Line 650) target.isTypeVariable() ==> com.github.javaparser.symbolsolver.model.typesystem.Type.isTypeVariable()
  Line 155) Arrays.stream(methodSignature.getTypeParameters()).map((jasTp) -> new JavassistTypeParameter(jasTp, this, typeSolver)).collect(Collectors.toList()) ==> java.util.stream.Stream.collect(java.util.stream.Collector<? super T, A, R>)
  Line 155) Arrays.stream(methodSignature.getTypeParameters()).map((jasTp) -> new JavassistTypeParameter(jasTp, this, typeSolver)) ==> java.util.stream.Stream.map(java.util.function.Function<? super T, ? extends R>)
  Line 155) Arrays.stream(methodSignature.getTypeParameters()) ==> java.util.Arrays.stream(T[])
  Line 155) methodSignature.getTypeParameters() ==> javassist.bytecode.SignatureAttribute.MethodSignature.getTypeParameters()
  Line 155) Collectors.toList() ==> java.util.stream.Collectors.toList()
  Line 69) itName.contains(".") ==> java.lang.String.contains(java.lang.CharSequence)
  Line 70) getType(itName) ==> com.github.javaparser.symbolsolver.javaparsermodel.contexts.CompilationUnitContext.getType(java.lang.String)
  Line 163) wrappedNode.getImplementedTypes() ==> com.github.javaparser.ast.body.ClassOrInterfaceDeclaration.getImplementedTypes()
  Line 135) ReflectionMethodResolutionLogic.solveMethodAsUsage(name, parameterTypes, typeSolver, invokationContext, typeParameterValues, this, clazz) ==> com.github.javaparser.symbolsolver.reflectionmodel.ReflectionMethodResolutionLogic.solveMethodAsUsage(java.lang.String, java.util.List<com.github.javaparser.symbolsolver.model.typesystem.Type>, com.github.javaparser.symbolsolver.model.resolution.TypeSolver, com.github.javaparser.symbolsolver.core.resolution.Context, java.util.List<com.github.javaparser.symbolsolver.model.typesystem.Type>, com.github.javaparser.symbolsolver.model.declarations.ReferenceTypeDeclaration, java.lang.Class)
  Line 651) mappings.put(target.asTypeParameter(), source) ==> java.util.Map.put(K, V)
  Line 166) JavaParserFacade.get(typeSolver).convert(classNode.getExtendedTypes(0), classNode) ==> UNSOLVED
