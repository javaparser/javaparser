  Line 36) AbstractJavaParserContext.solveWith(sb, name) ==> com.github.javaparser.symbolsolver.javaparsermodel.contexts.AbstractJavaParserContext.solveWith(com.github.javaparser.symbolsolver.resolution.SymbolDeclarator, java.lang.String)
  Line 230) this.ctClass.getSuperclass() ==> javassist.CtClass.getSuperclass()
  Line 52) res.add(new ArrayType(componentType)) ==> java.util.List.add(E)
  Line 58) variadicValues.isEmpty() ==> java.util.List.isEmpty()
  Line 62) variadicValues.get(0) ==> java.util.List.get(int)
  Line 37) symbolReference.isSolved() ==> com.github.javaparser.symbolsolver.model.resolution.SymbolReference.isSolved()
  Line 43) getParent().solveSymbol(name, typeSolver) ==> com.github.javaparser.symbolsolver.core.resolution.Context.solveSymbol(java.lang.String, com.github.javaparser.symbolsolver.model.resolution.TypeSolver)
  Line 43) getParent() ==> com.github.javaparser.symbolsolver.javaparsermodel.contexts.AbstractJavaParserContext.getParent()
  Line 48) wrappedNode.getTypeParameters() ==> com.github.javaparser.ast.nodeTypes.NodeWithTypeParameters.getTypeParameters()
  Line 66) isApplicable(method, name, argumentsTypes, typeSolver, false) ==> com.github.javaparser.symbolsolver.resolution.MethodResolutionLogic.isApplicable(com.github.javaparser.symbolsolver.model.declarations.MethodDeclaration, java.lang.String, java.util.List<com.github.javaparser.symbolsolver.model.typesystem.Type>, com.github.javaparser.symbolsolver.model.resolution.TypeSolver, boolean)
  Line 233) ctClass.getInterfaces() ==> javassist.CtClass.getInterfaces()
  Line 123) node.getClass() ==> java.lang.Object.getClass()
  Line 70) method.getName().equals(name) ==> java.lang.String.equals(java.lang.Object)
  Line 44) inferenceVariableTypeMap.containsKey(tp.getName()) ==> java.util.Map.containsKey(java.lang.Object)
  Line 70) method.getName() ==> com.github.javaparser.symbolsolver.model.declarations.Declaration.getName()
  Line 44) tp.getName() ==> com.github.javaparser.symbolsolver.model.declarations.TypeParameterDeclaration.getName()
  Line 234) new JavassistInterfaceDeclaration(interfaze, typeSolver).isAssignableBy(type) ==> com.github.javaparser.symbolsolver.javassistmodel.JavassistInterfaceDeclaration.isAssignableBy(com.github.javaparser.symbolsolver.model.typesystem.Type)
  Line 73) method.hasVariadicParameter() ==> com.github.javaparser.symbolsolver.model.declarations.MethodLikeDeclaration.hasVariadicParameter()
  Line 74) method.getNumberOfParams() ==> com.github.javaparser.symbolsolver.model.declarations.MethodLikeDeclaration.getNumberOfParams()
  Line 251) javassistTypeDeclarationAdapter.getDeclaredFields() ==> com.github.javaparser.symbolsolver.javassistmodel.JavassistTypeDeclarationAdapter.getDeclaredFields()
  Line 75) method.getNumberOfParams() ==> com.github.javaparser.symbolsolver.model.declarations.MethodLikeDeclaration.getNumberOfParams()
  Line 46) inferenceVariableTypes.add(inferenceVariableType) ==> java.util.List.add(E)
  Line 49) tp.getName().getId().equals(name) ==> java.lang.String.equals(java.lang.Object)
  Line 49) tp.getName().getId() ==> com.github.javaparser.ast.nodeTypes.NodeWithIdentifier.getId()
  Line 49) tp.getName() ==> com.github.javaparser.ast.type.TypeParameter.getName()
  Line 256) ctClass.getSimpleName().replace('$', '.').split("\\.") ==> java.lang.String.split(java.lang.String)
  Line 256) ctClass.getSimpleName().replace('$', '.') ==> java.lang.String.replace(char, char)
  Line 50) Optional.of(new TypeVariable(new JavaParserTypeParameter(tp, typeSolver))) ==> java.util.Optional.of(T)
  Line 256) ctClass.getSimpleName() ==> javassist.CtClass.getSimpleName()
  Line 53) super.solveGenericType(name, typeSolver) ==> com.github.javaparser.symbolsolver.javaparsermodel.contexts.AbstractJavaParserContext.solveGenericType(java.lang.String, com.github.javaparser.symbolsolver.model.resolution.TypeSolver)
  Line 47) inferenceVariableType.setCorrespondingTp(tp) ==> com.github.javaparser.symbolsolver.logic.InferenceVariableType.setCorrespondingTp(com.github.javaparser.symbolsolver.model.declarations.TypeParameterDeclaration)
  Line 58) wrappedNode.getParameters() ==> com.github.javaparser.ast.nodeTypes.NodeWithParameters.getParameters()
  Line 48) inferenceVariableTypeMap.put(tp.getName(), inferenceVariableType) ==> java.util.Map.put(K, V)
  Line 69) typeParametersMapBuilder.setValue(typeDeclaration.getTypeParameters().get(i), typeParameters.get(i)) ==> com.github.javaparser.symbolsolver.model.typesystem.parametrization.TypeParametersMap.Builder.setValue(com.github.javaparser.symbolsolver.model.declarations.TypeParameterDeclaration, com.github.javaparser.symbolsolver.model.typesystem.Type)
  Line 69) typeDeclaration.getTypeParameters().get(i) ==> java.util.List.get(int)
  Line 167) methodCallExpr.getName().getId().equals(methodName) ==> java.lang.String.equals(java.lang.Object)
  Line 48) tp.getName() ==> com.github.javaparser.symbolsolver.model.declarations.TypeParameterDeclaration.getName()
  Line 69) typeDeclaration.getTypeParameters() ==> com.github.javaparser.symbolsolver.model.declarations.TypeParametrizable.getTypeParameters()
  Line 69) typeParameters.get(i) ==> java.util.List.get(int)
  Line 122) JavaParserFacade.get(typeSolver).getType(node) ==> com.github.javaparser.symbolsolver.javaparsermodel.JavaParserFacade.getType(com.github.javaparser.ast.Node)
  Line 75) argumentsTypes.size() ==> java.util.List.size()
  Line 122) JavaParserFacade.get(typeSolver) ==> com.github.javaparser.symbolsolver.javaparsermodel.JavaParserFacade.get(com.github.javaparser.symbolsolver.model.resolution.TypeSolver)
  Line 71) typeParametersMapBuilder.build() ==> com.github.javaparser.symbolsolver.model.typesystem.parametrization.TypeParametersMap.Builder.build()
  Line 83) getClass() ==> java.lang.Object.getClass()
  Line 77) method.getLastParam().getType() ==> com.github.javaparser.symbolsolver.model.declarations.ValueDeclaration.getType()
  Line 83) o.getClass() ==> java.lang.Object.getClass()
  Line 77) method.getLastParam() ==> com.github.javaparser.symbolsolver.model.declarations.MethodLikeDeclaration.getLastParam()
  Line 78) argumentsTypes.get(pos) ==> java.util.List.get(int)
  Line 167) methodCallExpr.getName().getId() ==> com.github.javaparser.ast.nodeTypes.NodeWithIdentifier.getId()
  Line 79) expectedType.isAssignableBy(actualType) ==> com.github.javaparser.symbolsolver.model.typesystem.Type.isAssignableBy(com.github.javaparser.symbolsolver.model.typesystem.Type)
  Line 128) node.getClass().getCanonicalName() ==> java.lang.Class.getCanonicalName()
  Line 80) method.getTypeParameters() ==> com.github.javaparser.symbolsolver.model.declarations.TypeParametrizable.getTypeParameters()
  Line 81) replaceTypeParam(expectedType, tp, typeSolver) ==> com.github.javaparser.symbolsolver.resolution.MethodResolutionLogic.replaceTypeParam(com.github.javaparser.symbolsolver.model.typesystem.Type, com.github.javaparser.symbolsolver.model.declarations.TypeParameterDeclaration, com.github.javaparser.symbolsolver.model.resolution.TypeSolver)
  Line 277) ctClass.isInterface() ==> javassist.CtClass.isInterface()
  Line 128) node.getClass() ==> java.lang.Object.getClass()
  Line 59) JavaParserFactory.getSymbolDeclarator(parameter, typeSolver) ==> com.github.javaparser.symbolsolver.javaparsermodel.JavaParserFactory.getSymbolDeclarator(com.github.javaparser.ast.Node, com.github.javaparser.symbolsolver.model.resolution.TypeSolver)
  Line 87) typeDeclaration.equals(that.typeDeclaration) ==> java.lang.Object.equals(java.lang.Object)
  Line 60) solveWithAsValue(sb, name, typeSolver) ==> com.github.javaparser.symbolsolver.javaparsermodel.contexts.AbstractJavaParserContext.solveWithAsValue(com.github.javaparser.symbolsolver.resolution.SymbolDeclarator, java.lang.String, com.github.javaparser.symbolsolver.model.resolution.TypeSolver)
  Line 50) inferenceVariableTypeMap.get(tp.getName()) ==> java.util.Map.get(java.lang.Object)
  Line 61) symbolReference.isPresent() ==> java.util.Optional.isPresent()
  Line 50) tp.getName() ==> com.github.javaparser.symbolsolver.model.declarations.TypeParameterDeclaration.getName()
  Line 58) placeInferenceVariables(target) ==> com.github.javaparser.symbolsolver.logic.InferenceContext.placeInferenceVariables(com.github.javaparser.symbolsolver.model.typesystem.Type)
  Line 59) placeInferenceVariables(actual) ==> com.github.javaparser.symbolsolver.logic.InferenceContext.placeInferenceVariables(com.github.javaparser.symbolsolver.model.typesystem.Type)
  Line 167) methodCallExpr.getName() ==> com.github.javaparser.ast.expr.MethodCallExpr.getName()
  Line 68) getParent().solveSymbolAsValue(name, typeSolver) ==> com.github.javaparser.symbolsolver.core.resolution.Context.solveSymbolAsValue(java.lang.String, com.github.javaparser.symbolsolver.model.resolution.TypeSolver)
  Line 68) getParent() ==> com.github.javaparser.symbolsolver.javaparsermodel.contexts.AbstractJavaParserContext.getParent()
  Line 60) registerCorrespondance(target, actual) ==> com.github.javaparser.symbolsolver.logic.InferenceContext.registerCorrespondance(com.github.javaparser.symbolsolver.model.typesystem.Type, com.github.javaparser.symbolsolver.model.typesystem.Type)
  Line 171) node.getChildNodes() ==> com.github.javaparser.ast.Node.getChildNodes()
  Line 88) typeParametersMap.equals(that.typeParametersMap) ==> com.github.javaparser.symbolsolver.model.typesystem.parametrization.TypeParametersMap.equals(java.lang.Object)
  Line 65) placeInferenceVariables(actual) ==> com.github.javaparser.symbolsolver.logic.InferenceContext.placeInferenceVariables(com.github.javaparser.symbolsolver.model.typesystem.Type)
  Line 73) wrappedNode.getTypeParameters() ==> com.github.javaparser.ast.nodeTypes.NodeWithTypeParameters.getTypeParameters()
  Line 172) findMethodCall(child, methodName) ==> com.github.javaparser.symbolsolver.javaparser.Navigator.findMethodCall(com.github.javaparser.ast.Node, java.lang.String)
  Line 83) expectedType.isAssignableBy(actualType) ==> com.github.javaparser.symbolsolver.model.typesystem.Type.isAssignableBy(com.github.javaparser.symbolsolver.model.typesystem.Type)
  Line 283) ctClass.getSuperclass() ==> javassist.CtClass.getSuperclass()
  Line 84) actualType.isArray() ==> com.github.javaparser.symbolsolver.model.typesystem.Type.isArray()
  Line 84) expectedType.isAssignableBy(actualType.asArrayType().getComponentType()) ==> com.github.javaparser.symbolsolver.model.typesystem.Type.isAssignableBy(com.github.javaparser.symbolsolver.model.typesystem.Type)
  Line 84) actualType.asArrayType().getComponentType() ==> com.github.javaparser.symbolsolver.model.typesystem.ArrayType.getComponentType()
  Line 284) typeSolver.solveType(Object.class.getCanonicalName()) ==> com.github.javaparser.symbolsolver.model.resolution.TypeSolver.solveType(java.lang.String)
  Line 284) Object.class.getCanonicalName() ==> java.lang.Class.getCanonicalName()
  Line 84) actualType.asArrayType() ==> com.github.javaparser.symbolsolver.model.typesystem.Type.asArrayType()
  Line 85) argumentsTypes.set(pos, actualType.asArrayType().getComponentType()) ==> java.util.List.set(int, E)
  Line 85) actualType.asArrayType().getComponentType() ==> com.github.javaparser.symbolsolver.model.typesystem.ArrayType.getComponentType()
  Line 85) actualType.asArrayType() ==> com.github.javaparser.symbolsolver.model.typesystem.Type.asArrayType()
  Line 286) ctClass.getGenericSignature() ==> javassist.CtClass.getGenericSignature()
  Line 127) Arrays.stream(clazz.getDeclaredMethods()).filter(m -> !m.isSynthetic() && !m.isBridge()).map(m -> new ReflectionMethodDeclaration(m, typeSolver)) ==> java.util.stream.Stream.map(java.util.function.Function<? super T, ? extends R>)
  Line 127) Arrays.stream(clazz.getDeclaredMethods()).filter(m -> !m.isSynthetic() && !m.isBridge()) ==> java.util.stream.Stream.filter(java.util.function.Predicate<? super T>)
  Line 127) Arrays.stream(clazz.getDeclaredMethods()) ==> java.util.Arrays.stream(T[])
  Line 69) formalType.isReferenceType() ==> com.github.javaparser.symbolsolver.model.typesystem.Type.isReferenceType()
  Line 127) clazz.getDeclaredMethods() ==> java.lang.Class.getDeclaredMethods()
  Line 128) m.isSynthetic() ==> java.lang.reflect.Method.isSynthetic()
  Line 69) actualType.isReferenceType() ==> com.github.javaparser.symbolsolver.model.typesystem.Type.isReferenceType()
  Line 70) formalType.asReferenceType() ==> com.github.javaparser.symbolsolver.model.typesystem.Type.asReferenceType()
  Line 71) actualType.asReferenceType() ==> com.github.javaparser.symbolsolver.model.typesystem.Type.asReferenceType()
  Line 87) groupVariadicParamValues(argumentsTypes, pos, method.getLastParam().getType()) ==> com.github.javaparser.symbolsolver.resolution.MethodResolutionLogic.groupVariadicParamValues(java.util.List<com.github.javaparser.symbolsolver.model.typesystem.Type>, int, com.github.javaparser.symbolsolver.model.typesystem.Type)
  Line 87) method.getLastParam().getType() ==> com.github.javaparser.symbolsolver.model.declarations.ValueDeclaration.getType()
  Line 87) method.getLastParam() ==> com.github.javaparser.symbolsolver.model.declarations.MethodLikeDeclaration.getLastParam()
  Line 92) argumentsTypes.size() ==> java.util.List.size()
  Line 287) ctClass.getSuperclass() ==> javassist.CtClass.getSuperclass()
  Line 95) groupVariadicParamValues(argumentsTypes, pos, method.getLastParam().getType()) ==> com.github.javaparser.symbolsolver.resolution.MethodResolutionLogic.groupVariadicParamValues(java.util.List<com.github.javaparser.symbolsolver.model.typesystem.Type>, int, com.github.javaparser.symbolsolver.model.typesystem.Type)
  Line 95) method.getLastParam().getType() ==> com.github.javaparser.symbolsolver.model.declarations.ValueDeclaration.getType()
  Line 133) node.getClass().getCanonicalName() ==> java.lang.Class.getCanonicalName()
  Line 128) m.isBridge() ==> java.lang.reflect.Method.isBridge()
  Line 95) method.getLastParam() ==> com.github.javaparser.symbolsolver.model.declarations.MethodLikeDeclaration.getLastParam()
  Line 99) method.getNumberOfParams() ==> com.github.javaparser.symbolsolver.model.declarations.MethodLikeDeclaration.getNumberOfParams()
  Line 183) variableDeclarator.getName().getId().equals(name) ==> java.lang.String.equals(java.lang.Object)
  Line 183) variableDeclarator.getName().getId() ==> com.github.javaparser.ast.nodeTypes.NodeWithIdentifier.getId()
  Line 290) SignatureAttribute.toClassSignature(ctClass.getGenericSignature()) ==> javassist.bytecode.SignatureAttribute.toClassSignature(java.lang.String)
  Line 130) Collectors.toSet() ==> java.util.stream.Collectors.toSet()
  Line 183) variableDeclarator.getName() ==> com.github.javaparser.ast.body.VariableDeclarator.getName()
  Line 290) ctClass.getGenericSignature() ==> javassist.CtClass.getGenericSignature()
  Line 95) typeDeclaration.hashCode() ==> java.lang.Object.hashCode()
  Line 187) node.getChildNodes() ==> com.github.javaparser.ast.Node.getChildNodes()
  Line 96) typeParametersMap.hashCode() ==> com.github.javaparser.symbolsolver.model.typesystem.parametrization.TypeParametersMap.hashCode()
  Line 102) getQualifiedName() ==> com.github.javaparser.symbolsolver.model.typesystem.ReferenceType.getQualifiedName()
  Line 132) hasName() ==> com.github.javaparser.symbolsolver.model.typesystem.ReferenceType.hasName()
  Line 133) node.getClass() ==> java.lang.Object.getClass()
  Line 73) formalTypeAsReference.getQualifiedName().equals(actualTypeAsReference.getQualifiedName()) ==> java.lang.String.equals(java.lang.Object)
  Line 74) wrappedNode.getTypeParameters() ==> com.github.javaparser.ast.nodeTypes.NodeWithTypeParameters.getTypeParameters()
  Line 73) formalTypeAsReference.getQualifiedName() ==> com.github.javaparser.symbolsolver.model.typesystem.ReferenceType.getQualifiedName()
  Line 133) sb.append(typeDeclaration.getQualifiedName()) ==> java.lang.StringBuilder.append(java.lang.String)
  Line 73) actualTypeAsReference.getQualifiedName() ==> com.github.javaparser.symbolsolver.model.typesystem.ReferenceType.getQualifiedName()
  Line 133) typeDeclaration.getQualifiedName() ==> com.github.javaparser.symbolsolver.model.declarations.TypeDeclaration.getQualifiedName()
  Line 74) actualTypeAsReference.getAllAncestors() ==> com.github.javaparser.symbolsolver.model.typesystem.ReferenceType.getAllAncestors()
  Line 75) formalTypeAsReference.getQualifiedName() ==> com.github.javaparser.symbolsolver.model.typesystem.ReferenceType.getQualifiedName()
  Line 135) sb.append("<anonymous class>") ==> java.lang.StringBuilder.append(java.lang.String)
  Line 137) typeParametersMap().isEmpty() ==> com.github.javaparser.symbolsolver.model.typesystem.parametrization.TypeParametersMap.isEmpty()
  Line 138) node.getClass().getCanonicalName() ==> java.lang.Class.getCanonicalName()
  Line 137) typeParametersMap() ==> com.github.javaparser.symbolsolver.model.typesystem.ReferenceType.typeParametersMap()
  Line 138) node.getClass() ==> java.lang.Object.getClass()
  Line 138) sb.append("<") ==> java.lang.StringBuilder.append(java.lang.String)
  Line 143) node.getClass().getCanonicalName() ==> java.lang.Class.getCanonicalName()
  Line 143) node.getClass() ==> java.lang.Object.getClass()
  Line 188) demandVariableDeclaration(child, name) ==> com.github.javaparser.symbolsolver.javaparser.Navigator.demandVariableDeclaration(com.github.javaparser.ast.Node, java.lang.String)
  Line 135) this.clazz.getTypeParameters() ==> java.lang.Class.getTypeParameters()
  Line 75) tp.getName().getId().equals(name) ==> java.lang.String.equals(java.lang.Object)
  Line 99) argumentsTypes.size() ==> java.util.List.size()
  Line 75) tp.getName().getId() ==> com.github.javaparser.ast.nodeTypes.NodeWithIdentifier.getId()
  Line 104) method.getNumberOfParams() ==> com.github.javaparser.symbolsolver.model.declarations.MethodLikeDeclaration.getNumberOfParams()
  Line 75) tp.getName() ==> com.github.javaparser.ast.type.TypeParameter.getName()
  Line 76) SymbolReference.solved(new JavaParserTypeParameter(tp, typeSolver)) ==> com.github.javaparser.symbolsolver.model.resolution.SymbolReference.solved(S2)
  Line 136) params.add(new ReflectionTypeParameter(tv, true, typeSolver)) ==> java.util.List.add(E)
  Line 146) isFunctionalInterface() ==> com.github.javaparser.symbolsolver.reflectionmodel.ReflectionClassAdapter.isFunctionalInterface()
  Line 105) method.getParam(i).getType() ==> com.github.javaparser.symbolsolver.model.declarations.ValueDeclaration.getType()
  Line 105) method.getParam(i) ==> com.github.javaparser.symbolsolver.model.declarations.MethodLikeDeclaration.getParam(int)
  Line 106) argumentsTypes.get(i) ==> java.util.List.get(int)
  Line 123) out.println("  Line " + node.getRange().get().begin.line + ") " + node + " ==> " + ref.describe()) ==> java.io.PrintStream.println(java.lang.String)
  Line 123) node.getRange().get() ==> java.util.Optional.get()
  Line 123) node.getRange() ==> com.github.javaparser.ast.Node.getRange()
  Line 123) ref.describe() ==> com.github.javaparser.symbolsolver.model.typesystem.Type.describe()
  Line 82) wrappedNode.getChildNodesByType(com.github.javaparser.ast.body.TypeDeclaration.class) ==> com.github.javaparser.ast.Node.getChildNodesByType(java.lang.Class<N>)
  Line 127) err.println(upe.getMessage()) ==> java.io.PrintStream.println(java.lang.String)
  Line 148) type.isArray() ==> com.github.javaparser.symbolsolver.model.typesystem.Type.isArray()
  Line 127) upe.getMessage() ==> java.lang.Throwable.getMessage()
  Line 151) type.isPrimitive() ==> com.github.javaparser.symbolsolver.model.typesystem.Type.isPrimitive()
  Line 107) expectedType.isTypeVariable() ==> com.github.javaparser.symbolsolver.model.typesystem.Type.isTypeVariable()
  Line 107) expectedType.isWildcard() ==> com.github.javaparser.symbolsolver.model.typesystem.Type.isWildcard()
  Line 107) expectedType.asTypeParameter().declaredOnMethod() ==> com.github.javaparser.symbolsolver.model.declarations.TypeParameterDeclaration.declaredOnMethod()
  Line 65) Helper.getClassName("", wrappedNode) ==> com.github.javaparser.symbolsolver.javaparsermodel.declarations.Helper.getClassName(java.lang.String, com.github.javaparser.ast.Node)
  Line 107) expectedType.asTypeParameter() ==> com.github.javaparser.symbolsolver.model.typesystem.Type.asTypeParameter()
  Line 131) err.println(re.getMessage()) ==> java.io.PrintStream.println(java.lang.String)
  Line 148) node.getClass().getCanonicalName() ==> java.lang.Class.getCanonicalName()
  Line 148) node.getClass() ==> java.lang.Object.getClass()
  Line 131) re.getMessage() ==> java.lang.Throwable.getMessage()
  Line 108) matchedParameters.put(expectedType.asTypeParameter().getName(), actualType) ==> java.util.Map.put(K, V)
  Line 108) expectedType.asTypeParameter().getName() ==> com.github.javaparser.symbolsolver.model.declarations.TypeParameterDeclaration.getName()
  Line 108) expectedType.asTypeParameter() ==> com.github.javaparser.symbolsolver.model.typesystem.Type.asTypeParameter()
  Line 85) localType.getName().getId().equals(name) ==> java.lang.String.equals(java.lang.Object)
  Line 85) localType.getName().getId() ==> com.github.javaparser.ast.nodeTypes.NodeWithIdentifier.getId()
  Line 111) expectedType.isAssignableBy(actualType) ==> com.github.javaparser.symbolsolver.model.typesystem.Type.isAssignableBy(com.github.javaparser.symbolsolver.model.typesystem.Type)
  Line 291) JavassistUtils.signatureTypeToType(classSignature.getSuperClass(), typeSolver, this).asReferenceType() ==> com.github.javaparser.symbolsolver.model.typesystem.Type.asReferenceType()
  Line 85) localType.getName() ==> com.github.javaparser.ast.body.TypeDeclaration.getName()
  Line 154) type.describe().equals(typeDeclaration.getQualifiedName()) ==> java.lang.String.equals(java.lang.Object)
  Line 291) JavassistUtils.signatureTypeToType(classSignature.getSuperClass(), typeSolver, this) ==> com.github.javaparser.symbolsolver.javassistmodel.JavassistUtils.signatureTypeToType(javassist.bytecode.SignatureAttribute.Type, com.github.javaparser.symbolsolver.model.resolution.TypeSolver, com.github.javaparser.symbolsolver.model.declarations.TypeParametrizable)
  Line 154) type.describe() ==> com.github.javaparser.symbolsolver.model.typesystem.Type.describe()
  Line 291) classSignature.getSuperClass() ==> javassist.bytecode.SignatureAttribute.ClassSignature.getSuperClass()
  Line 154) typeDeclaration.getQualifiedName() ==> com.github.javaparser.symbolsolver.model.declarations.TypeDeclaration.getQualifiedName()
  Line 76) ancestors.stream().filter((a) -> a.getQualifiedName().equals(formalParamTypeQName)).collect(Collectors.toList()) ==> java.util.stream.Stream.collect(java.util.stream.Collector<? super T, A, R>)
  Line 197) findType(compilationUnit, qualifiedName) ==> com.github.javaparser.symbolsolver.javaparser.Navigator.findType(com.github.javaparser.ast.CompilationUnit, java.lang.String)
  Line 76) ancestors.stream().filter((a) -> a.getQualifiedName().equals(formalParamTypeQName)) ==> java.util.stream.Stream.filter(java.util.function.Predicate<? super T>)
  Line 153) node.getClass().getCanonicalName() ==> java.lang.Class.getCanonicalName()
  Line 302) ctClass.getGenericSignature() ==> javassist.CtClass.getGenericSignature()
  Line 153) node.getClass() ==> java.lang.Object.getClass()
  Line 158) node.getClass().getCanonicalName() ==> java.lang.Class.getCanonicalName()
  Line 158) node.getClass() ==> java.lang.Object.getClass()
  Line 76) ancestors.stream() ==> java.util.Collection.stream()
  Line 76) a.getQualifiedName().equals(formalParamTypeQName) ==> java.lang.String.equals(java.lang.Object)
  Line 76) a.getQualifiedName() ==> com.github.javaparser.symbolsolver.model.typesystem.ReferenceType.getQualifiedName()
  Line 76) Collectors.toList() ==> java.util.stream.Collectors.toList()
  Line 112) method.getParam(i).isVariadic() ==> com.github.javaparser.symbolsolver.model.declarations.ParameterDeclaration.isVariadic()
  Line 198) res.isPresent() ==> java.util.Optional.isPresent()
  Line 201) res.get() ==> java.util.Optional.get()
  Line 77) correspondingFormalType.isEmpty() ==> java.util.List.isEmpty()
  Line 78) formalTypeAsReference.getAllAncestors() ==> com.github.javaparser.symbolsolver.model.typesystem.ReferenceType.getAllAncestors()
  Line 159) otherTypeDeclaration.getTypeDeclaration().canBeAssignedTo(typeDeclaration) ==> com.github.javaparser.symbolsolver.model.declarations.ReferenceTypeDeclaration.canBeAssignedTo(com.github.javaparser.symbolsolver.model.declarations.ReferenceTypeDeclaration)
  Line 202) res.get().getClass().getCanonicalName() ==> java.lang.Class.getCanonicalName()
  Line 79) actualTypeAsReference.getQualifiedName() ==> com.github.javaparser.symbolsolver.model.typesystem.ReferenceType.getQualifiedName()
  Line 159) otherTypeDeclaration.getTypeDeclaration() ==> com.github.javaparser.symbolsolver.model.typesystem.ReferenceType.getTypeDeclaration()
  Line 202) res.get().getClass() ==> java.lang.Object.getClass()
  Line 166) clazz.getDeclaredAnnotations() ==> java.lang.Class.getDeclaredAnnotations()
  Line 163) node.getClass().getCanonicalName() ==> java.lang.Class.getCanonicalName()
  Line 202) res.get() ==> java.util.Optional.get()
  Line 167) a.annotationType().getCanonicalName().equals(canonicalName) ==> java.lang.String.equals(java.lang.Object)
  Line 167) a.annotationType().getCanonicalName() ==> java.lang.Class.getCanonicalName()
  Line 204) res.get() ==> java.util.Optional.get()
  Line 167) a.annotationType() ==> java.lang.annotation.Annotation.annotationType()
  Line 209) findSwitchHelper(node) ==> com.github.javaparser.symbolsolver.javaparser.Navigator.findSwitchHelper(com.github.javaparser.ast.Node)
  Line 175) FunctionalInterfaceLogic.getFunctionalMethod(typeDeclaration).isPresent() ==> java.util.Optional.isPresent()
  Line 175) FunctionalInterfaceLogic.getFunctionalMethod(typeDeclaration) ==> com.github.javaparser.symbolsolver.logic.FunctionalInterfaceLogic.getFunctionalMethod(com.github.javaparser.symbolsolver.model.declarations.ReferenceTypeDeclaration)
  Line 112) method.getParam(i) ==> com.github.javaparser.symbolsolver.model.declarations.MethodLikeDeclaration.getParam(int)
  Line 112) new ArrayType(expectedType).isAssignableBy(actualType) ==> com.github.javaparser.symbolsolver.model.typesystem.ArrayType.isAssignableBy(com.github.javaparser.symbolsolver.model.typesystem.Type)
  Line 163) node.getClass() ==> java.lang.Object.getClass()
  Line 113) expectedType.isReferenceType() ==> com.github.javaparser.symbolsolver.model.typesystem.Type.isReferenceType()
  Line 113) actualType.isReferenceType() ==> com.github.javaparser.symbolsolver.model.typesystem.Type.isReferenceType()
  Line 168) node.getClass().getCanonicalName() ==> java.lang.Class.getCanonicalName()
  Line 168) node.getClass() ==> java.lang.Object.getClass()
  Line 173) node.getClass().getCanonicalName() ==> java.lang.Class.getCanonicalName()
  Line 173) node.getClass() ==> java.lang.Object.getClass()
  Line 218) findNodeOfGivenClassHelper(node, clazz) ==> com.github.javaparser.symbolsolver.javaparser.Navigator.findNodeOfGivenClassHelper(com.github.javaparser.ast.Node, java.lang.Class<N>)
  Line 140) out.println("  Line " + node.getBegin().get().line + ") " + node + " ==> " + toString((MethodCallExpr) node)) ==> java.io.PrintStream.println(java.lang.String)
  Line 140) node.getBegin().get() ==> java.util.Optional.get()
  Line 178) node.getClass().getCanonicalName() ==> java.lang.Class.getCanonicalName()
  Line 80) ancestors.stream().filter(a -> a.getQualifiedName().equals(actualParamTypeQname)).collect(Collectors.toList()) ==> java.util.stream.Stream.collect(java.util.stream.Collector<? super T, A, R>)
  Line 80) ancestors.stream().filter(a -> a.getQualifiedName().equals(actualParamTypeQname)) ==> java.util.stream.Stream.filter(java.util.function.Predicate<? super T>)
  Line 179) Arrays.stream(clazz.getConstructors()).map(m -> new ReflectionConstructorDeclaration(m, typeSolver)).collect(Collectors.toList()) ==> java.util.stream.Stream.collect(java.util.stream.Collector<? super T, A, R>)
  Line 179) Arrays.stream(clazz.getConstructors()).map(m -> new ReflectionConstructorDeclaration(m, typeSolver)) ==> java.util.stream.Stream.map(java.util.function.Function<? super T, ? extends R>)
  Line 179) Arrays.stream(clazz.getConstructors()) ==> java.util.Arrays.stream(T[])
  Line 140) node.getBegin() ==> com.github.javaparser.ast.nodeTypes.NodeWithRange.getBegin()
  Line 179) clazz.getConstructors() ==> java.lang.Class.getConstructors()
  Line 181) Collectors.toList() ==> java.util.stream.Collectors.toList()
  Line 185) clazz.getDeclaringClass() ==> java.lang.Class.getDeclaringClass()
  Line 187) Optional.empty() ==> java.util.Optional.empty()
  Line 114) isAssignableMatchTypeParameters(expectedType.asReferenceType(), actualType.asReferenceType(), matchedParameters) ==> com.github.javaparser.symbolsolver.resolution.MethodResolutionLogic.isAssignableMatchTypeParameters(com.github.javaparser.symbolsolver.model.typesystem.ReferenceType, com.github.javaparser.symbolsolver.model.typesystem.ReferenceType, java.util.Map<java.lang.String, com.github.javaparser.symbolsolver.model.typesystem.Type>)
  Line 115) expectedType.asReferenceType() ==> com.github.javaparser.symbolsolver.model.typesystem.Type.asReferenceType()
  Line 116) actualType.asReferenceType() ==> com.github.javaparser.symbolsolver.model.typesystem.Type.asReferenceType()
  Line 80) ancestors.stream() ==> java.util.Collection.stream()
  Line 80) a.getQualifiedName().equals(actualParamTypeQname) ==> java.lang.String.equals(java.lang.Object)
  Line 120) method.getTypeParameters() ==> com.github.javaparser.symbolsolver.model.declarations.TypeParametrizable.getTypeParameters()
  Line 80) a.getQualifiedName() ==> com.github.javaparser.symbolsolver.model.typesystem.ReferenceType.getQualifiedName()
  Line 80) Collectors.toList() ==> java.util.stream.Collectors.toList()
  Line 178) node.getClass() ==> java.lang.Object.getClass()
  Line 139) sb.append(String.join(", ", typeDeclaration.getTypeParameters().stream().map(tp -> typeParametersMap().getValue(tp).describe()).collect(Collectors.toList()))) ==> java.lang.StringBuilder.append(java.lang.String)
  Line 183) node.getClass().getCanonicalName() ==> java.lang.Class.getCanonicalName()
  Line 228) findAllNodesOfGivenClassHelper(node, clazz, res) ==> com.github.javaparser.symbolsolver.javaparser.Navigator.findAllNodesOfGivenClassHelper(com.github.javaparser.ast.Node, java.lang.Class<N>, java.util.List<N>)
  Line 81) correspondingActualType.isEmpty() ==> java.util.List.isEmpty()
  Line 183) node.getClass() ==> java.lang.Object.getClass()
  Line 87) correspondingFormalType.get(0).asReferenceType() ==> com.github.javaparser.symbolsolver.model.typesystem.Type.asReferenceType()
  Line 87) correspondingFormalType.get(0) ==> java.util.List.get(int)
  Line 121) typeParameters.addAll(method.declaringType().getTypeParameters()) ==> java.util.List.addAll(java.util.Collection<? extends E>)
  Line 121) method.declaringType().getTypeParameters() ==> com.github.javaparser.symbolsolver.model.declarations.TypeParametrizable.getTypeParameters()
  Line 121) method.declaringType() ==> com.github.javaparser.symbolsolver.model.declarations.MethodLikeDeclaration.declaringType()
  Line 188) Optional.of(ReflectionFactory.typeDeclarationFor(declaringClass, typeSolver)) ==> java.util.Optional.of(T)
  Line 188) ReflectionFactory.typeDeclarationFor(declaringClass, typeSolver) ==> com.github.javaparser.symbolsolver.reflectionmodel.ReflectionFactory.typeDeclarationFor(java.lang.Class<?>, com.github.javaparser.symbolsolver.model.resolution.TypeSolver)
  Line 303) Arrays.stream(ctClass.getInterfaces()).map(i -> new JavassistInterfaceDeclaration(i, typeSolver)).map(i -> new ReferenceTypeImpl(i, typeSolver)).collect(Collectors.toList()) ==> java.util.stream.Stream.collect(java.util.stream.Collector<? super T, A, R>)
  Line 90) formalTypeAsReference.getQualifiedName().equals(actualTypeAsReference.getQualifiedName()) ==> java.lang.String.equals(java.lang.Object)
  Line 188) node.getClass().getCanonicalName() ==> java.lang.Class.getCanonicalName()
  Line 123) replaceTypeParam(expectedType, tp, typeSolver) ==> com.github.javaparser.symbolsolver.resolution.MethodResolutionLogic.replaceTypeParam(com.github.javaparser.symbolsolver.model.typesystem.Type, com.github.javaparser.symbolsolver.model.declarations.TypeParameterDeclaration, com.github.javaparser.symbolsolver.model.resolution.TypeSolver)
  Line 139) String.join(", ", typeDeclaration.getTypeParameters().stream().map(tp -> typeParametersMap().getValue(tp).describe()).collect(Collectors.toList())) ==> java.lang.String.join(java.lang.CharSequence, java.lang.Iterable<? extends java.lang.CharSequence>)
  Line 140) toString((MethodCallExpr) node) ==> com.github.javaparser.symbolsolver.SourceFileInfoExtractor.toString(com.github.javaparser.ast.expr.MethodCallExpr)
  Line 233) findNodeOfGivenClass(method, ReturnStmt.class) ==> com.github.javaparser.symbolsolver.javaparser.Navigator.findNodeOfGivenClass(com.github.javaparser.ast.Node, java.lang.Class<N>)
  Line 70) Helper.containerName(getParentNode(wrappedNode)) ==> com.github.javaparser.symbolsolver.javaparsermodel.declarations.Helper.containerName(com.github.javaparser.ast.Node)
  Line 86) SymbolReference.solved(JavaParserFacade.get(typeSolver).getTypeDeclaration(localType)) ==> com.github.javaparser.symbolsolver.model.resolution.SymbolReference.solved(S2)
