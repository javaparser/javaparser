  Line 531) Optional.of(applicableMethods.get(0)) ==> java.util.Optional.of(T)
  Line 200) ctClass.getSimpleName() ==> javassist.CtClass.getSimpleName()
  Line 206) javassistTypeDeclarationAdapter.getTypeParameters() ==> com.github.javaparser.symbolsolver.javassistmodel.JavassistTypeDeclarationAdapter.getTypeParameters()
  Line 38) wrappedNode.getParameter() ==> com.github.javaparser.ast.stmt.CatchClause.getParameter()
  Line 211) JavassistFactory.modifiersToAccessLevel(ctClass.getModifiers()) ==> com.github.javaparser.symbolsolver.javassistmodel.JavassistFactory.modifiersToAccessLevel(int)
  Line 39) solveWithAsValue(sb, name, typeSolver) ==> com.github.javaparser.symbolsolver.javaparsermodel.contexts.AbstractJavaParserContext.solveWithAsValue(com.github.javaparser.symbolsolver.resolution.SymbolDeclarator, java.lang.String, com.github.javaparser.symbolsolver.model.resolution.TypeSolver)
  Line 531) applicableMethods.get(0) ==> java.util.List.get(int)
  Line 211) ctClass.getModifiers() ==> javassist.CtClass.getModifiers()
  Line 40) symbolReference.isPresent() ==> java.util.Optional.isPresent()
  Line 46) getParent().solveSymbolAsValue(name, typeSolver) ==> com.github.javaparser.symbolsolver.core.resolution.Context.solveSymbolAsValue(java.lang.String, com.github.javaparser.symbolsolver.model.resolution.TypeSolver)
  Line 222) ctClass.getDeclaredFields() ==> javassist.CtClass.getDeclaredFields()
  Line 533) applicableMethods.get(0) ==> java.util.List.get(int)
  Line 534) applicableMethods.size() ==> java.util.List.size()
  Line 75) typeUsageFor(c.getComponentType(), typeSolver) ==> com.github.javaparser.symbolsolver.reflectionmodel.ReflectionFactory.typeUsageFor(java.lang.reflect.Type, com.github.javaparser.symbolsolver.model.resolution.TypeSolver)
  Line 75) c.getComponentType() ==> java.lang.Class.getComponentType()
  Line 535) applicableMethods.get(i) ==> java.util.List.get(int)
  Line 536) isMoreSpecific(winningCandidate, other, typeSolver) ==> com.github.javaparser.symbolsolver.resolution.MethodResolutionLogic.isMoreSpecific(com.github.javaparser.symbolsolver.model.methods.MethodUsage, com.github.javaparser.symbolsolver.model.methods.MethodUsage, com.github.javaparser.symbolsolver.model.resolution.TypeSolver)
  Line 223) field.getName().equals(name) ==> java.lang.String.equals(java.lang.Object)
  Line 223) field.getName() ==> javassist.CtField.getName()
  Line 224) SymbolReference.solved(new JavassistFieldDeclaration(field, typeSolver)) ==> com.github.javaparser.symbolsolver.model.resolution.SymbolReference.solved(S2)
  Line 183) findMembersOfKind(com.github.javaparser.ast.body.TypeDeclaration.class).stream().map(typeMember -> JavaParserFacade.get(typeSolver).getTypeDeclaration(typeMember)) ==> java.util.stream.Stream.map(java.util.function.Function<? super T, ? extends R>)
  Line 183) findMembersOfKind(com.github.javaparser.ast.body.TypeDeclaration.class).stream() ==> java.util.Collection.stream()
  Line 81) boundedType.equals(that.boundedType) ==> java.lang.Object.equals(java.lang.Object)
  Line 89) type.hashCode() ==> java.lang.Enum.hashCode()
  Line 183) findMembersOfKind(com.github.javaparser.ast.body.TypeDeclaration.class) ==> com.github.javaparser.symbolsolver.javaparsermodel.declarations.JavaParserAnonymousClassDeclaration.findMembersOfKind(java.lang.Class<T>)
  Line 77) typeDeclarationFor(c, typeSolver) ==> com.github.javaparser.symbolsolver.reflectionmodel.ReflectionFactory.typeDeclarationFor(java.lang.Class<?>, com.github.javaparser.symbolsolver.model.resolution.TypeSolver)
  Line 90) boundedType.hashCode() ==> java.lang.Object.hashCode()
  Line 99) boundedType.describe() ==> com.github.javaparser.symbolsolver.model.typesystem.Type.describe()
  Line 101) boundedType.describe() ==> com.github.javaparser.symbolsolver.model.typesystem.Type.describe()
  Line 116) isSuper() ==> com.github.javaparser.symbolsolver.model.typesystem.Wildcard.isSuper()
  Line 116) isExtends() ==> com.github.javaparser.symbolsolver.model.typesystem.Wildcard.isExtends()
  Line 538) isMoreSpecific(other, winningCandidate, typeSolver) ==> com.github.javaparser.symbolsolver.resolution.MethodResolutionLogic.isMoreSpecific(com.github.javaparser.symbolsolver.model.methods.MethodUsage, com.github.javaparser.symbolsolver.model.methods.MethodUsage, com.github.javaparser.symbolsolver.model.resolution.TypeSolver)
  Line 132) boundedType.isAssignableBy(other) ==> com.github.javaparser.symbolsolver.model.typesystem.Type.isAssignableBy(com.github.javaparser.symbolsolver.model.typesystem.Type)
  Line 46) getParent() ==> com.github.javaparser.symbolsolver.javaparsermodel.contexts.AbstractJavaParserContext.getParent()
  Line 148) boundedType.replaceTypeVariables(tpToReplace, replaced, inferredTypes) ==> com.github.javaparser.symbolsolver.model.typesystem.Type.replaceTypeVariables(com.github.javaparser.symbolsolver.model.declarations.TypeParameterDeclaration, com.github.javaparser.symbolsolver.model.typesystem.Type, java.util.Map<com.github.javaparser.symbolsolver.model.declarations.TypeParameterDeclaration, com.github.javaparser.symbolsolver.model.typesystem.Type>)
