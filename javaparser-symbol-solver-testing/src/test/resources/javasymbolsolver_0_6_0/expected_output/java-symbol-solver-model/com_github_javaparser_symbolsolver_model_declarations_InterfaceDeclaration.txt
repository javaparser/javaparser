  Line 46) getInterfacesExtended() ==> com.github.javaparser.symbolsolver.model.declarations.InterfaceDeclaration.getInterfacesExtended()
  Line 50) methodDeclaration.getParam(i).getType() ==> com.github.javaparser.symbolsolver.model.declarations.ValueDeclaration.getType()
  Line 50) methodDeclaration.getParam(i) ==> com.github.javaparser.symbolsolver.model.declarations.MethodLikeDeclaration.getParam(int)
  Line 51) params.add(replaced) ==> java.util.List.add(E)
  Line 58) methodDeclaration.getNumberOfParams() ==> com.github.javaparser.symbolsolver.model.declarations.MethodLikeDeclaration.getNumberOfParams()
  Line 58) methodDeclaration.hasVariadicParameter() ==> com.github.javaparser.symbolsolver.model.declarations.MethodLikeDeclaration.hasVariadicParameter()
  Line 59) methodDeclaration.getParam(i).getType() ==> com.github.javaparser.symbolsolver.model.declarations.ValueDeclaration.getType()
  Line 59) methodDeclaration.getParam(i) ==> com.github.javaparser.symbolsolver.model.declarations.MethodLikeDeclaration.getParam(int)
  Line 44) node.getParentNode() ==> com.github.javaparser.ast.Node.getParentNode()
  Line 60) parameterTypes.get(i) ==> java.util.List.get(int)
  Line 61) inferenceContext.addPair(formalParamType, actualParamType) ==> com.github.javaparser.symbolsolver.logic.InferenceContext.addPair(com.github.javaparser.symbolsolver.model.typesystem.Type, com.github.javaparser.symbolsolver.model.typesystem.Type)
  Line 49) cu.getTypes().isEmpty() ==> com.github.javaparser.ast.NodeList.isEmpty()
  Line 49) cu.getTypes() ==> com.github.javaparser.ast.CompilationUnit.getTypes()
  Line 50) Optional.empty() ==> java.util.Optional.empty()
  Line 53) getOuterTypeName(qualifiedName) ==> com.github.javaparser.symbolsolver.javaparser.Navigator.getOuterTypeName(java.lang.String)
  Line 64) inferenceContext.resolve(inferenceContext.addSingle(returnType)) ==> com.github.javaparser.symbolsolver.logic.InferenceContext.resolve(com.github.javaparser.symbolsolver.model.typesystem.Type)
  Line 64) inferenceContext.addSingle(returnType) ==> com.github.javaparser.symbolsolver.logic.InferenceContext.addSingle(com.github.javaparser.symbolsolver.model.typesystem.Type)
  Line 47) superclasses.add(superClass) ==> java.util.List.add(E)
  Line 47) interfaces.add(interfaceDeclaration) ==> java.util.List.add(E)
  Line 70) type.isTypeVariable() ==> com.github.javaparser.symbolsolver.model.typesystem.Type.isTypeVariable()
  Line 71) type.asTypeParameter() ==> com.github.javaparser.symbolsolver.model.typesystem.Type.asTypeParameter()
  Line 72) typeParameter.declaredOnType() ==> com.github.javaparser.symbolsolver.model.declarations.TypeParameterDeclaration.declaredOnType()
  Line 54) cu.getTypes().stream().filter((t) -> t.getName().getId().equals(typeName)).findFirst() ==> ERROR
  Line 54) cu.getTypes().stream().filter((t) -> t.getName().getId().equals(typeName)) ==> ERROR
  Line 54) cu.getTypes().stream() ==> java.util.Collection.stream()
  Line 54) cu.getTypes() ==> com.github.javaparser.ast.CompilationUnit.getTypes()
  Line 73) typeParamByName(typeParameter.getName(), typeSolver, context) ==> com.github.javaparser.symbolsolver.declarations.common.MethodDeclarationCommonLogic.typeParamByName(java.lang.String, com.github.javaparser.symbolsolver.model.resolution.TypeSolver, com.github.javaparser.symbolsolver.core.resolution.Context)
  Line 54) t.getName().getId().equals(typeName) ==> ERROR
  Line 73) typeParameter.getName() ==> com.github.javaparser.symbolsolver.model.declarations.TypeParameterDeclaration.getName()
  Line 74) typeParam.isPresent() ==> java.util.Optional.isPresent()
  Line 75) typeParam.get() ==> java.util.Optional.get()
  Line 54) t.getName().getId() ==> ERROR
  Line 54) t.getName() ==> ERROR
  Line 56) getInnerTypeName(qualifiedName) ==> com.github.javaparser.symbolsolver.javaparser.Navigator.getInnerTypeName(java.lang.String)
  Line 80) type.isReferenceType() ==> com.github.javaparser.symbolsolver.model.typesystem.Type.isReferenceType()
  Line 57) type.isPresent() ==> java.util.Optional.isPresent()
  Line 57) innerTypeName.isEmpty() ==> java.lang.String.isEmpty()
  Line 39) argumentsTypes.subList(startVariadic, argumentsTypes.size()) ==> java.util.List.subList(int, int)
  Line 39) argumentsTypes.size() ==> java.util.List.size()
  Line 52) this.elements.add(typeSolver) ==> java.util.List.add(E)
  Line 53) typeSolver.setParent(this) ==> com.github.javaparser.symbolsolver.model.resolution.TypeSolver.setParent(com.github.javaparser.symbolsolver.model.resolution.TypeSolver)
  Line 59) ts.tryToSolveType(name) ==> com.github.javaparser.symbolsolver.model.resolution.TypeSolver.tryToSolveType(java.lang.String)
  Line 81) type.asReferenceType().transformTypeParameters(tp -> replaceTypeParams(tp, typeSolver, context)) ==> com.github.javaparser.symbolsolver.model.typesystem.ReferenceType.transformTypeParameters(com.github.javaparser.symbolsolver.model.typesystem.TypeTransformer)
  Line 125) typeParametersMap.toBuilder().setValue(typeParameter, type) ==> com.github.javaparser.symbolsolver.model.typesystem.parametrization.TypeParametersMap.Builder.setValue(com.github.javaparser.symbolsolver.model.declarations.TypeParameterDeclaration, com.github.javaparser.symbolsolver.model.typesystem.Type)
  Line 48) interfaces.addAll(interfaceDeclaration.getAllInterfacesAncestors()) ==> java.util.List.addAll(java.util.Collection<? extends E>)
  Line 40) variadicValues.isEmpty() ==> java.util.List.isEmpty()
  Line 48) interfaceDeclaration.getAllInterfacesAncestors() ==> com.github.javaparser.symbolsolver.model.typesystem.ReferenceType.getAllInterfacesAncestors()
