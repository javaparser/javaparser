  Line 53) this.equivalentTypes.add(type) ==> java.util.Set.add(E)
  Line 81) wildcard.isExtends() ==> com.github.javaparser.symbolsolver.model.typesystem.Wildcard.isExtends()
  Line 82) inferenceVariableType.superTypes.add(wildcard.getBoundedType()) ==> java.util.Set.add(E)
  Line 82) wildcard.getBoundedType() ==> com.github.javaparser.symbolsolver.model.typesystem.Wildcard.getBoundedType()
  Line 84) wildcard.isSuper() ==> com.github.javaparser.symbolsolver.model.typesystem.Wildcard.isSuper()
  Line 86) inferenceVariableType.superTypes.add(wildcard.getBoundedType()) ==> java.util.Set.add(E)
  Line 86) wildcard.getBoundedType() ==> com.github.javaparser.symbolsolver.model.typesystem.Wildcard.getBoundedType()
  Line 102) considered.add(inferenceVariableType) ==> java.util.Set.add(E)
  Line 104) result.addAll(inferenceVariableType.equivalentTypes.stream().filter(t -> !t.isTypeVariable() && !(t instanceof InferenceVariableType)).collect(Collectors.toSet())) ==> java.util.Set.addAll(java.util.Collection<? extends E>)
  Line 104) inferenceVariableType.equivalentTypes.stream().filter(t -> !t.isTypeVariable() && !(t instanceof InferenceVariableType)).collect(Collectors.toSet()) ==> java.util.stream.Stream.collect(java.util.stream.Collector<? super T, A, R>)
  Line 104) inferenceVariableType.equivalentTypes.stream().filter(t -> !t.isTypeVariable() && !(t instanceof InferenceVariableType)) ==> java.util.stream.Stream.filter(java.util.function.Predicate<? super T>)
  Line 104) inferenceVariableType.equivalentTypes.stream() ==> java.util.Collection.stream()
  Line 104) t.isTypeVariable() ==> com.github.javaparser.symbolsolver.model.typesystem.Type.isTypeVariable()
  Line 104) Collectors.toSet() ==> java.util.stream.Collectors.toSet()
  Line 105) inferenceVariableType.equivalentTypes.stream().filter(t -> t instanceof InferenceVariableType).forEach(t -> {
    InferenceVariableType ivt = (InferenceVariableType) t;
    if (!considered.contains(ivt)) {
        result.addAll(concreteEquivalentTypesAlsoIndirectly(considered, ivt));
    }
}) ==> java.util.stream.Stream.forEach(java.util.function.Consumer<? super T>)
  Line 105) inferenceVariableType.equivalentTypes.stream().filter(t -> t instanceof InferenceVariableType) ==> java.util.stream.Stream.filter(java.util.function.Predicate<? super T>)
  Line 105) inferenceVariableType.equivalentTypes.stream() ==> java.util.Collection.stream()
  Line 107) considered.contains(ivt) ==> java.util.Set.contains(java.lang.Object)
  Line 108) result.addAll(concreteEquivalentTypesAlsoIndirectly(considered, ivt)) ==> java.util.Set.addAll(java.util.Collection<? extends E>)
  Line 108) concreteEquivalentTypesAlsoIndirectly(considered, ivt) ==> com.github.javaparser.symbolsolver.logic.InferenceVariableType.concreteEquivalentTypesAlsoIndirectly(java.util.Set<com.github.javaparser.symbolsolver.logic.InferenceVariableType>, com.github.javaparser.symbolsolver.logic.InferenceVariableType)
  Line 115) concreteEquivalentTypesAlsoIndirectly(new HashSet<>(), this) ==> com.github.javaparser.symbolsolver.logic.InferenceVariableType.concreteEquivalentTypesAlsoIndirectly(java.util.Set<com.github.javaparser.symbolsolver.logic.InferenceVariableType>, com.github.javaparser.symbolsolver.logic.InferenceVariableType)
  Line 116) concreteEquivalent.isEmpty() ==> java.util.Set.isEmpty()
  Line 118) objectProvider.object() ==> com.github.javaparser.symbolsolver.logic.ObjectProvider.object()
  Line 123) concreteEquivalent.size() ==> java.util.Set.size()
  Line 124) concreteEquivalent.iterator().next() ==> java.util.Iterator.next()
  Line 124) concreteEquivalent.iterator() ==> java.util.Set.iterator()
  Line 126) equivalentTypes.stream().filter(t -> !t.isTypeVariable() && !hasInferenceVariables(t)).collect(Collectors.toSet()) ==> java.util.stream.Stream.collect(java.util.stream.Collector<? super T, A, R>)
  Line 126) equivalentTypes.stream().filter(t -> !t.isTypeVariable() && !hasInferenceVariables(t)) ==> java.util.stream.Stream.filter(java.util.function.Predicate<? super T>)
  Line 126) equivalentTypes.stream() ==> java.util.Collection.stream()
  Line 127) t.isTypeVariable() ==> com.github.javaparser.symbolsolver.model.typesystem.Type.isTypeVariable()
  Line 127) hasInferenceVariables(t) ==> com.github.javaparser.symbolsolver.logic.InferenceVariableType.hasInferenceVariables(com.github.javaparser.symbolsolver.model.typesystem.Type)
  Line 128) Collectors.toSet() ==> java.util.stream.Collectors.toSet()
  Line 129) notTypeVariables.size() ==> java.util.Set.size()
  Line 130) notTypeVariables.iterator().next() ==> java.util.Iterator.next()
  Line 130) notTypeVariables.iterator() ==> java.util.Set.iterator()
  Line 131) notTypeVariables.size() ==> java.util.Set.size()
  Line 131) superTypes.isEmpty() ==> java.util.Set.isEmpty()
  Line 132) superTypes.size() ==> java.util.Set.size()
  Line 133) superTypes.iterator().next() ==> java.util.Iterator.next()
  Line 133) superTypes.iterator() ==> java.util.Set.iterator()
  Line 147) type.isReferenceType() ==> com.github.javaparser.symbolsolver.model.typesystem.Type.isReferenceType()
  Line 148) type.asReferenceType() ==> com.github.javaparser.symbolsolver.model.typesystem.Type.asReferenceType()
  Line 149) refType.typeParametersValues() ==> com.github.javaparser.symbolsolver.model.typesystem.ReferenceType.typeParametersValues()
  Line 150) hasInferenceVariables(t) ==> com.github.javaparser.symbolsolver.logic.InferenceVariableType.hasInferenceVariables(com.github.javaparser.symbolsolver.model.typesystem.Type)
  Line 157) type.isWildcard() ==> com.github.javaparser.symbolsolver.model.typesystem.Type.isWildcard()
  Line 158) type.asWildcard() ==> com.github.javaparser.symbolsolver.model.typesystem.Type.asWildcard()
  Line 159) hasInferenceVariables(wildcardType.getBoundedType()) ==> com.github.javaparser.symbolsolver.logic.InferenceVariableType.hasInferenceVariables(com.github.javaparser.symbolsolver.model.typesystem.Type)
  Line 159) wildcardType.getBoundedType() ==> com.github.javaparser.symbolsolver.model.typesystem.Wildcard.getBoundedType()
