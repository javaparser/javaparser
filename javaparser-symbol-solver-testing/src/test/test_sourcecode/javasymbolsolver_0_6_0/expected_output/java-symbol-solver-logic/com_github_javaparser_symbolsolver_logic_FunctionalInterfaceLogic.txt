  Line 44) type.isReferenceType() ==> com.github.javaparser.symbolsolver.model.typesystem.Type.isReferenceType()
  Line 44) type.asReferenceType().getTypeDeclaration().isInterface() ==> com.github.javaparser.symbolsolver.model.declarations.TypeDeclaration.isInterface()
  Line 44) type.asReferenceType().getTypeDeclaration() ==> com.github.javaparser.symbolsolver.model.typesystem.ReferenceType.getTypeDeclaration()
  Line 44) type.asReferenceType() ==> com.github.javaparser.symbolsolver.model.typesystem.Type.asReferenceType()
  Line 45) getFunctionalMethod(type.asReferenceType().getTypeDeclaration()) ==> com.github.javaparser.symbolsolver.logic.FunctionalInterfaceLogic.getFunctionalMethod(com.github.javaparser.symbolsolver.model.declarations.ReferenceTypeDeclaration)
  Line 45) type.asReferenceType().getTypeDeclaration() ==> com.github.javaparser.symbolsolver.model.typesystem.ReferenceType.getTypeDeclaration()
  Line 45) type.asReferenceType() ==> com.github.javaparser.symbolsolver.model.typesystem.Type.asReferenceType()
  Line 47) Optional.empty() ==> java.util.Optional.empty()
  Line 56) typeDeclaration.getAllMethods().stream().filter(m -> m.getDeclaration().isAbstract()).filter(m -> !declaredOnObject(m)).collect(Collectors.toSet()) ==> java.util.stream.Stream.collect(java.util.stream.Collector<? super T, A, R>)
  Line 56) typeDeclaration.getAllMethods().stream().filter(m -> m.getDeclaration().isAbstract()).filter(m -> !declaredOnObject(m)) ==> java.util.stream.Stream.filter(java.util.function.Predicate<? super T>)
  Line 56) typeDeclaration.getAllMethods().stream().filter(m -> m.getDeclaration().isAbstract()) ==> java.util.stream.Stream.filter(java.util.function.Predicate<? super T>)
  Line 56) typeDeclaration.getAllMethods().stream() ==> java.util.Collection.stream()
  Line 56) typeDeclaration.getAllMethods() ==> com.github.javaparser.symbolsolver.model.declarations.ReferenceTypeDeclaration.getAllMethods()
  Line 57) m.getDeclaration().isAbstract() ==> com.github.javaparser.symbolsolver.model.declarations.MethodDeclaration.isAbstract()
  Line 57) m.getDeclaration() ==> com.github.javaparser.symbolsolver.model.methods.MethodUsage.getDeclaration()
  Line 60) declaredOnObject(m) ==> com.github.javaparser.symbolsolver.logic.FunctionalInterfaceLogic.declaredOnObject(com.github.javaparser.symbolsolver.model.methods.MethodUsage)
  Line 61) Collectors.toSet() ==> java.util.stream.Collectors.toSet()
  Line 63) methods.size() ==> java.util.Set.size()
  Line 64) Optional.of(methods.iterator().next()) ==> java.util.Optional.of(T)
  Line 64) methods.iterator().next() ==> java.util.Iterator.next()
  Line 64) methods.iterator() ==> java.util.Set.iterator()
  Line 66) Optional.empty() ==> java.util.Optional.empty()
  Line 71) String.format("%s(%s)", m.getName(), String.join(", ", Arrays.stream(m.getParameters()).map(p -> toSignature(p)).collect(Collectors.toList()))) ==> java.lang.String.format(java.lang.String, java.lang.Object...)
  Line 71) m.getName() ==> java.lang.reflect.Method.getName()
  Line 71) String.join(", ", Arrays.stream(m.getParameters()).map(p -> toSignature(p)).collect(Collectors.toList())) ==> java.lang.String.join(java.lang.CharSequence, java.lang.Iterable<? extends java.lang.CharSequence>)
  Line 71) Arrays.stream(m.getParameters()).map(p -> toSignature(p)).collect(Collectors.toList()) ==> java.util.stream.Stream.collect(java.util.stream.Collector<? super T, A, R>)
  Line 71) Arrays.stream(m.getParameters()).map(p -> toSignature(p)) ==> java.util.stream.Stream.map(java.util.function.Function<? super T, ? extends R>)
  Line 71) Arrays.stream(m.getParameters()) ==> java.util.Arrays.stream(T[])
  Line 71) m.getParameters() ==> java.lang.reflect.Executable.getParameters()
  Line 71) toSignature(p) ==> com.github.javaparser.symbolsolver.logic.FunctionalInterfaceLogic.toSignature(java.lang.reflect.Parameter)
  Line 71) Collectors.toList() ==> java.util.stream.Collectors.toList()
  Line 75) p.getType().getCanonicalName() ==> java.lang.Class.getCanonicalName()
  Line 75) p.getType() ==> java.lang.reflect.Parameter.getType()
  Line 78) Arrays.stream(Object.class.getDeclaredMethods()).map(method -> getSignature(method)).collect(Collectors.toList()) ==> java.util.stream.Stream.collect(java.util.stream.Collector<? super T, A, R>)
  Line 78) Arrays.stream(Object.class.getDeclaredMethods()).map(method -> getSignature(method)) ==> java.util.stream.Stream.map(java.util.function.Function<? super T, ? extends R>)
  Line 78) Arrays.stream(Object.class.getDeclaredMethods()) ==> java.util.Arrays.stream(T[])
  Line 78) Object.class.getDeclaredMethods() ==> java.lang.Class.getDeclaredMethods()
  Line 79) getSignature(method) ==> com.github.javaparser.symbolsolver.logic.FunctionalInterfaceLogic.getSignature(java.lang.reflect.Method)
  Line 80) Collectors.toList() ==> java.util.stream.Collectors.toList()
  Line 83) OBJECT_METHODS_SIGNATURES.contains(m.getDeclaration().getSignature()) ==> java.util.List.contains(java.lang.Object)
  Line 83) m.getDeclaration().getSignature() ==> com.github.javaparser.symbolsolver.model.declarations.MethodLikeDeclaration.getSignature()
  Line 83) m.getDeclaration() ==> com.github.javaparser.symbolsolver.model.methods.MethodUsage.getDeclaration()
