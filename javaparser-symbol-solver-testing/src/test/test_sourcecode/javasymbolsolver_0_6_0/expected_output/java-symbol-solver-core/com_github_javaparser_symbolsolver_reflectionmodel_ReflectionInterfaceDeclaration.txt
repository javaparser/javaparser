  Line 56) clazz.isInterface() ==> java.lang.Class.isInterface()
  Line 71) isAssignableBy(new ReferenceTypeImpl(other, typeSolver)) ==> com.github.javaparser.symbolsolver.reflectionmodel.ReflectionInterfaceDeclaration.isAssignableBy(com.github.javaparser.symbolsolver.model.typesystem.Type)
  Line 76) clazz.getPackage() ==> java.lang.Class.getPackage()
  Line 77) clazz.getPackage().getName() ==> java.lang.Package.getName()
  Line 77) clazz.getPackage() ==> java.lang.Class.getPackage()
  Line 84) clazz.getCanonicalName() ==> java.lang.Class.getCanonicalName()
  Line 85) getPackageName() ==> com.github.javaparser.symbolsolver.reflectionmodel.ReflectionInterfaceDeclaration.getPackageName()
  Line 86) canonicalName.substring(getPackageName().length() + 1, canonicalName.length()) ==> java.lang.String.substring(int, int)
  Line 86) getPackageName().length() ==> java.lang.String.length()
  Line 86) getPackageName() ==> com.github.javaparser.symbolsolver.reflectionmodel.ReflectionInterfaceDeclaration.getPackageName()
  Line 86) canonicalName.length() ==> java.lang.String.length()
  Line 93) clazz.getCanonicalName() ==> java.lang.Class.getCanonicalName()
  Line 98) ReflectionMethodResolutionLogic.solveMethod(name, parameterTypes, staticOnly, typeSolver, this, clazz) ==> com.github.javaparser.symbolsolver.reflectionmodel.ReflectionMethodResolutionLogic.solveMethod(java.lang.String, java.util.List<com.github.javaparser.symbolsolver.model.typesystem.Type>, boolean, com.github.javaparser.symbolsolver.model.resolution.TypeSolver, com.github.javaparser.symbolsolver.model.declarations.ReferenceTypeDeclaration, java.lang.Class)
  Line 105) clazz.getCanonicalName() ==> java.lang.Class.getCanonicalName()
  Line 120) clazz.getCanonicalName().equals(that.clazz.getCanonicalName()) ==> java.lang.String.equals(java.lang.Object)
  Line 120) clazz.getCanonicalName() ==> java.lang.Class.getCanonicalName()
  Line 120) that.clazz.getCanonicalName() ==> java.lang.Class.getCanonicalName()
  Line 122) getTypeParameters().equals(that.getTypeParameters()) ==> java.util.List.equals(java.lang.Object)
  Line 122) getTypeParameters() ==> com.github.javaparser.symbolsolver.reflectionmodel.ReflectionInterfaceDeclaration.getTypeParameters()
  Line 122) that.getTypeParameters() ==> com.github.javaparser.symbolsolver.reflectionmodel.ReflectionInterfaceDeclaration.getTypeParameters()
  Line 131) clazz.hashCode() ==> java.lang.Object.hashCode()
  Line 135) ReflectionMethodResolutionLogic.solveMethodAsUsage(name, parameterTypes, typeSolver, invokationContext, typeParameterValues, this, clazz) ==> com.github.javaparser.symbolsolver.reflectionmodel.ReflectionMethodResolutionLogic.solveMethodAsUsage(java.lang.String, java.util.List<com.github.javaparser.symbolsolver.model.typesystem.Type>, com.github.javaparser.symbolsolver.model.resolution.TypeSolver, com.github.javaparser.symbolsolver.core.resolution.Context, java.util.List<com.github.javaparser.symbolsolver.model.typesystem.Type>, com.github.javaparser.symbolsolver.model.declarations.ReferenceTypeDeclaration, java.lang.Class)
  Line 137) res.isPresent() ==> java.util.Optional.isPresent()
  Line 140) res.get() ==> java.util.Optional.get()
  Line 144) methodUsage.getParamType(i) ==> com.github.javaparser.symbolsolver.model.methods.MethodUsage.getParamType(int)
  Line 147) parameters.add(inferenceContext.addPair(formalType, actualType)) ==> java.util.List.add(E)
  Line 147) inferenceContext.addPair(formalType, actualType) ==> com.github.javaparser.symbolsolver.logic.InferenceContext.addPair(com.github.javaparser.symbolsolver.model.typesystem.Type, com.github.javaparser.symbolsolver.model.typesystem.Type)
  Line 151) inferenceContext.addSingle(methodUsage.returnType()) ==> com.github.javaparser.symbolsolver.logic.InferenceContext.addSingle(com.github.javaparser.symbolsolver.model.typesystem.Type)
  Line 151) methodUsage.returnType() ==> com.github.javaparser.symbolsolver.model.methods.MethodUsage.returnType()
  Line 152) parameters.size() ==> java.util.List.size()
  Line 153) methodUsage.replaceParamType(j, inferenceContext.resolve(parameters.get(j))) ==> com.github.javaparser.symbolsolver.model.methods.MethodUsage.replaceParamType(int, com.github.javaparser.symbolsolver.model.typesystem.Type)
  Line 153) inferenceContext.resolve(parameters.get(j)) ==> com.github.javaparser.symbolsolver.logic.InferenceContext.resolve(com.github.javaparser.symbolsolver.model.typesystem.Type)
  Line 153) parameters.get(j) ==> java.util.List.get(int)
  Line 155) methodUsage.replaceReturnType(inferenceContext.resolve(returnType)) ==> com.github.javaparser.symbolsolver.model.methods.MethodUsage.replaceReturnType(com.github.javaparser.symbolsolver.model.typesystem.Type)
  Line 155) inferenceContext.resolve(returnType) ==> com.github.javaparser.symbolsolver.logic.InferenceContext.resolve(com.github.javaparser.symbolsolver.model.typesystem.Type)
  Line 156) Optional.of(methodUsage) ==> java.util.Optional.of(T)
  Line 158) Optional.empty() ==> java.util.Optional.empty()
  Line 168) isFunctionalInterface() ==> com.github.javaparser.symbolsolver.logic.AbstractTypeDeclaration.isFunctionalInterface()
  Line 170) other.getQualifiedName().equals(getQualifiedName()) ==> java.lang.String.equals(java.lang.Object)
  Line 170) other.getQualifiedName() ==> com.github.javaparser.symbolsolver.model.declarations.TypeDeclaration.getQualifiedName()
  Line 170) getQualifiedName() ==> com.github.javaparser.symbolsolver.reflectionmodel.ReflectionInterfaceDeclaration.getQualifiedName()
  Line 173) this.clazz.getSuperclass() ==> java.lang.Class.getSuperclass()
  Line 174) new ReflectionInterfaceDeclaration(clazz.getSuperclass(), typeSolver).canBeAssignedTo(other) ==> com.github.javaparser.symbolsolver.reflectionmodel.ReflectionInterfaceDeclaration.canBeAssignedTo(com.github.javaparser.symbolsolver.model.declarations.ReferenceTypeDeclaration)
  Line 174) clazz.getSuperclass() ==> java.lang.Class.getSuperclass()
  Line 177) clazz.getInterfaces() ==> java.lang.Class.getInterfaces()
  Line 178) new ReflectionInterfaceDeclaration(interfaze, typeSolver).canBeAssignedTo(other) ==> com.github.javaparser.symbolsolver.reflectionmodel.ReflectionInterfaceDeclaration.canBeAssignedTo(com.github.javaparser.symbolsolver.model.declarations.ReferenceTypeDeclaration)
  Line 183) other.getQualifiedName().equals(Object.class.getCanonicalName()) ==> java.lang.String.equals(java.lang.Object)
  Line 183) other.getQualifiedName() ==> com.github.javaparser.symbolsolver.model.declarations.TypeDeclaration.getQualifiedName()
  Line 183) Object.class.getCanonicalName() ==> java.lang.Class.getCanonicalName()
  Line 196) isFunctionalInterface() ==> com.github.javaparser.symbolsolver.logic.AbstractTypeDeclaration.isFunctionalInterface()
  Line 198) type.isArray() ==> com.github.javaparser.symbolsolver.model.typesystem.Type.isArray()
  Line 201) type.isPrimitive() ==> com.github.javaparser.symbolsolver.model.typesystem.Type.isPrimitive()
  Line 204) type.describe().equals(getQualifiedName()) ==> java.lang.String.equals(java.lang.Object)
  Line 204) type.describe() ==> com.github.javaparser.symbolsolver.model.typesystem.Type.describe()
  Line 204) getQualifiedName() ==> com.github.javaparser.symbolsolver.reflectionmodel.ReflectionInterfaceDeclaration.getQualifiedName()
  Line 209) otherTypeDeclaration.getTypeDeclaration().canBeAssignedTo(this) ==> com.github.javaparser.symbolsolver.model.declarations.ReferenceTypeDeclaration.canBeAssignedTo(com.github.javaparser.symbolsolver.model.declarations.ReferenceTypeDeclaration)
  Line 209) otherTypeDeclaration.getTypeDeclaration() ==> com.github.javaparser.symbolsolver.model.typesystem.ReferenceType.getTypeDeclaration()
  Line 222) reflectionClassAdapter.getField(name) ==> com.github.javaparser.symbolsolver.reflectionmodel.ReflectionClassAdapter.getField(java.lang.String)
  Line 227) reflectionClassAdapter.getAllFields() ==> com.github.javaparser.symbolsolver.reflectionmodel.ReflectionClassAdapter.getAllFields()
  Line 232) clazz.getFields() ==> java.lang.Class.getFields()
  Line 233) field.getName().equals(name) ==> java.lang.String.equals(java.lang.Object)
  Line 233) field.getName() ==> java.lang.reflect.Field.getName()
  Line 234) SymbolReference.solved(new ReflectionFieldDeclaration(field, typeSolver)) ==> com.github.javaparser.symbolsolver.model.resolution.SymbolReference.solved(S2)
  Line 237) SymbolReference.unsolved(ValueDeclaration.class) ==> com.github.javaparser.symbolsolver.model.resolution.SymbolReference.unsolved(java.lang.Class<S2>)
  Line 242) reflectionClassAdapter.getAncestors() ==> com.github.javaparser.symbolsolver.reflectionmodel.ReflectionClassAdapter.getAncestors()
  Line 247) reflectionClassAdapter.getDeclaredMethods() ==> com.github.javaparser.symbolsolver.reflectionmodel.ReflectionClassAdapter.getDeclaredMethods()
  Line 252) reflectionClassAdapter.hasField(name) ==> com.github.javaparser.symbolsolver.reflectionmodel.ReflectionClassAdapter.hasField(java.lang.String)
  Line 257) clazz.getSimpleName() ==> java.lang.Class.getSimpleName()
  Line 268) clazz.getInterfaces() ==> java.lang.Class.getInterfaces()
  Line 269) res.add(new ReferenceTypeImpl(new ReflectionInterfaceDeclaration(i, typeSolver), typeSolver)) ==> java.util.List.add(E)
  Line 276) reflectionClassAdapter.containerType() ==> com.github.javaparser.symbolsolver.reflectionmodel.ReflectionClassAdapter.containerType()
  Line 281) Arrays.stream(this.clazz.getDeclaredClasses()).map(ic -> ReflectionFactory.typeDeclarationFor(ic, typeSolver)).collect(Collectors.toSet()) ==> java.util.stream.Stream.collect(java.util.stream.Collector<? super T, A, R>)
  Line 281) Arrays.stream(this.clazz.getDeclaredClasses()).map(ic -> ReflectionFactory.typeDeclarationFor(ic, typeSolver)) ==> java.util.stream.Stream.map(java.util.function.Function<? super T, ? extends R>)
  Line 281) Arrays.stream(this.clazz.getDeclaredClasses()) ==> java.util.Arrays.stream(T[])
  Line 281) this.clazz.getDeclaredClasses() ==> java.lang.Class.getDeclaredClasses()
  Line 282) ReflectionFactory.typeDeclarationFor(ic, typeSolver) ==> com.github.javaparser.symbolsolver.reflectionmodel.ReflectionFactory.typeDeclarationFor(java.lang.Class<?>, com.github.javaparser.symbolsolver.model.resolution.TypeSolver)
  Line 283) Collectors.toSet() ==> java.util.stream.Collectors.toSet()
  Line 293) reflectionClassAdapter.hasDirectlyAnnotation(canonicalName) ==> com.github.javaparser.symbolsolver.reflectionmodel.ReflectionClassAdapter.hasDirectlyAnnotation(java.lang.String)
  Line 298) reflectionClassAdapter.getTypeParameters() ==> com.github.javaparser.symbolsolver.reflectionmodel.ReflectionClassAdapter.getTypeParameters()
  Line 303) ReflectionFactory.modifiersToAccessLevel(this.clazz.getModifiers()) ==> com.github.javaparser.symbolsolver.reflectionmodel.ReflectionFactory.modifiersToAccessLevel(int)
  Line 303) this.clazz.getModifiers() ==> java.lang.Class.getModifiers()
