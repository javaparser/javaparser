  Line 39) clazz.isArray() ==> java.lang.Class.isArray()
  Line 41) clazz.isPrimitive() ==> java.lang.Class.isPrimitive()
  Line 43) clazz.isInterface() ==> java.lang.Class.isInterface()
  Line 45) clazz.isEnum() ==> java.lang.Class.isEnum()
  Line 55) tv.getGenericDeclaration() ==> java.lang.reflect.TypeVariable.getGenericDeclaration()
  Line 60) typeUsageFor(pt.getRawType(), typeSolver).asReferenceType() ==> com.github.javaparser.symbolsolver.model.typesystem.Type.asReferenceType()
  Line 60) typeUsageFor(pt.getRawType(), typeSolver) ==> com.github.javaparser.symbolsolver.reflectionmodel.ReflectionFactory.typeUsageFor(java.lang.reflect.Type, com.github.javaparser.symbolsolver.model.resolution.TypeSolver)
  Line 60) pt.getRawType() ==> java.lang.reflect.ParameterizedType.getRawType()
  Line 62) actualTypes.addAll(Arrays.asList(pt.getActualTypeArguments())) ==> java.util.List.addAll(java.util.Collection<? extends E>)
  Line 62) Arrays.asList(pt.getActualTypeArguments()) ==> java.util.Arrays.asList(T...)
  Line 62) pt.getActualTypeArguments() ==> java.lang.reflect.ParameterizedType.getActualTypeArguments()
  Line 64) rawType.transformTypeParameters(tp -> typeUsageFor(actualTypes.remove(0), typeSolver)).asReferenceType() ==> com.github.javaparser.symbolsolver.model.typesystem.Type.asReferenceType()
  Line 64) rawType.transformTypeParameters(tp -> typeUsageFor(actualTypes.remove(0), typeSolver)) ==> com.github.javaparser.symbolsolver.model.typesystem.ReferenceType.transformTypeParameters(com.github.javaparser.symbolsolver.model.typesystem.TypeTransformer)
  Line 64) typeUsageFor(actualTypes.remove(0), typeSolver) ==> com.github.javaparser.symbolsolver.reflectionmodel.ReflectionFactory.typeUsageFor(java.lang.reflect.Type, com.github.javaparser.symbolsolver.model.resolution.TypeSolver)
  Line 64) actualTypes.remove(0) ==> java.util.List.remove(int)
  Line 68) c.isPrimitive() ==> java.lang.Class.isPrimitive()
  Line 69) c.getName().equals(Void.TYPE.getName()) ==> java.lang.String.equals(java.lang.Object)
  Line 69) c.getName() ==> java.lang.Class.getName()
  Line 69) Void.TYPE.getName() ==> java.lang.Class.getName()
  Line 72) PrimitiveType.byName(c.getName()) ==> com.github.javaparser.symbolsolver.model.typesystem.PrimitiveType.byName(java.lang.String)
  Line 72) c.getName() ==> java.lang.Class.getName()
  Line 74) c.isArray() ==> java.lang.Class.isArray()
  Line 75) typeUsageFor(c.getComponentType(), typeSolver) ==> com.github.javaparser.symbolsolver.reflectionmodel.ReflectionFactory.typeUsageFor(java.lang.reflect.Type, com.github.javaparser.symbolsolver.model.resolution.TypeSolver)
  Line 75) c.getComponentType() ==> java.lang.Class.getComponentType()
  Line 77) typeDeclarationFor(c, typeSolver) ==> com.github.javaparser.symbolsolver.reflectionmodel.ReflectionFactory.typeDeclarationFor(java.lang.Class<?>, com.github.javaparser.symbolsolver.model.resolution.TypeSolver)
  Line 81) typeUsageFor(genericArrayType.getGenericComponentType(), typeSolver) ==> com.github.javaparser.symbolsolver.reflectionmodel.ReflectionFactory.typeUsageFor(java.lang.reflect.Type, com.github.javaparser.symbolsolver.model.resolution.TypeSolver)
  Line 81) genericArrayType.getGenericComponentType() ==> java.lang.reflect.GenericArrayType.getGenericComponentType()
  Line 84) wildcardType.getLowerBounds() ==> java.lang.reflect.WildcardType.getLowerBounds()
  Line 84) wildcardType.getUpperBounds() ==> java.lang.reflect.WildcardType.getUpperBounds()
  Line 85) wildcardType.getUpperBounds() ==> java.lang.reflect.WildcardType.getUpperBounds()
  Line 85) wildcardType.getUpperBounds()[0].getTypeName().equals("java.lang.Object") ==> java.lang.String.equals(java.lang.Object)
  Line 85) wildcardType.getUpperBounds()[0].getTypeName() ==> java.lang.reflect.Type.getTypeName()
  Line 85) wildcardType.getUpperBounds() ==> java.lang.reflect.WildcardType.getUpperBounds()
  Line 89) wildcardType.getLowerBounds() ==> java.lang.reflect.WildcardType.getLowerBounds()
  Line 90) wildcardType.getLowerBounds() ==> java.lang.reflect.WildcardType.getLowerBounds()
  Line 93) Wildcard.superBound(typeUsageFor(wildcardType.getLowerBounds()[0], typeSolver)) ==> com.github.javaparser.symbolsolver.model.typesystem.Wildcard.superBound(com.github.javaparser.symbolsolver.model.typesystem.Type)
  Line 93) typeUsageFor(wildcardType.getLowerBounds()[0], typeSolver) ==> com.github.javaparser.symbolsolver.reflectionmodel.ReflectionFactory.typeUsageFor(java.lang.reflect.Type, com.github.javaparser.symbolsolver.model.resolution.TypeSolver)
  Line 93) wildcardType.getLowerBounds() ==> java.lang.reflect.WildcardType.getLowerBounds()
  Line 95) wildcardType.getUpperBounds() ==> java.lang.reflect.WildcardType.getUpperBounds()
  Line 96) wildcardType.getUpperBounds() ==> java.lang.reflect.WildcardType.getUpperBounds()
  Line 99) Wildcard.extendsBound(typeUsageFor(wildcardType.getUpperBounds()[0], typeSolver)) ==> com.github.javaparser.symbolsolver.model.typesystem.Wildcard.extendsBound(com.github.javaparser.symbolsolver.model.typesystem.Type)
  Line 99) typeUsageFor(wildcardType.getUpperBounds()[0], typeSolver) ==> com.github.javaparser.symbolsolver.reflectionmodel.ReflectionFactory.typeUsageFor(java.lang.reflect.Type, com.github.javaparser.symbolsolver.model.resolution.TypeSolver)
  Line 99) wildcardType.getUpperBounds() ==> java.lang.reflect.WildcardType.getUpperBounds()
  Line 103) type.getClass().getCanonicalName() ==> java.lang.Class.getCanonicalName()
  Line 103) type.getClass() ==> java.lang.Object.getClass()
  Line 108) Modifier.isPublic(modifiers) ==> java.lang.reflect.Modifier.isPublic(int)
  Line 110) Modifier.isProtected(modifiers) ==> java.lang.reflect.Modifier.isProtected(int)
  Line 112) Modifier.isPrivate(modifiers) ==> java.lang.reflect.Modifier.isPrivate(int)
