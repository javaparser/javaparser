  Line 58) wrappedNode.getParameters() ==> com.github.javaparser.ast.expr.LambdaExpr.getParameters()
  Line 59) JavaParserFactory.getSymbolDeclarator(parameter, typeSolver) ==> com.github.javaparser.symbolsolver.javaparsermodel.JavaParserFactory.getSymbolDeclarator(com.github.javaparser.ast.Node, com.github.javaparser.symbolsolver.model.resolution.TypeSolver)
  Line 61) sb.getSymbolDeclarations() ==> com.github.javaparser.symbolsolver.resolution.SymbolDeclarator.getSymbolDeclarations()
  Line 62) decl.getName().equals(name) ==> java.lang.String.equals(java.lang.Object)
  Line 62) decl.getName() ==> com.github.javaparser.symbolsolver.model.declarations.Declaration.getName()
  Line 63) getParentNode(wrappedNode) ==> com.github.javaparser.symbolsolver.javaparser.Navigator.getParentNode(com.github.javaparser.ast.Node)
  Line 64) getParentNode(wrappedNode) ==> com.github.javaparser.symbolsolver.javaparser.Navigator.getParentNode(com.github.javaparser.ast.Node)
  Line 65) JavaParserFacade.get(typeSolver).solveMethodAsUsage(methodCallExpr) ==> com.github.javaparser.symbolsolver.javaparsermodel.JavaParserFacade.solveMethodAsUsage(com.github.javaparser.ast.expr.MethodCallExpr)
  Line 65) JavaParserFacade.get(typeSolver) ==> com.github.javaparser.symbolsolver.javaparsermodel.JavaParserFacade.get(com.github.javaparser.symbolsolver.model.resolution.TypeSolver)
  Line 66) pos(methodCallExpr, wrappedNode) ==> com.github.javaparser.symbolsolver.javaparsermodel.contexts.LambdaExprContext.pos(com.github.javaparser.ast.expr.MethodCallExpr, com.github.javaparser.ast.expr.Expression)
  Line 67) methodUsage.getParamTypes().get(i) ==> java.util.List.get(int)
  Line 67) methodUsage.getParamTypes() ==> com.github.javaparser.symbolsolver.model.methods.MethodUsage.getParamTypes()
  Line 70) FunctionalInterfaceLogic.getFunctionalMethod(lambdaType) ==> com.github.javaparser.symbolsolver.logic.FunctionalInterfaceLogic.getFunctionalMethod(com.github.javaparser.symbolsolver.model.typesystem.Type)
  Line 71) functionalMethodOpt.isPresent() ==> java.util.Optional.isPresent()
  Line 72) functionalMethodOpt.get() ==> java.util.Optional.get()
  Line 77) inferenceContext.addPair(lambdaType, new ReferenceTypeImpl(lambdaType.asReferenceType().getTypeDeclaration(), typeSolver)) ==> com.github.javaparser.symbolsolver.logic.InferenceContext.addPair(com.github.javaparser.symbolsolver.model.typesystem.Type, com.github.javaparser.symbolsolver.model.typesystem.Type)
  Line 77) lambdaType.asReferenceType().getTypeDeclaration() ==> com.github.javaparser.symbolsolver.model.typesystem.ReferenceType.getTypeDeclaration()
  Line 77) lambdaType.asReferenceType() ==> com.github.javaparser.symbolsolver.model.typesystem.Type.asReferenceType()
  Line 82) wrappedNode.getParameters().size() ==> com.github.javaparser.ast.NodeList.size()
  Line 82) wrappedNode.getParameters() ==> com.github.javaparser.ast.expr.LambdaExpr.getParameters()
  Line 83) wrappedNode.getParameter(lambdaParamIndex).getName().getIdentifier().equals(name) ==> java.lang.String.equals(java.lang.Object)
  Line 83) wrappedNode.getParameter(lambdaParamIndex).getName().getIdentifier() ==> com.github.javaparser.ast.expr.SimpleName.getIdentifier()
  Line 83) wrappedNode.getParameter(lambdaParamIndex).getName() ==> com.github.javaparser.ast.body.Parameter.getName()
  Line 83) wrappedNode.getParameter(lambdaParamIndex) ==> com.github.javaparser.ast.nodeTypes.NodeWithParameters.getParameter(int)
  Line 88) Optional.empty() ==> java.util.Optional.empty()
  Line 91) inferenceContext.resolve(inferenceContext.addSingle(functionalMethod.getParamType(lambdaParamIndex))) ==> com.github.javaparser.symbolsolver.logic.InferenceContext.resolve(com.github.javaparser.symbolsolver.model.typesystem.Type)
  Line 91) inferenceContext.addSingle(functionalMethod.getParamType(lambdaParamIndex)) ==> com.github.javaparser.symbolsolver.logic.InferenceContext.addSingle(com.github.javaparser.symbolsolver.model.typesystem.Type)
  Line 91) functionalMethod.getParamType(lambdaParamIndex) ==> com.github.javaparser.symbolsolver.model.methods.MethodUsage.getParamType(int)
  Line 94) argType.isWildcard() ==> com.github.javaparser.symbolsolver.model.typesystem.Type.isWildcard()
  Line 95) LambdaConstraintType.bound(argType.asWildcard().getBoundedType()) ==> com.github.javaparser.symbolsolver.model.typesystem.LambdaConstraintType.bound(com.github.javaparser.symbolsolver.model.typesystem.Type)
  Line 95) argType.asWildcard().getBoundedType() ==> com.github.javaparser.symbolsolver.model.typesystem.Wildcard.getBoundedType()
  Line 95) argType.asWildcard() ==> com.github.javaparser.symbolsolver.model.typesystem.Type.asWildcard()
  Line 97) LambdaConstraintType.bound(argType) ==> com.github.javaparser.symbolsolver.model.typesystem.LambdaConstraintType.bound(com.github.javaparser.symbolsolver.model.typesystem.Type)
  Line 100) Optional.of(value) ==> java.util.Optional.of(T)
  Line 102) Optional.empty() ==> java.util.Optional.empty()
  Line 104) getParentNode(wrappedNode) ==> com.github.javaparser.symbolsolver.javaparser.Navigator.getParentNode(com.github.javaparser.ast.Node)
  Line 105) getParentNode(wrappedNode) ==> com.github.javaparser.symbolsolver.javaparser.Navigator.getParentNode(com.github.javaparser.ast.Node)
  Line 106) JavaParserFacade.get(typeSolver).convertToUsageVariableType(variableDeclarator) ==> com.github.javaparser.symbolsolver.javaparsermodel.JavaParserFacade.convertToUsageVariableType(com.github.javaparser.ast.body.VariableDeclarator)
  Line 106) JavaParserFacade.get(typeSolver) ==> com.github.javaparser.symbolsolver.javaparsermodel.JavaParserFacade.get(com.github.javaparser.symbolsolver.model.resolution.TypeSolver)
  Line 107) FunctionalInterfaceLogic.getFunctionalMethod(t) ==> com.github.javaparser.symbolsolver.logic.FunctionalInterfaceLogic.getFunctionalMethod(com.github.javaparser.symbolsolver.model.typesystem.Type)
  Line 108) functionalMethod.isPresent() ==> java.util.Optional.isPresent()
  Line 109) functionalMethod.get().getParamType(index) ==> com.github.javaparser.symbolsolver.model.methods.MethodUsage.getParamType(int)
  Line 109) functionalMethod.get() ==> java.util.Optional.get()
  Line 113) lambdaType.isReferenceType() ==> com.github.javaparser.symbolsolver.model.typesystem.Type.isReferenceType()
  Line 114) lambdaType.asReferenceType().getTypeParametersMap() ==> com.github.javaparser.symbolsolver.model.typesystem.ReferenceType.getTypeParametersMap()
  Line 114) lambdaType.asReferenceType() ==> com.github.javaparser.symbolsolver.model.typesystem.Type.asReferenceType()
  Line 115) entry._2.isTypeVariable() ==> com.github.javaparser.symbolsolver.model.typesystem.Type.isTypeVariable()
  Line 115) entry._2.asTypeParameter().declaredOnType() ==> com.github.javaparser.symbolsolver.model.declarations.TypeParameterDeclaration.declaredOnType()
  Line 115) entry._2.asTypeParameter() ==> com.github.javaparser.symbolsolver.model.typesystem.Type.asTypeParameter()
  Line 116) t.asReferenceType().typeParametersMap().getValue(entry._1) ==> com.github.javaparser.symbolsolver.model.typesystem.parametrization.TypeParametersMap.getValue(com.github.javaparser.symbolsolver.model.declarations.TypeParameterDeclaration)
  Line 116) t.asReferenceType().typeParametersMap() ==> com.github.javaparser.symbolsolver.model.typesystem.ReferenceType.typeParametersMap()
  Line 116) t.asReferenceType() ==> com.github.javaparser.symbolsolver.model.typesystem.Type.asReferenceType()
  Line 117) lambdaType.replaceTypeVariables(entry._1, ot, inferredTypes) ==> com.github.javaparser.symbolsolver.model.typesystem.Type.replaceTypeVariables(com.github.javaparser.symbolsolver.model.declarations.TypeParameterDeclaration, com.github.javaparser.symbolsolver.model.typesystem.Type, java.util.Map<com.github.javaparser.symbolsolver.model.declarations.TypeParameterDeclaration, com.github.javaparser.symbolsolver.model.typesystem.Type>)
  Line 120) lambdaType.isTypeVariable() ==> com.github.javaparser.symbolsolver.model.typesystem.Type.isTypeVariable()
  Line 120) lambdaType.asTypeParameter().declaredOnType() ==> com.github.javaparser.symbolsolver.model.declarations.TypeParameterDeclaration.declaredOnType()
  Line 120) lambdaType.asTypeParameter() ==> com.github.javaparser.symbolsolver.model.typesystem.Type.asTypeParameter()
  Line 121) t.asReferenceType().typeParametersMap().getValue(lambdaType.asTypeParameter()) ==> com.github.javaparser.symbolsolver.model.typesystem.parametrization.TypeParametersMap.getValue(com.github.javaparser.symbolsolver.model.declarations.TypeParameterDeclaration)
  Line 121) t.asReferenceType().typeParametersMap() ==> com.github.javaparser.symbolsolver.model.typesystem.ReferenceType.typeParametersMap()
  Line 121) t.asReferenceType() ==> com.github.javaparser.symbolsolver.model.typesystem.Type.asReferenceType()
  Line 121) lambdaType.asTypeParameter() ==> com.github.javaparser.symbolsolver.model.typesystem.Type.asTypeParameter()
  Line 125) Optional.of(value) ==> java.util.Optional.of(T)
  Line 138) getParent().solveSymbolAsValue(name, typeSolver) ==> com.github.javaparser.symbolsolver.core.resolution.Context.solveSymbolAsValue(java.lang.String, com.github.javaparser.symbolsolver.model.resolution.TypeSolver)
  Line 138) getParent() ==> com.github.javaparser.symbolsolver.javaparsermodel.contexts.AbstractJavaParserContext.getParent()
  Line 143) wrappedNode.getParameters() ==> com.github.javaparser.ast.expr.LambdaExpr.getParameters()
  Line 144) JavaParserFactory.getSymbolDeclarator(parameter, typeSolver) ==> com.github.javaparser.symbolsolver.javaparsermodel.JavaParserFactory.getSymbolDeclarator(com.github.javaparser.ast.Node, com.github.javaparser.symbolsolver.model.resolution.TypeSolver)
  Line 145) solveWith(sb, name) ==> com.github.javaparser.symbolsolver.javaparsermodel.contexts.AbstractJavaParserContext.solveWith(com.github.javaparser.symbolsolver.resolution.SymbolDeclarator, java.lang.String)
  Line 146) symbolReference.isSolved() ==> com.github.javaparser.symbolsolver.model.resolution.SymbolReference.isSolved()
  Line 152) getParent().solveSymbol(name, typeSolver) ==> com.github.javaparser.symbolsolver.core.resolution.Context.solveSymbol(java.lang.String, com.github.javaparser.symbolsolver.model.resolution.TypeSolver)
  Line 152) getParent() ==> com.github.javaparser.symbolsolver.javaparsermodel.contexts.AbstractJavaParserContext.getParent()
  Line 157) getParent().solveType(name, typeSolver) ==> com.github.javaparser.symbolsolver.core.resolution.Context.solveType(java.lang.String, com.github.javaparser.symbolsolver.model.resolution.TypeSolver)
  Line 157) getParent() ==> com.github.javaparser.symbolsolver.javaparsermodel.contexts.AbstractJavaParserContext.getParent()
  Line 163) getParent().solveMethod(name, argumentsTypes, false, typeSolver) ==> com.github.javaparser.symbolsolver.core.resolution.Context.solveMethod(java.lang.String, java.util.List<com.github.javaparser.symbolsolver.model.typesystem.Type>, boolean, com.github.javaparser.symbolsolver.model.resolution.TypeSolver)
  Line 163) getParent() ==> com.github.javaparser.symbolsolver.javaparsermodel.contexts.AbstractJavaParserContext.getParent()
  Line 171) symbolDeclarator.getSymbolDeclarations() ==> com.github.javaparser.symbolsolver.resolution.SymbolDeclarator.getSymbolDeclarations()
  Line 172) decl.getName().equals(name) ==> java.lang.String.equals(java.lang.Object)
  Line 172) decl.getName() ==> com.github.javaparser.symbolsolver.model.declarations.Declaration.getName()
  Line 177) Optional.empty() ==> java.util.Optional.empty()
  Line 186) callExpr.getArguments() ==> com.github.javaparser.ast.expr.MethodCallExpr.getArguments()
