  Line 44) typeVariable.getGenericDeclaration() ==> java.lang.reflect.TypeVariable.getGenericDeclaration()
  Line 46) ReflectionFactory.typeDeclarationFor((Class) genericDeclaration, typeSolver) ==> com.github.javaparser.symbolsolver.reflectionmodel.ReflectionFactory.typeDeclarationFor(java.lang.Class<?>, com.github.javaparser.symbolsolver.model.resolution.TypeSolver)
  Line 63) getQualifiedName().equals(that.getQualifiedName()) ==> java.lang.String.equals(java.lang.Object)
  Line 63) getQualifiedName() ==> com.github.javaparser.symbolsolver.model.declarations.TypeParameterDeclaration.getQualifiedName()
  Line 63) that.getQualifiedName() ==> com.github.javaparser.symbolsolver.model.declarations.TypeParameterDeclaration.getQualifiedName()
  Line 66) declaredOnType() ==> com.github.javaparser.symbolsolver.model.declarations.TypeParameterDeclaration.declaredOnType()
  Line 66) that.declaredOnType() ==> com.github.javaparser.symbolsolver.model.declarations.TypeParameterDeclaration.declaredOnType()
  Line 69) declaredOnMethod() ==> com.github.javaparser.symbolsolver.model.declarations.TypeParameterDeclaration.declaredOnMethod()
  Line 69) that.declaredOnMethod() ==> com.github.javaparser.symbolsolver.model.declarations.TypeParameterDeclaration.declaredOnMethod()
  Line 78) typeVariable.hashCode() ==> java.lang.Object.hashCode()
  Line 79) container.hashCode() ==> java.lang.Object.hashCode()
  Line 85) typeVariable.getName() ==> java.lang.reflect.TypeVariable.getName()
  Line 91) ((ReferenceTypeDeclaration) container).getQualifiedName() ==> com.github.javaparser.symbolsolver.model.declarations.TypeDeclaration.getQualifiedName()
  Line 93) ((MethodLikeDeclaration) container).getQualifiedSignature() ==> com.github.javaparser.symbolsolver.model.declarations.MethodLikeDeclaration.getQualifiedSignature()
  Line 100) ((ReferenceTypeDeclaration) container).getId() ==> com.github.javaparser.symbolsolver.model.declarations.TypeDeclaration.getId()
  Line 102) ((MethodLikeDeclaration) container).getQualifiedSignature() ==> com.github.javaparser.symbolsolver.model.declarations.MethodLikeDeclaration.getQualifiedSignature()
  Line 113) Arrays.stream(typeVariable.getBounds()).map((refB) -> Bound.extendsBound(ReflectionFactory.typeUsageFor(refB, typeSolver))).collect(Collectors.toList()) ==> java.util.stream.Stream.collect(java.util.stream.Collector<? super T, A, R>)
  Line 113) Arrays.stream(typeVariable.getBounds()).map((refB) -> Bound.extendsBound(ReflectionFactory.typeUsageFor(refB, typeSolver))) ==> java.util.stream.Stream.map(java.util.function.Function<? super T, ? extends R>)
  Line 113) Arrays.stream(typeVariable.getBounds()) ==> java.util.Arrays.stream(T[])
  Line 113) typeVariable.getBounds() ==> java.lang.reflect.TypeVariable.getBounds()
  Line 113) Bound.extendsBound(ReflectionFactory.typeUsageFor(refB, typeSolver)) ==> com.github.javaparser.symbolsolver.model.declarations.TypeParameterDeclaration.Bound.extendsBound(com.github.javaparser.symbolsolver.model.typesystem.Type)
  Line 113) ReflectionFactory.typeUsageFor(refB, typeSolver) ==> com.github.javaparser.symbolsolver.reflectionmodel.ReflectionFactory.typeUsageFor(java.lang.reflect.Type, com.github.javaparser.symbolsolver.model.resolution.TypeSolver)
  Line 113) Collectors.toList() ==> java.util.stream.Collectors.toList()
  Line 126) Optional.of((ReferenceTypeDeclaration) container) ==> java.util.Optional.of(T)
  Line 128) Optional.empty() ==> java.util.Optional.empty()
