  Line 36) clazz.getGenericSuperclass() ==> java.lang.Class.getGenericSuperclass()
  Line 39) clazz.getGenericSuperclass() ==> java.lang.Class.getGenericSuperclass()
  Line 42) Arrays.stream(parameterizedType.getActualTypeArguments()).map((t) -> ReflectionFactory.typeUsageFor(t, typeSolver)).collect(Collectors.toList()) ==> java.util.stream.Stream.collect(java.util.stream.Collector<? super T, A, R>)
  Line 42) Arrays.stream(parameterizedType.getActualTypeArguments()).map((t) -> ReflectionFactory.typeUsageFor(t, typeSolver)) ==> java.util.stream.Stream.map(java.util.function.Function<? super T, ? extends R>)
  Line 42) Arrays.stream(parameterizedType.getActualTypeArguments()) ==> java.util.Arrays.stream(T[])
  Line 42) parameterizedType.getActualTypeArguments() ==> java.lang.reflect.ParameterizedType.getActualTypeArguments()
  Line 43) ReflectionFactory.typeUsageFor(t, typeSolver) ==> com.github.javaparser.symbolsolver.reflectionmodel.ReflectionFactory.typeUsageFor(java.lang.reflect.Type, com.github.javaparser.symbolsolver.model.resolution.TypeSolver)
  Line 44) Collectors.toList() ==> java.util.stream.Collectors.toList()
  Line 45) clazz.getSuperclass() ==> java.lang.Class.getSuperclass()
  Line 47) clazz.getSuperclass() ==> java.lang.Class.getSuperclass()
  Line 52) clazz.getGenericInterfaces() ==> java.lang.Class.getGenericInterfaces()
  Line 55) Arrays.stream(parameterizedType.getActualTypeArguments()).map((t) -> ReflectionFactory.typeUsageFor(t, typeSolver)).collect(Collectors.toList()) ==> java.util.stream.Stream.collect(java.util.stream.Collector<? super T, A, R>)
  Line 55) Arrays.stream(parameterizedType.getActualTypeArguments()).map((t) -> ReflectionFactory.typeUsageFor(t, typeSolver)) ==> java.util.stream.Stream.map(java.util.function.Function<? super T, ? extends R>)
  Line 55) Arrays.stream(parameterizedType.getActualTypeArguments()) ==> java.util.Arrays.stream(T[])
  Line 55) parameterizedType.getActualTypeArguments() ==> java.lang.reflect.ParameterizedType.getActualTypeArguments()
  Line 56) ReflectionFactory.typeUsageFor(t, typeSolver) ==> com.github.javaparser.symbolsolver.reflectionmodel.ReflectionFactory.typeUsageFor(java.lang.reflect.Type, com.github.javaparser.symbolsolver.model.resolution.TypeSolver)
  Line 57) Collectors.toList() ==> java.util.stream.Collectors.toList()
  Line 58) interfaces.add(new ReferenceTypeImpl(new ReflectionInterfaceDeclaration((Class<?>) ((ParameterizedType) superInterface).getRawType(), typeSolver), typeParameters, typeSolver)) ==> java.util.List.add(E)
  Line 58) ((ParameterizedType) superInterface).getRawType() ==> java.lang.reflect.ParameterizedType.getRawType()
  Line 60) interfaces.add(new ReferenceTypeImpl(new ReflectionInterfaceDeclaration((Class<?>) superInterface, typeSolver), typeSolver)) ==> java.util.List.add(E)
  Line 68) getSuperClass() ==> com.github.javaparser.symbolsolver.reflectionmodel.ReflectionClassAdapter.getSuperClass()
  Line 69) getSuperClass() ==> com.github.javaparser.symbolsolver.reflectionmodel.ReflectionClassAdapter.getSuperClass()
  Line 70) ancestors.add(superClass) ==> java.util.List.add(E)
  Line 73) ancestors.add(object) ==> java.util.List.add(E)
  Line 75) ancestors.addAll(getInterfaces()) ==> java.util.List.addAll(java.util.Collection<? extends E>)
  Line 75) getInterfaces() ==> com.github.javaparser.symbolsolver.reflectionmodel.ReflectionClassAdapter.getInterfaces()
  Line 76) ancestors.size() ==> java.util.List.size()
  Line 77) ancestors.get(i) ==> java.util.List.get(int)
  Line 78) ancestor.hasName() ==> com.github.javaparser.symbolsolver.model.typesystem.ReferenceType.hasName()
  Line 78) ancestor.getQualifiedName().equals(Object.class.getCanonicalName()) ==> java.lang.String.equals(java.lang.Object)
  Line 78) ancestor.getQualifiedName() ==> com.github.javaparser.symbolsolver.model.typesystem.ReferenceType.getQualifiedName()
  Line 78) Object.class.getCanonicalName() ==> java.lang.Class.getCanonicalName()
  Line 79) ancestors.remove(i) ==> java.util.List.remove(int)
  Line 87) clazz.getDeclaredFields() ==> java.lang.Class.getDeclaredFields()
  Line 88) field.getName().equals(name) ==> java.lang.String.equals(java.lang.Object)
  Line 88) field.getName() ==> java.lang.reflect.Field.getName()
  Line 92) typeDeclaration.getAllAncestors() ==> com.github.javaparser.symbolsolver.model.declarations.ReferenceTypeDeclaration.getAllAncestors()
  Line 93) ancestor.getTypeDeclaration().hasField(name) ==> com.github.javaparser.symbolsolver.model.declarations.ReferenceTypeDeclaration.hasField(java.lang.String)
  Line 93) ancestor.getTypeDeclaration() ==> com.github.javaparser.symbolsolver.model.typesystem.ReferenceType.getTypeDeclaration()
  Line 94) ancestor.getTypeDeclaration().getField(name) ==> com.github.javaparser.symbolsolver.model.declarations.ReferenceTypeDeclaration.getField(java.lang.String)
  Line 94) ancestor.getTypeDeclaration() ==> com.github.javaparser.symbolsolver.model.typesystem.ReferenceType.getTypeDeclaration()
  Line 95) reflectionFieldDeclaration.replaceType(ancestor.getFieldType(name).get()) ==> com.github.javaparser.symbolsolver.reflectionmodel.ReflectionFieldDeclaration.replaceType(com.github.javaparser.symbolsolver.model.typesystem.Type)
  Line 95) ancestor.getFieldType(name).get() ==> java.util.Optional.get()
  Line 95) ancestor.getFieldType(name) ==> com.github.javaparser.symbolsolver.model.typesystem.ReferenceType.getFieldType(java.lang.String)
  Line 102) clazz.getDeclaredFields() ==> java.lang.Class.getDeclaredFields()
  Line 103) field.getName().equals(name) ==> java.lang.String.equals(java.lang.Object)
  Line 103) field.getName() ==> java.lang.reflect.Field.getName()
  Line 107) getSuperClass() ==> com.github.javaparser.symbolsolver.reflectionmodel.ReflectionClassAdapter.getSuperClass()
  Line 111) superclass.getTypeDeclaration().hasField(name) ==> com.github.javaparser.symbolsolver.model.declarations.ReferenceTypeDeclaration.hasField(java.lang.String)
  Line 111) superclass.getTypeDeclaration() ==> com.github.javaparser.symbolsolver.model.typesystem.ReferenceType.getTypeDeclaration()
  Line 117) clazz.getDeclaredFields() ==> java.lang.Class.getDeclaredFields()
  Line 118) fields.add(new ReflectionFieldDeclaration(field, typeSolver)) ==> java.util.ArrayList.add(E)
  Line 120) typeDeclaration.getAllAncestors() ==> com.github.javaparser.symbolsolver.model.declarations.ReferenceTypeDeclaration.getAllAncestors()
  Line 121) fields.addAll(ancestor.getTypeDeclaration().getAllFields()) ==> java.util.ArrayList.addAll(java.util.Collection<? extends E>)
  Line 121) ancestor.getTypeDeclaration().getAllFields() ==> com.github.javaparser.symbolsolver.model.declarations.ReferenceTypeDeclaration.getAllFields()
  Line 121) ancestor.getTypeDeclaration() ==> com.github.javaparser.symbolsolver.model.typesystem.ReferenceType.getTypeDeclaration()
  Line 127) Arrays.stream(clazz.getDeclaredMethods()).filter(m -> !m.isSynthetic() && !m.isBridge()).map(m -> new ReflectionMethodDeclaration(m, typeSolver)).collect(Collectors.toSet()) ==> java.util.stream.Stream.collect(java.util.stream.Collector<? super T, A, R>)
  Line 127) Arrays.stream(clazz.getDeclaredMethods()).filter(m -> !m.isSynthetic() && !m.isBridge()).map(m -> new ReflectionMethodDeclaration(m, typeSolver)) ==> java.util.stream.Stream.map(java.util.function.Function<? super T, ? extends R>)
  Line 127) Arrays.stream(clazz.getDeclaredMethods()).filter(m -> !m.isSynthetic() && !m.isBridge()) ==> java.util.stream.Stream.filter(java.util.function.Predicate<? super T>)
  Line 127) Arrays.stream(clazz.getDeclaredMethods()) ==> java.util.Arrays.stream(T[])
  Line 127) clazz.getDeclaredMethods() ==> java.lang.Class.getDeclaredMethods()
  Line 128) m.isSynthetic() ==> java.lang.reflect.Method.isSynthetic()
  Line 128) m.isBridge() ==> java.lang.reflect.Method.isBridge()
  Line 130) Collectors.toSet() ==> java.util.stream.Collectors.toSet()
  Line 135) this.clazz.getTypeParameters() ==> java.lang.Class.getTypeParameters()
  Line 136) params.add(new ReflectionTypeParameter(tv, true, typeSolver)) ==> java.util.List.add(E)
  Line 146) isFunctionalInterface() ==> com.github.javaparser.symbolsolver.reflectionmodel.ReflectionClassAdapter.isFunctionalInterface()
  Line 148) type.isArray() ==> com.github.javaparser.symbolsolver.model.typesystem.Type.isArray()
  Line 151) type.isPrimitive() ==> com.github.javaparser.symbolsolver.model.typesystem.Type.isPrimitive()
  Line 154) type.describe().equals(typeDeclaration.getQualifiedName()) ==> java.lang.String.equals(java.lang.Object)
  Line 154) type.describe() ==> com.github.javaparser.symbolsolver.model.typesystem.Type.describe()
  Line 154) typeDeclaration.getQualifiedName() ==> com.github.javaparser.symbolsolver.model.declarations.TypeDeclaration.getQualifiedName()
  Line 159) otherTypeDeclaration.getTypeDeclaration().canBeAssignedTo(typeDeclaration) ==> com.github.javaparser.symbolsolver.model.declarations.ReferenceTypeDeclaration.canBeAssignedTo(com.github.javaparser.symbolsolver.model.declarations.ReferenceTypeDeclaration)
  Line 159) otherTypeDeclaration.getTypeDeclaration() ==> com.github.javaparser.symbolsolver.model.typesystem.ReferenceType.getTypeDeclaration()
  Line 166) clazz.getDeclaredAnnotations() ==> java.lang.Class.getDeclaredAnnotations()
  Line 167) a.annotationType().getCanonicalName().equals(canonicalName) ==> java.lang.String.equals(java.lang.Object)
  Line 167) a.annotationType().getCanonicalName() ==> java.lang.Class.getCanonicalName()
  Line 167) a.annotationType() ==> java.lang.annotation.Annotation.annotationType()
  Line 175) FunctionalInterfaceLogic.getFunctionalMethod(typeDeclaration).isPresent() ==> java.util.Optional.isPresent()
  Line 175) FunctionalInterfaceLogic.getFunctionalMethod(typeDeclaration) ==> com.github.javaparser.symbolsolver.logic.FunctionalInterfaceLogic.getFunctionalMethod(com.github.javaparser.symbolsolver.model.declarations.ReferenceTypeDeclaration)
  Line 179) Arrays.stream(clazz.getConstructors()).map(m -> new ReflectionConstructorDeclaration(m, typeSolver)).collect(Collectors.toList()) ==> java.util.stream.Stream.collect(java.util.stream.Collector<? super T, A, R>)
  Line 179) Arrays.stream(clazz.getConstructors()).map(m -> new ReflectionConstructorDeclaration(m, typeSolver)) ==> java.util.stream.Stream.map(java.util.function.Function<? super T, ? extends R>)
  Line 179) Arrays.stream(clazz.getConstructors()) ==> java.util.Arrays.stream(T[])
  Line 179) clazz.getConstructors() ==> java.lang.Class.getConstructors()
  Line 181) Collectors.toList() ==> java.util.stream.Collectors.toList()
  Line 185) clazz.getDeclaringClass() ==> java.lang.Class.getDeclaringClass()
  Line 187) Optional.empty() ==> java.util.Optional.empty()
  Line 188) Optional.of(ReflectionFactory.typeDeclarationFor(declaringClass, typeSolver)) ==> java.util.Optional.of(T)
  Line 188) ReflectionFactory.typeDeclarationFor(declaringClass, typeSolver) ==> com.github.javaparser.symbolsolver.reflectionmodel.ReflectionFactory.typeDeclarationFor(java.lang.Class<?>, com.github.javaparser.symbolsolver.model.resolution.TypeSolver)
