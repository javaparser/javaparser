  Line 52) clazz.isInterface() ==> java.lang.Class.isInterface()
  Line 55) clazz.isPrimitive() ==> java.lang.Class.isPrimitive()
  Line 58) clazz.isArray() ==> java.lang.Class.isArray()
  Line 61) clazz.isEnum() ==> java.lang.Class.isEnum()
  Line 75) ReflectionFactory.modifiersToAccessLevel(this.clazz.getModifiers()) ==> com.github.javaparser.symbolsolver.reflectionmodel.ReflectionFactory.modifiersToAccessLevel(int)
  Line 75) this.clazz.getModifiers() ==> java.lang.Class.getModifiers()
  Line 80) reflectionClassAdapter.containerType() ==> com.github.javaparser.symbolsolver.reflectionmodel.ReflectionClassAdapter.containerType()
  Line 85) clazz.getPackage() ==> java.lang.Class.getPackage()
  Line 86) clazz.getPackage().getName() ==> java.lang.Package.getName()
  Line 86) clazz.getPackage() ==> java.lang.Class.getPackage()
  Line 93) clazz.getCanonicalName() ==> java.lang.Class.getCanonicalName()
  Line 94) getPackageName() ==> com.github.javaparser.symbolsolver.reflectionmodel.ReflectionEnumDeclaration.getPackageName()
  Line 95) canonicalName.substring(getPackageName().length() + 1, canonicalName.length()) ==> java.lang.String.substring(int, int)
  Line 95) getPackageName().length() ==> java.lang.String.length()
  Line 95) getPackageName() ==> com.github.javaparser.symbolsolver.reflectionmodel.ReflectionEnumDeclaration.getPackageName()
  Line 95) canonicalName.length() ==> java.lang.String.length()
  Line 102) clazz.getCanonicalName() ==> java.lang.Class.getCanonicalName()
  Line 107) reflectionClassAdapter.getAncestors() ==> com.github.javaparser.symbolsolver.reflectionmodel.ReflectionClassAdapter.getAncestors()
  Line 112) reflectionClassAdapter.getField(name) ==> com.github.javaparser.symbolsolver.reflectionmodel.ReflectionClassAdapter.getField(java.lang.String)
  Line 117) reflectionClassAdapter.hasField(name) ==> com.github.javaparser.symbolsolver.reflectionmodel.ReflectionClassAdapter.hasField(java.lang.String)
  Line 122) reflectionClassAdapter.getAllFields() ==> com.github.javaparser.symbolsolver.reflectionmodel.ReflectionClassAdapter.getAllFields()
  Line 127) reflectionClassAdapter.getDeclaredMethods() ==> com.github.javaparser.symbolsolver.reflectionmodel.ReflectionClassAdapter.getDeclaredMethods()
  Line 132) reflectionClassAdapter.isAssignableBy(type) ==> com.github.javaparser.symbolsolver.reflectionmodel.ReflectionClassAdapter.isAssignableBy(com.github.javaparser.symbolsolver.model.typesystem.Type)
  Line 137) isAssignableBy(new ReferenceTypeImpl(other, typeSolver)) ==> com.github.javaparser.symbolsolver.reflectionmodel.ReflectionEnumDeclaration.isAssignableBy(com.github.javaparser.symbolsolver.model.typesystem.Type)
  Line 142) reflectionClassAdapter.hasDirectlyAnnotation(qualifiedName) ==> com.github.javaparser.symbolsolver.reflectionmodel.ReflectionClassAdapter.hasDirectlyAnnotation(java.lang.String)
  Line 147) clazz.getSimpleName() ==> java.lang.Class.getSimpleName()
  Line 152) reflectionClassAdapter.getTypeParameters() ==> com.github.javaparser.symbolsolver.reflectionmodel.ReflectionClassAdapter.getTypeParameters()
  Line 156) ReflectionMethodResolutionLogic.solveMethod(name, parameterTypes, staticOnly, typeSolver, this, clazz) ==> com.github.javaparser.symbolsolver.reflectionmodel.ReflectionMethodResolutionLogic.solveMethod(java.lang.String, java.util.List<com.github.javaparser.symbolsolver.model.typesystem.Type>, boolean, com.github.javaparser.symbolsolver.model.resolution.TypeSolver, com.github.javaparser.symbolsolver.model.declarations.ReferenceTypeDeclaration, java.lang.Class)
  Line 161) ReflectionMethodResolutionLogic.solveMethodAsUsage(name, parameterTypes, typeSolver, invokationContext, typeParameterValues, this, clazz) ==> com.github.javaparser.symbolsolver.reflectionmodel.ReflectionMethodResolutionLogic.solveMethodAsUsage(java.lang.String, java.util.List<com.github.javaparser.symbolsolver.model.typesystem.Type>, com.github.javaparser.symbolsolver.model.resolution.TypeSolver, com.github.javaparser.symbolsolver.core.resolution.Context, java.util.List<com.github.javaparser.symbolsolver.model.typesystem.Type>, com.github.javaparser.symbolsolver.model.declarations.ReferenceTypeDeclaration, java.lang.Class)
  Line 163) res.isPresent() ==> java.util.Optional.isPresent()
  Line 166) res.get() ==> java.util.Optional.get()
  Line 170) methodUsage.getParamType(i) ==> com.github.javaparser.symbolsolver.model.methods.MethodUsage.getParamType(int)
  Line 173) parameters.add(inferenceContext.addPair(formalType, actualType)) ==> java.util.List.add(E)
  Line 173) inferenceContext.addPair(formalType, actualType) ==> com.github.javaparser.symbolsolver.logic.InferenceContext.addPair(com.github.javaparser.symbolsolver.model.typesystem.Type, com.github.javaparser.symbolsolver.model.typesystem.Type)
  Line 177) inferenceContext.addSingle(methodUsage.returnType()) ==> com.github.javaparser.symbolsolver.logic.InferenceContext.addSingle(com.github.javaparser.symbolsolver.model.typesystem.Type)
  Line 177) methodUsage.returnType() ==> com.github.javaparser.symbolsolver.model.methods.MethodUsage.returnType()
  Line 178) parameters.size() ==> java.util.List.size()
  Line 179) methodUsage.replaceParamType(j, inferenceContext.resolve(parameters.get(j))) ==> com.github.javaparser.symbolsolver.model.methods.MethodUsage.replaceParamType(int, com.github.javaparser.symbolsolver.model.typesystem.Type)
  Line 179) inferenceContext.resolve(parameters.get(j)) ==> com.github.javaparser.symbolsolver.logic.InferenceContext.resolve(com.github.javaparser.symbolsolver.model.typesystem.Type)
  Line 179) parameters.get(j) ==> java.util.List.get(int)
  Line 181) methodUsage.replaceReturnType(inferenceContext.resolve(returnType)) ==> com.github.javaparser.symbolsolver.model.methods.MethodUsage.replaceReturnType(com.github.javaparser.symbolsolver.model.typesystem.Type)
  Line 181) inferenceContext.resolve(returnType) ==> com.github.javaparser.symbolsolver.logic.InferenceContext.resolve(com.github.javaparser.symbolsolver.model.typesystem.Type)
  Line 182) Optional.of(methodUsage) ==> java.util.Optional.of(T)
  Line 184) Optional.empty() ==> java.util.Optional.empty()
