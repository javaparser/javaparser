  Line 54) ctClass.getName() ==> javassist.CtClass.getName()
  Line 60) ctClass.isInterface() ==> javassist.CtClass.isInterface()
  Line 61) ctClass.getName() ==> javassist.CtClass.getName()
  Line 71) Arrays.stream(ctClass.getInterfaces()).map(i -> new JavassistInterfaceDeclaration(i, typeSolver)).map(i -> new ReferenceTypeImpl(i, typeSolver)).collect(Collectors.toList()) ==> java.util.stream.Stream.collect(java.util.stream.Collector<? super T, A, R>)
  Line 71) Arrays.stream(ctClass.getInterfaces()).map(i -> new JavassistInterfaceDeclaration(i, typeSolver)).map(i -> new ReferenceTypeImpl(i, typeSolver)) ==> java.util.stream.Stream.map(java.util.function.Function<? super T, ? extends R>)
  Line 71) Arrays.stream(ctClass.getInterfaces()).map(i -> new JavassistInterfaceDeclaration(i, typeSolver)) ==> java.util.stream.Stream.map(java.util.function.Function<? super T, ? extends R>)
  Line 71) Arrays.stream(ctClass.getInterfaces()) ==> java.util.Arrays.stream(T[])
  Line 71) ctClass.getInterfaces() ==> javassist.CtClass.getInterfaces()
  Line 72) Collectors.toList() ==> java.util.stream.Collectors.toList()
  Line 80) ctClass.getPackageName() ==> javassist.CtClass.getPackageName()
  Line 85) ctClass.getName().replace('$', '.') ==> java.lang.String.replace(char, char)
  Line 85) ctClass.getName() ==> javassist.CtClass.getName()
  Line 86) getPackageName() ==> com.github.javaparser.symbolsolver.javassistmodel.JavassistInterfaceDeclaration.getPackageName()
  Line 87) className.substring(getPackageName().length() + 1, className.length()) ==> java.lang.String.substring(int, int)
  Line 87) getPackageName().length() ==> java.lang.String.length()
  Line 87) getPackageName() ==> com.github.javaparser.symbolsolver.javassistmodel.JavassistInterfaceDeclaration.getPackageName()
  Line 87) className.length() ==> java.lang.String.length()
  Line 94) ctClass.getName().replace('$', '.') ==> java.lang.String.replace(char, char)
  Line 94) ctClass.getName() ==> javassist.CtClass.getName()
  Line 101) JavassistUtils.getMethodUsage(ctClass, name, argumentsTypes, typeSolver, invokationContext) ==> com.github.javaparser.symbolsolver.javassistmodel.JavassistUtils.getMethodUsage(javassist.CtClass, java.lang.String, java.util.List<com.github.javaparser.symbolsolver.model.typesystem.Type>, com.github.javaparser.symbolsolver.model.resolution.TypeSolver, com.github.javaparser.symbolsolver.core.resolution.Context)
  Line 107) Modifier.isStatic(m.getModifiers()) ==> java.lang.reflect.Modifier.isStatic(int)
  Line 107) m.getModifiers() ==> javassist.CtBehavior.getModifiers()
  Line 108) ctClass.getDeclaredMethods() ==> javassist.CtClass.getDeclaredMethods()
  Line 109) method.getMethodInfo().getAttribute(SyntheticAttribute.tag) ==> javassist.bytecode.MethodInfo.getAttribute(java.lang.String)
  Line 109) method.getMethodInfo() ==> javassist.CtBehavior.getMethodInfo()
  Line 110) method.getMethodInfo().getAccessFlags() ==> javassist.bytecode.MethodInfo.getAccessFlags()
  Line 110) method.getMethodInfo() ==> javassist.CtBehavior.getMethodInfo()
  Line 111) method.getName().equals(name) ==> java.lang.String.equals(java.lang.Object)
  Line 111) method.getName() ==> javassist.CtMethod.getName()
  Line 111) staticOnlyCheck.test(method) ==> java.util.function.Predicate.test(T)
  Line 112) candidates.add(new JavassistMethodDeclaration(method, typeSolver)) ==> java.util.List.add(E)
  Line 117) ctClass.getSuperclass() ==> javassist.CtClass.getSuperclass()
  Line 119) new JavassistClassDeclaration(superClass, typeSolver).solveMethod(name, argumentsTypes, staticOnly) ==> com.github.javaparser.symbolsolver.javassistmodel.JavassistClassDeclaration.solveMethod(java.lang.String, java.util.List<com.github.javaparser.symbolsolver.model.typesystem.Type>, boolean)
  Line 120) ref.isSolved() ==> com.github.javaparser.symbolsolver.model.resolution.SymbolReference.isSolved()
  Line 121) candidates.add(ref.getCorrespondingDeclaration()) ==> java.util.List.add(E)
  Line 121) ref.getCorrespondingDeclaration() ==> com.github.javaparser.symbolsolver.model.resolution.SymbolReference.getCorrespondingDeclaration()
  Line 129) ctClass.getInterfaces() ==> javassist.CtClass.getInterfaces()
  Line 130) new JavassistInterfaceDeclaration(interfaze, typeSolver).solveMethod(name, argumentsTypes, staticOnly) ==> com.github.javaparser.symbolsolver.javassistmodel.JavassistInterfaceDeclaration.solveMethod(java.lang.String, java.util.List<com.github.javaparser.symbolsolver.model.typesystem.Type>, boolean)
  Line 131) ref.isSolved() ==> com.github.javaparser.symbolsolver.model.resolution.SymbolReference.isSolved()
  Line 132) candidates.add(ref.getCorrespondingDeclaration()) ==> java.util.List.add(E)
  Line 132) ref.getCorrespondingDeclaration() ==> com.github.javaparser.symbolsolver.model.resolution.SymbolReference.getCorrespondingDeclaration()
  Line 139) MethodResolutionLogic.findMostApplicable(candidates, name, argumentsTypes, typeSolver) ==> com.github.javaparser.symbolsolver.resolution.MethodResolutionLogic.findMostApplicable(java.util.List<com.github.javaparser.symbolsolver.model.declarations.MethodDeclaration>, java.lang.String, java.util.List<com.github.javaparser.symbolsolver.model.typesystem.Type>, com.github.javaparser.symbolsolver.model.resolution.TypeSolver)
  Line 149) javassistTypeDeclarationAdapter.getDeclaredFields() ==> com.github.javaparser.symbolsolver.javassistmodel.JavassistTypeDeclarationAdapter.getDeclaredFields()
  Line 161) ctClass.getInterfaces() ==> javassist.CtClass.getInterfaces()
  Line 162) JavassistFactory.typeUsageFor(interfaze, typeSolver).asReferenceType() ==> com.github.javaparser.symbolsolver.model.typesystem.Type.asReferenceType()
  Line 162) JavassistFactory.typeUsageFor(interfaze, typeSolver) ==> com.github.javaparser.symbolsolver.javassistmodel.JavassistFactory.typeUsageFor(javassist.CtClass, com.github.javaparser.symbolsolver.model.resolution.TypeSolver)
  Line 163) ancestors.add(superInterfaze) ==> java.util.List.add(E)
  Line 168) ancestors.stream().filter(a -> a.getQualifiedName() != Object.class.getCanonicalName()).collect(Collectors.toList()) ==> java.util.stream.Stream.collect(java.util.stream.Collector<? super T, A, R>)
  Line 168) ancestors.stream().filter(a -> a.getQualifiedName() != Object.class.getCanonicalName()) ==> java.util.stream.Stream.filter(java.util.function.Predicate<? super T>)
  Line 168) ancestors.stream() ==> java.util.Collection.stream()
  Line 168) a.getQualifiedName() ==> com.github.javaparser.symbolsolver.model.typesystem.ReferenceType.getQualifiedName()
  Line 168) Object.class.getCanonicalName() ==> java.lang.Class.getCanonicalName()
  Line 169) Collectors.toList() ==> java.util.stream.Collectors.toList()
  Line 170) ancestors.add(new ReferenceTypeImpl(typeSolver.solveType(Object.class.getCanonicalName()), typeSolver)) ==> java.util.List.add(E)
  Line 170) typeSolver.solveType(Object.class.getCanonicalName()) ==> com.github.javaparser.symbolsolver.model.resolution.TypeSolver.solveType(java.lang.String)
  Line 170) Object.class.getCanonicalName() ==> java.lang.Class.getCanonicalName()
  Line 176) Arrays.stream(ctClass.getDeclaredMethods()).map(m -> new JavassistMethodDeclaration(m, typeSolver)).collect(Collectors.toSet()) ==> java.util.stream.Stream.collect(java.util.stream.Collector<? super T, A, R>)
  Line 176) Arrays.stream(ctClass.getDeclaredMethods()).map(m -> new JavassistMethodDeclaration(m, typeSolver)) ==> java.util.stream.Stream.map(java.util.function.Function<? super T, ? extends R>)
  Line 176) Arrays.stream(ctClass.getDeclaredMethods()) ==> java.util.Arrays.stream(T[])
  Line 176) ctClass.getDeclaredMethods() ==> javassist.CtClass.getDeclaredMethods()
  Line 178) Collectors.toSet() ==> java.util.stream.Collectors.toSet()
  Line 184) ctClass.getAnnotations() ==> javassist.CtClass.getAnnotations()
  Line 185) annotationRaw.getClass().getCanonicalName().equals(canonicalName) ==> java.lang.String.equals(java.lang.Object)
  Line 185) annotationRaw.getClass().getCanonicalName() ==> java.lang.Class.getCanonicalName()
  Line 185) annotationRaw.getClass() ==> java.lang.Object.getClass()
  Line 188) Arrays.stream(annotationRaw.getClass().getInterfaces()).anyMatch(it -> it.getCanonicalName().equals(canonicalName)) ==> java.util.stream.Stream.anyMatch(java.util.function.Predicate<? super T>)
  Line 188) Arrays.stream(annotationRaw.getClass().getInterfaces()) ==> java.util.Arrays.stream(T[])
  Line 188) annotationRaw.getClass().getInterfaces() ==> java.lang.Class.getInterfaces()
  Line 188) annotationRaw.getClass() ==> java.lang.Object.getClass()
  Line 188) it.getCanonicalName().equals(canonicalName) ==> java.lang.String.equals(java.lang.Object)
  Line 188) it.getCanonicalName() ==> java.lang.Class.getCanonicalName()
  Line 200) ctClass.getSimpleName().replace('$', '.').split("\\.") ==> java.lang.String.split(java.lang.String)
  Line 200) ctClass.getSimpleName().replace('$', '.') ==> java.lang.String.replace(char, char)
  Line 200) ctClass.getSimpleName() ==> javassist.CtClass.getSimpleName()
  Line 206) javassistTypeDeclarationAdapter.getTypeParameters() ==> com.github.javaparser.symbolsolver.javassistmodel.JavassistTypeDeclarationAdapter.getTypeParameters()
  Line 211) JavassistFactory.modifiersToAccessLevel(ctClass.getModifiers()) ==> com.github.javaparser.symbolsolver.javassistmodel.JavassistFactory.modifiersToAccessLevel(int)
  Line 211) ctClass.getModifiers() ==> javassist.CtClass.getModifiers()
  Line 222) ctClass.getDeclaredFields() ==> javassist.CtClass.getDeclaredFields()
  Line 223) field.getName().equals(name) ==> java.lang.String.equals(java.lang.Object)
  Line 223) field.getName() ==> javassist.CtField.getName()
  Line 224) SymbolReference.solved(new JavassistFieldDeclaration(field, typeSolver)) ==> com.github.javaparser.symbolsolver.model.resolution.SymbolReference.solved(S2)
  Line 229) ctClass.getInterfaces() ==> javassist.CtClass.getInterfaces()
  Line 230) new JavassistInterfaceDeclaration(interfaze, typeSolver).solveSymbol(name, typeSolver) ==> com.github.javaparser.symbolsolver.javassistmodel.JavassistInterfaceDeclaration.solveSymbol(java.lang.String, com.github.javaparser.symbolsolver.model.resolution.TypeSolver)
  Line 231) ref.isSolved() ==> com.github.javaparser.symbolsolver.model.resolution.SymbolReference.isSolved()
  Line 239) SymbolReference.unsolved(ValueDeclaration.class) ==> com.github.javaparser.symbolsolver.model.resolution.SymbolReference.unsolved(java.lang.Class<S2>)
  Line 244) javassistTypeDeclarationAdapter.containerType() ==> com.github.javaparser.symbolsolver.javassistmodel.JavassistTypeDeclarationAdapter.containerType()
  Line 254) Arrays.stream(ctClass.getDeclaredClasses()).map(itype -> JavassistFactory.toTypeDeclaration(itype, typeSolver)).collect(Collectors.toSet()) ==> java.util.stream.Stream.collect(java.util.stream.Collector<? super T, A, R>)
  Line 254) Arrays.stream(ctClass.getDeclaredClasses()).map(itype -> JavassistFactory.toTypeDeclaration(itype, typeSolver)) ==> java.util.stream.Stream.map(java.util.function.Function<? super T, ? extends R>)
  Line 254) Arrays.stream(ctClass.getDeclaredClasses()) ==> java.util.Arrays.stream(T[])
  Line 254) ctClass.getDeclaredClasses() ==> javassist.CtClass.getDeclaredClasses()
  Line 254) JavassistFactory.toTypeDeclaration(itype, typeSolver) ==> com.github.javaparser.symbolsolver.javassistmodel.JavassistFactory.toTypeDeclaration(javassist.CtClass, com.github.javaparser.symbolsolver.model.resolution.TypeSolver)
  Line 254) Collectors.toSet() ==> java.util.stream.Collectors.toSet()
  Line 267) this.internalTypes().stream().filter(f -> f.getName().endsWith(name)).findFirst() ==> java.util.stream.Stream.findFirst()
  Line 267) this.internalTypes().stream().filter(f -> f.getName().endsWith(name)) ==> java.util.stream.Stream.filter(java.util.function.Predicate<? super T>)
  Line 267) this.internalTypes().stream() ==> java.util.Collection.stream()
  Line 267) this.internalTypes() ==> com.github.javaparser.symbolsolver.javassistmodel.JavassistInterfaceDeclaration.internalTypes()
  Line 267) f.getName().endsWith(name) ==> java.lang.String.endsWith(java.lang.String)
  Line 267) f.getName() ==> com.github.javaparser.symbolsolver.model.declarations.Declaration.getName()
  Line 268) type.orElseThrow(() -> new UnsolvedSymbolException("Internal type not found: " + name)) ==> java.util.Optional.orElseThrow(java.util.function.Supplier<? extends X>)
  Line 278) this.internalTypes().stream().anyMatch(f -> f.getName().endsWith(name)) ==> java.util.stream.Stream.anyMatch(java.util.function.Predicate<? super T>)
  Line 278) this.internalTypes().stream() ==> java.util.Collection.stream()
  Line 278) this.internalTypes() ==> com.github.javaparser.symbolsolver.javassistmodel.JavassistInterfaceDeclaration.internalTypes()
  Line 278) f.getName().endsWith(name) ==> java.lang.String.endsWith(java.lang.String)
  Line 278) f.getName() ==> com.github.javaparser.symbolsolver.model.declarations.Declaration.getName()
