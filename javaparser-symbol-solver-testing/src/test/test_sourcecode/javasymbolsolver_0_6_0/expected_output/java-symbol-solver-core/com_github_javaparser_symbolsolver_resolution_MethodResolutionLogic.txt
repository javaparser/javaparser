  Line 45) argumentsTypes.subList(0, startVariadic) ==> java.util.List.subList(int, int)
  Line 46) argumentsTypes.subList(startVariadic, argumentsTypes.size()) ==> java.util.List.subList(int, int)
  Line 46) argumentsTypes.size() ==> java.util.List.size()
  Line 47) variadicValues.isEmpty() ==> java.util.List.isEmpty()
  Line 49) res.add(variadicType) ==> java.util.List.add(E)
  Line 51) findCommonType(variadicValues) ==> com.github.javaparser.symbolsolver.resolution.MethodResolutionLogic.findCommonType(java.util.List<com.github.javaparser.symbolsolver.model.typesystem.Type>)
  Line 52) res.add(new ArrayType(componentType)) ==> java.util.List.add(E)
  Line 58) variadicValues.isEmpty() ==> java.util.List.isEmpty()
  Line 62) variadicValues.get(0) ==> java.util.List.get(int)
  Line 66) isApplicable(method, name, argumentsTypes, typeSolver, false) ==> com.github.javaparser.symbolsolver.resolution.MethodResolutionLogic.isApplicable(com.github.javaparser.symbolsolver.model.declarations.MethodDeclaration, java.lang.String, java.util.List<com.github.javaparser.symbolsolver.model.typesystem.Type>, com.github.javaparser.symbolsolver.model.resolution.TypeSolver, boolean)
  Line 70) method.getName().equals(name) ==> java.lang.String.equals(java.lang.Object)
  Line 70) method.getName() ==> com.github.javaparser.symbolsolver.model.declarations.Declaration.getName()
  Line 73) method.hasVariadicParameter() ==> com.github.javaparser.symbolsolver.model.declarations.MethodLikeDeclaration.hasVariadicParameter()
  Line 74) method.getNumberOfParams() ==> com.github.javaparser.symbolsolver.model.declarations.MethodLikeDeclaration.getNumberOfParams()
  Line 75) method.getNumberOfParams() ==> com.github.javaparser.symbolsolver.model.declarations.MethodLikeDeclaration.getNumberOfParams()
  Line 75) argumentsTypes.size() ==> java.util.List.size()
  Line 77) method.getLastParam().getType() ==> com.github.javaparser.symbolsolver.model.declarations.ValueDeclaration.getType()
  Line 77) method.getLastParam() ==> com.github.javaparser.symbolsolver.model.declarations.MethodLikeDeclaration.getLastParam()
  Line 78) argumentsTypes.get(pos) ==> java.util.List.get(int)
  Line 79) expectedType.isAssignableBy(actualType) ==> com.github.javaparser.symbolsolver.model.typesystem.Type.isAssignableBy(com.github.javaparser.symbolsolver.model.typesystem.Type)
  Line 80) method.getTypeParameters() ==> com.github.javaparser.symbolsolver.model.declarations.TypeParametrizable.getTypeParameters()
  Line 81) replaceTypeParam(expectedType, tp, typeSolver) ==> com.github.javaparser.symbolsolver.resolution.MethodResolutionLogic.replaceTypeParam(com.github.javaparser.symbolsolver.model.typesystem.Type, com.github.javaparser.symbolsolver.model.declarations.TypeParameterDeclaration, com.github.javaparser.symbolsolver.model.resolution.TypeSolver)
  Line 83) expectedType.isAssignableBy(actualType) ==> com.github.javaparser.symbolsolver.model.typesystem.Type.isAssignableBy(com.github.javaparser.symbolsolver.model.typesystem.Type)
  Line 84) actualType.isArray() ==> com.github.javaparser.symbolsolver.model.typesystem.Type.isArray()
  Line 84) expectedType.isAssignableBy(actualType.asArrayType().getComponentType()) ==> com.github.javaparser.symbolsolver.model.typesystem.Type.isAssignableBy(com.github.javaparser.symbolsolver.model.typesystem.Type)
  Line 84) actualType.asArrayType().getComponentType() ==> com.github.javaparser.symbolsolver.model.typesystem.ArrayType.getComponentType()
  Line 84) actualType.asArrayType() ==> com.github.javaparser.symbolsolver.model.typesystem.Type.asArrayType()
  Line 85) argumentsTypes.set(pos, actualType.asArrayType().getComponentType()) ==> java.util.List.set(int, E)
  Line 85) actualType.asArrayType().getComponentType() ==> com.github.javaparser.symbolsolver.model.typesystem.ArrayType.getComponentType()
  Line 85) actualType.asArrayType() ==> com.github.javaparser.symbolsolver.model.typesystem.Type.asArrayType()
  Line 87) groupVariadicParamValues(argumentsTypes, pos, method.getLastParam().getType()) ==> com.github.javaparser.symbolsolver.resolution.MethodResolutionLogic.groupVariadicParamValues(java.util.List<com.github.javaparser.symbolsolver.model.typesystem.Type>, int, com.github.javaparser.symbolsolver.model.typesystem.Type)
  Line 87) method.getLastParam().getType() ==> com.github.javaparser.symbolsolver.model.declarations.ValueDeclaration.getType()
  Line 87) method.getLastParam() ==> com.github.javaparser.symbolsolver.model.declarations.MethodLikeDeclaration.getLastParam()
  Line 92) argumentsTypes.size() ==> java.util.List.size()
  Line 95) groupVariadicParamValues(argumentsTypes, pos, method.getLastParam().getType()) ==> com.github.javaparser.symbolsolver.resolution.MethodResolutionLogic.groupVariadicParamValues(java.util.List<com.github.javaparser.symbolsolver.model.typesystem.Type>, int, com.github.javaparser.symbolsolver.model.typesystem.Type)
  Line 95) method.getLastParam().getType() ==> com.github.javaparser.symbolsolver.model.declarations.ValueDeclaration.getType()
  Line 95) method.getLastParam() ==> com.github.javaparser.symbolsolver.model.declarations.MethodLikeDeclaration.getLastParam()
  Line 99) method.getNumberOfParams() ==> com.github.javaparser.symbolsolver.model.declarations.MethodLikeDeclaration.getNumberOfParams()
  Line 99) argumentsTypes.size() ==> java.util.List.size()
  Line 104) method.getNumberOfParams() ==> com.github.javaparser.symbolsolver.model.declarations.MethodLikeDeclaration.getNumberOfParams()
  Line 105) method.getParam(i).getType() ==> com.github.javaparser.symbolsolver.model.declarations.ValueDeclaration.getType()
  Line 105) method.getParam(i) ==> com.github.javaparser.symbolsolver.model.declarations.MethodLikeDeclaration.getParam(int)
  Line 106) argumentsTypes.get(i) ==> java.util.List.get(int)
  Line 107) expectedType.isTypeVariable() ==> com.github.javaparser.symbolsolver.model.typesystem.Type.isTypeVariable()
  Line 107) expectedType.isWildcard() ==> com.github.javaparser.symbolsolver.model.typesystem.Type.isWildcard()
  Line 107) expectedType.asTypeParameter().declaredOnMethod() ==> com.github.javaparser.symbolsolver.model.declarations.TypeParameterDeclaration.declaredOnMethod()
  Line 107) expectedType.asTypeParameter() ==> com.github.javaparser.symbolsolver.model.typesystem.Type.asTypeParameter()
  Line 108) matchedParameters.put(expectedType.asTypeParameter().getName(), actualType) ==> java.util.Map.put(K, V)
  Line 108) expectedType.asTypeParameter().getName() ==> com.github.javaparser.symbolsolver.model.declarations.TypeParameterDeclaration.getName()
  Line 108) expectedType.asTypeParameter() ==> com.github.javaparser.symbolsolver.model.typesystem.Type.asTypeParameter()
  Line 111) expectedType.isAssignableBy(actualType) ==> com.github.javaparser.symbolsolver.model.typesystem.Type.isAssignableBy(com.github.javaparser.symbolsolver.model.typesystem.Type)
  Line 112) method.getParam(i).isVariadic() ==> com.github.javaparser.symbolsolver.model.declarations.ParameterDeclaration.isVariadic()
  Line 112) method.getParam(i) ==> com.github.javaparser.symbolsolver.model.declarations.MethodLikeDeclaration.getParam(int)
  Line 112) new ArrayType(expectedType).isAssignableBy(actualType) ==> com.github.javaparser.symbolsolver.model.typesystem.ArrayType.isAssignableBy(com.github.javaparser.symbolsolver.model.typesystem.Type)
  Line 113) expectedType.isReferenceType() ==> com.github.javaparser.symbolsolver.model.typesystem.Type.isReferenceType()
  Line 113) actualType.isReferenceType() ==> com.github.javaparser.symbolsolver.model.typesystem.Type.isReferenceType()
  Line 114) isAssignableMatchTypeParameters(expectedType.asReferenceType(), actualType.asReferenceType(), matchedParameters) ==> com.github.javaparser.symbolsolver.resolution.MethodResolutionLogic.isAssignableMatchTypeParameters(com.github.javaparser.symbolsolver.model.typesystem.ReferenceType, com.github.javaparser.symbolsolver.model.typesystem.ReferenceType, java.util.Map<java.lang.String, com.github.javaparser.symbolsolver.model.typesystem.Type>)
  Line 115) expectedType.asReferenceType() ==> com.github.javaparser.symbolsolver.model.typesystem.Type.asReferenceType()
  Line 116) actualType.asReferenceType() ==> com.github.javaparser.symbolsolver.model.typesystem.Type.asReferenceType()
  Line 120) method.getTypeParameters() ==> com.github.javaparser.symbolsolver.model.declarations.TypeParametrizable.getTypeParameters()
  Line 121) typeParameters.addAll(method.declaringType().getTypeParameters()) ==> java.util.List.addAll(java.util.Collection<? extends E>)
  Line 121) method.declaringType().getTypeParameters() ==> com.github.javaparser.symbolsolver.model.declarations.TypeParametrizable.getTypeParameters()
  Line 121) method.declaringType() ==> com.github.javaparser.symbolsolver.model.declarations.MethodLikeDeclaration.declaringType()
  Line 123) replaceTypeParam(expectedType, tp, typeSolver) ==> com.github.javaparser.symbolsolver.resolution.MethodResolutionLogic.replaceTypeParam(com.github.javaparser.symbolsolver.model.typesystem.Type, com.github.javaparser.symbolsolver.model.declarations.TypeParameterDeclaration, com.github.javaparser.symbolsolver.model.resolution.TypeSolver)
  Line 126) expectedType.isAssignableBy(actualType) ==> com.github.javaparser.symbolsolver.model.typesystem.Type.isAssignableBy(com.github.javaparser.symbolsolver.model.typesystem.Type)
  Line 127) actualType.isWildcard() ==> com.github.javaparser.symbolsolver.model.typesystem.Type.isWildcard()
  Line 127) expectedType.isPrimitive() ==> com.github.javaparser.symbolsolver.model.typesystem.Type.isPrimitive()
  Line 131) method.hasVariadicParameter() ==> com.github.javaparser.symbolsolver.model.declarations.MethodLikeDeclaration.hasVariadicParameter()
  Line 131) method.getNumberOfParams() ==> com.github.javaparser.symbolsolver.model.declarations.MethodLikeDeclaration.getNumberOfParams()
  Line 132) new ArrayType(expectedType).isAssignableBy(actualType) ==> com.github.javaparser.symbolsolver.model.typesystem.ArrayType.isAssignableBy(com.github.javaparser.symbolsolver.model.typesystem.Type)
  Line 145) expected.isReferenceType() ==> com.github.javaparser.symbolsolver.model.typesystem.Type.isReferenceType()
  Line 145) actual.isReferenceType() ==> com.github.javaparser.symbolsolver.model.typesystem.Type.isReferenceType()
  Line 146) isAssignableMatchTypeParameters(expected.asReferenceType(), actual.asReferenceType(), matchedParameters) ==> com.github.javaparser.symbolsolver.resolution.MethodResolutionLogic.isAssignableMatchTypeParameters(com.github.javaparser.symbolsolver.model.typesystem.ReferenceType, com.github.javaparser.symbolsolver.model.typesystem.ReferenceType, java.util.Map<java.lang.String, com.github.javaparser.symbolsolver.model.typesystem.Type>)
  Line 146) expected.asReferenceType() ==> com.github.javaparser.symbolsolver.model.typesystem.Type.asReferenceType()
  Line 146) actual.asReferenceType() ==> com.github.javaparser.symbolsolver.model.typesystem.Type.asReferenceType()
  Line 147) expected.isTypeVariable() ==> com.github.javaparser.symbolsolver.model.typesystem.Type.isTypeVariable()
  Line 148) matchedParameters.put(expected.asTypeParameter().getName(), actual) ==> java.util.Map.put(K, V)
  Line 148) expected.asTypeParameter().getName() ==> com.github.javaparser.symbolsolver.model.declarations.TypeParameterDeclaration.getName()
  Line 148) expected.asTypeParameter() ==> com.github.javaparser.symbolsolver.model.typesystem.Type.asTypeParameter()
  Line 151) expected.getClass().getCanonicalName() ==> java.lang.Class.getCanonicalName()
  Line 151) expected.getClass() ==> java.lang.Object.getClass()
  Line 151) actual.getClass().getCanonicalName() ==> java.lang.Class.getCanonicalName()
  Line 151) actual.getClass() ==> java.lang.Object.getClass()
  Line 157) actual.getQualifiedName().equals(expected.getQualifiedName()) ==> java.lang.String.equals(java.lang.Object)
  Line 157) actual.getQualifiedName() ==> com.github.javaparser.symbolsolver.model.typesystem.ReferenceType.getQualifiedName()
  Line 157) expected.getQualifiedName() ==> com.github.javaparser.symbolsolver.model.typesystem.ReferenceType.getQualifiedName()
  Line 158) isAssignableMatchTypeParametersMatchingQName(expected, actual, matchedParameters) ==> com.github.javaparser.symbolsolver.resolution.MethodResolutionLogic.isAssignableMatchTypeParametersMatchingQName(com.github.javaparser.symbolsolver.model.typesystem.ReferenceType, com.github.javaparser.symbolsolver.model.typesystem.ReferenceType, java.util.Map<java.lang.String, com.github.javaparser.symbolsolver.model.typesystem.Type>)
  Line 160) actual.getAllAncestors() ==> com.github.javaparser.symbolsolver.model.typesystem.ReferenceType.getAllAncestors()
  Line 162) isAssignableMatchTypeParametersMatchingQName(expected, ancestor, matchedParameters) ==> com.github.javaparser.symbolsolver.resolution.MethodResolutionLogic.isAssignableMatchTypeParametersMatchingQName(com.github.javaparser.symbolsolver.model.typesystem.ReferenceType, com.github.javaparser.symbolsolver.model.typesystem.ReferenceType, java.util.Map<java.lang.String, com.github.javaparser.symbolsolver.model.typesystem.Type>)
  Line 173) expected.getQualifiedName().equals(actual.getQualifiedName()) ==> java.lang.String.equals(java.lang.Object)
  Line 173) expected.getQualifiedName() ==> com.github.javaparser.symbolsolver.model.typesystem.ReferenceType.getQualifiedName()
  Line 173) actual.getQualifiedName() ==> com.github.javaparser.symbolsolver.model.typesystem.ReferenceType.getQualifiedName()
  Line 176) expected.typeParametersValues().size() ==> java.util.List.size()
  Line 176) expected.typeParametersValues() ==> com.github.javaparser.symbolsolver.model.typesystem.ReferenceType.typeParametersValues()
  Line 176) actual.typeParametersValues().size() ==> java.util.List.size()
  Line 176) actual.typeParametersValues() ==> com.github.javaparser.symbolsolver.model.typesystem.ReferenceType.typeParametersValues()
  Line 180) expected.typeParametersValues().size() ==> java.util.List.size()
  Line 180) expected.typeParametersValues() ==> com.github.javaparser.symbolsolver.model.typesystem.ReferenceType.typeParametersValues()
  Line 181) expected.typeParametersValues().get(i) ==> java.util.List.get(int)
  Line 181) expected.typeParametersValues() ==> com.github.javaparser.symbolsolver.model.typesystem.ReferenceType.typeParametersValues()
  Line 182) actual.typeParametersValues().get(i) ==> java.util.List.get(int)
  Line 182) actual.typeParametersValues() ==> com.github.javaparser.symbolsolver.model.typesystem.ReferenceType.typeParametersValues()
  Line 186) expectedParam.isReferenceType() ==> com.github.javaparser.symbolsolver.model.typesystem.Type.isReferenceType()
  Line 186) actualParam.isReferenceType() ==> com.github.javaparser.symbolsolver.model.typesystem.Type.isReferenceType()
  Line 187) expectedParam.asReferenceType() ==> com.github.javaparser.symbolsolver.model.typesystem.Type.asReferenceType()
  Line 188) actualParam.asReferenceType() ==> com.github.javaparser.symbolsolver.model.typesystem.Type.asReferenceType()
  Line 190) isAssignableMatchTypeParametersMatchingQName(r1, r2, matchedParameters) ==> com.github.javaparser.symbolsolver.resolution.MethodResolutionLogic.isAssignableMatchTypeParametersMatchingQName(com.github.javaparser.symbolsolver.model.typesystem.ReferenceType, com.github.javaparser.symbolsolver.model.typesystem.ReferenceType, java.util.Map<java.lang.String, com.github.javaparser.symbolsolver.model.typesystem.Type>)
  Line 193) expectedParam.isTypeVariable() ==> com.github.javaparser.symbolsolver.model.typesystem.Type.isTypeVariable()
  Line 194) expectedParam.asTypeParameter().getName() ==> com.github.javaparser.symbolsolver.model.declarations.TypeParameterDeclaration.getName()
  Line 194) expectedParam.asTypeParameter() ==> com.github.javaparser.symbolsolver.model.typesystem.Type.asTypeParameter()
  Line 195) actualParam.isTypeVariable() ==> com.github.javaparser.symbolsolver.model.typesystem.Type.isTypeVariable()
  Line 195) actualParam.asTypeParameter().getName().equals(expectedParamName) ==> java.lang.String.equals(java.lang.Object)
  Line 195) actualParam.asTypeParameter().getName() ==> com.github.javaparser.symbolsolver.model.declarations.TypeParameterDeclaration.getName()
  Line 195) actualParam.asTypeParameter() ==> com.github.javaparser.symbolsolver.model.typesystem.Type.asTypeParameter()
  Line 196) matchedParameters.containsKey(expectedParamName) ==> java.util.Map.containsKey(java.lang.Object)
  Line 197) matchedParameters.get(expectedParamName) ==> java.util.Map.get(java.lang.Object)
  Line 198) matchedParameter.isAssignableBy(actualParam) ==> com.github.javaparser.symbolsolver.model.typesystem.Type.isAssignableBy(com.github.javaparser.symbolsolver.model.typesystem.Type)
  Line 200) actualParam.isAssignableBy(matchedParameter) ==> com.github.javaparser.symbolsolver.model.typesystem.Type.isAssignableBy(com.github.javaparser.symbolsolver.model.typesystem.Type)
  Line 201) matchedParameters.put(expectedParamName, actualParam) ==> java.util.Map.put(K, V)
  Line 206) matchedParameters.put(expectedParamName, actualParam) ==> java.util.Map.put(K, V)
  Line 209) expectedParam.isReferenceType() ==> com.github.javaparser.symbolsolver.model.typesystem.Type.isReferenceType()
  Line 210) expectedParam.equals(actualParam) ==> java.lang.Object.equals(java.lang.Object)
  Line 213) expectedParam.isWildcard() ==> com.github.javaparser.symbolsolver.model.typesystem.Type.isWildcard()
  Line 214) expectedParam.asWildcard().isExtends() ==> com.github.javaparser.symbolsolver.model.typesystem.Wildcard.isExtends()
  Line 214) expectedParam.asWildcard() ==> com.github.javaparser.symbolsolver.model.typesystem.Type.asWildcard()
  Line 215) isAssignableMatchTypeParameters(expectedParam.asWildcard().getBoundedType(), actual, matchedParameters) ==> com.github.javaparser.symbolsolver.resolution.MethodResolutionLogic.isAssignableMatchTypeParameters(com.github.javaparser.symbolsolver.model.typesystem.Type, com.github.javaparser.symbolsolver.model.typesystem.Type, java.util.Map<java.lang.String, com.github.javaparser.symbolsolver.model.typesystem.Type>)
  Line 215) expectedParam.asWildcard().getBoundedType() ==> com.github.javaparser.symbolsolver.model.typesystem.Wildcard.getBoundedType()
  Line 215) expectedParam.asWildcard() ==> com.github.javaparser.symbolsolver.model.typesystem.Type.asWildcard()
  Line 220) expectedParam.describe() ==> com.github.javaparser.symbolsolver.model.typesystem.Type.describe()
  Line 227) type.isTypeVariable() ==> com.github.javaparser.symbolsolver.model.typesystem.Type.isTypeVariable()
  Line 228) type.describe().equals(tp.getName()) ==> java.lang.String.equals(java.lang.Object)
  Line 228) type.describe() ==> com.github.javaparser.symbolsolver.model.typesystem.Type.describe()
  Line 228) tp.getName() ==> com.github.javaparser.symbolsolver.model.declarations.TypeParameterDeclaration.getName()
  Line 229) tp.getBounds(typeSolver) ==> com.github.javaparser.symbolsolver.model.declarations.TypeParameterDeclaration.getBounds(com.github.javaparser.symbolsolver.model.resolution.TypeSolver)
  Line 230) bounds.size() ==> java.util.List.size()
  Line 232) bounds.size() ==> java.util.List.size()
  Line 233) bounds.get(0).getType() ==> com.github.javaparser.symbolsolver.model.declarations.TypeParameterDeclaration.Bound.getType()
  Line 233) bounds.get(0) ==> java.util.List.get(int)
  Line 235) typeSolver.solveType(Object.class.getCanonicalName()) ==> com.github.javaparser.symbolsolver.model.resolution.TypeSolver.solveType(java.lang.String)
  Line 235) Object.class.getCanonicalName() ==> java.lang.Class.getCanonicalName()
  Line 239) type.isPrimitive() ==> com.github.javaparser.symbolsolver.model.typesystem.Type.isPrimitive()
  Line 241) type.isArray() ==> com.github.javaparser.symbolsolver.model.typesystem.Type.isArray()
  Line 242) replaceTypeParam(type.asArrayType().getComponentType(), tp, typeSolver) ==> com.github.javaparser.symbolsolver.resolution.MethodResolutionLogic.replaceTypeParam(com.github.javaparser.symbolsolver.model.typesystem.Type, com.github.javaparser.symbolsolver.model.declarations.TypeParameterDeclaration, com.github.javaparser.symbolsolver.model.resolution.TypeSolver)
  Line 242) type.asArrayType().getComponentType() ==> com.github.javaparser.symbolsolver.model.typesystem.ArrayType.getComponentType()
  Line 242) type.asArrayType() ==> com.github.javaparser.symbolsolver.model.typesystem.Type.asArrayType()
  Line 243) type.isReferenceType() ==> com.github.javaparser.symbolsolver.model.typesystem.Type.isReferenceType()
  Line 244) type.asReferenceType() ==> com.github.javaparser.symbolsolver.model.typesystem.Type.asReferenceType()
  Line 245) result.transformTypeParameters(typeParam -> replaceTypeParam(typeParam, tp, typeSolver)).asReferenceType() ==> com.github.javaparser.symbolsolver.model.typesystem.Type.asReferenceType()
  Line 245) result.transformTypeParameters(typeParam -> replaceTypeParam(typeParam, tp, typeSolver)) ==> com.github.javaparser.symbolsolver.model.typesystem.ReferenceType.transformTypeParameters(com.github.javaparser.symbolsolver.model.typesystem.TypeTransformer)
  Line 245) replaceTypeParam(typeParam, tp, typeSolver) ==> com.github.javaparser.symbolsolver.resolution.MethodResolutionLogic.replaceTypeParam(com.github.javaparser.symbolsolver.model.typesystem.Type, com.github.javaparser.symbolsolver.model.declarations.TypeParameterDeclaration, com.github.javaparser.symbolsolver.model.resolution.TypeSolver)
  Line 247) type.isWildcard() ==> com.github.javaparser.symbolsolver.model.typesystem.Type.isWildcard()
  Line 248) type.describe().equals(tp.getName()) ==> java.lang.String.equals(java.lang.Object)
  Line 248) type.describe() ==> com.github.javaparser.symbolsolver.model.typesystem.Type.describe()
  Line 248) tp.getName() ==> com.github.javaparser.symbolsolver.model.declarations.TypeParameterDeclaration.getName()
  Line 249) tp.getBounds(typeSolver) ==> com.github.javaparser.symbolsolver.model.declarations.TypeParameterDeclaration.getBounds(com.github.javaparser.symbolsolver.model.resolution.TypeSolver)
  Line 250) bounds.size() ==> java.util.List.size()
  Line 252) bounds.size() ==> java.util.List.size()
  Line 253) bounds.get(0).getType() ==> com.github.javaparser.symbolsolver.model.declarations.TypeParameterDeclaration.Bound.getType()
  Line 253) bounds.get(0) ==> java.util.List.get(int)
  Line 255) typeSolver.solveType(Object.class.getCanonicalName()) ==> com.github.javaparser.symbolsolver.model.resolution.TypeSolver.solveType(java.lang.String)
  Line 255) Object.class.getCanonicalName() ==> java.lang.Class.getCanonicalName()
  Line 260) type.getClass().getCanonicalName() ==> java.lang.Class.getCanonicalName()
  Line 260) type.getClass() ==> java.lang.Object.getClass()
  Line 265) method.getName().equals(name) ==> java.lang.String.equals(java.lang.Object)
  Line 265) method.getName() ==> com.github.javaparser.symbolsolver.model.methods.MethodUsage.getName()
  Line 269) method.getNoParams() ==> com.github.javaparser.symbolsolver.model.methods.MethodUsage.getNoParams()
  Line 269) argumentsTypes.size() ==> java.util.List.size()
  Line 272) method.getNoParams() ==> com.github.javaparser.symbolsolver.model.methods.MethodUsage.getNoParams()
  Line 273) method.getParamType(i) ==> com.github.javaparser.symbolsolver.model.methods.MethodUsage.getParamType(int)
  Line 275) method.getParamType(i) ==> com.github.javaparser.symbolsolver.model.methods.MethodUsage.getParamType(int)
  Line 276) argumentsTypes.get(i) ==> java.util.List.get(int)
  Line 278) method.getDeclaration().getTypeParameters() ==> com.github.javaparser.symbolsolver.model.declarations.TypeParametrizable.getTypeParameters()
  Line 278) method.getDeclaration() ==> com.github.javaparser.symbolsolver.model.methods.MethodUsage.getDeclaration()
  Line 279) typeParameters.addAll(method.declaringType().getTypeParameters()) ==> java.util.List.addAll(java.util.Collection<? extends E>)
  Line 279) method.declaringType().getTypeParameters() ==> com.github.javaparser.symbolsolver.model.declarations.TypeParametrizable.getTypeParameters()
  Line 279) method.declaringType() ==> com.github.javaparser.symbolsolver.model.methods.MethodUsage.declaringType()
  Line 281) expectedType.describe().equals(actualType.describe()) ==> java.lang.String.equals(java.lang.Object)
  Line 281) expectedType.describe() ==> com.github.javaparser.symbolsolver.model.typesystem.Type.describe()
  Line 281) actualType.describe() ==> com.github.javaparser.symbolsolver.model.typesystem.Type.describe()
  Line 286) method.getParamTypes().size() ==> java.util.List.size()
  Line 286) method.getParamTypes() ==> com.github.javaparser.symbolsolver.model.methods.MethodUsage.getParamTypes()
  Line 287) method.getDeclaration().getParam(i) ==> com.github.javaparser.symbolsolver.model.declarations.MethodLikeDeclaration.getParam(int)
  Line 287) method.getDeclaration() ==> com.github.javaparser.symbolsolver.model.methods.MethodUsage.getDeclaration()
  Line 288) parameter.getType() ==> com.github.javaparser.symbolsolver.model.declarations.ValueDeclaration.getType()
  Line 289) parameter.isVariadic() ==> com.github.javaparser.symbolsolver.model.declarations.ParameterDeclaration.isVariadic()
  Line 290) parameterType.asArrayType().getComponentType() ==> com.github.javaparser.symbolsolver.model.typesystem.ArrayType.getComponentType()
  Line 290) parameterType.asArrayType() ==> com.github.javaparser.symbolsolver.model.typesystem.Type.asArrayType()
  Line 292) inferTypes(argumentsTypes.get(j), parameterType, derivedValues) ==> com.github.javaparser.symbolsolver.resolution.MethodResolutionLogic.inferTypes(com.github.javaparser.symbolsolver.model.typesystem.Type, com.github.javaparser.symbolsolver.model.typesystem.Type, java.util.Map<com.github.javaparser.symbolsolver.model.declarations.TypeParameterDeclaration, com.github.javaparser.symbolsolver.model.typesystem.Type>)
  Line 292) argumentsTypes.get(j) ==> java.util.List.get(int)
  Line 295) derivedValues.entrySet() ==> java.util.Map.entrySet()
  Line 296) entry.getKey() ==> java.util.Map.Entry.getKey()
  Line 297) expectedTypeWithInference.replaceTypeVariables(tp, entry.getValue()) ==> com.github.javaparser.symbolsolver.model.typesystem.Type.replaceTypeVariables(com.github.javaparser.symbolsolver.model.declarations.TypeParameterDeclaration, com.github.javaparser.symbolsolver.model.typesystem.Type)
  Line 297) entry.getValue() ==> java.util.Map.Entry.getValue()
  Line 301) tp.getBounds(typeSolver).isEmpty() ==> java.util.List.isEmpty()
  Line 301) tp.getBounds(typeSolver) ==> com.github.javaparser.symbolsolver.model.declarations.TypeParameterDeclaration.getBounds(com.github.javaparser.symbolsolver.model.resolution.TypeSolver)
  Line 303) expectedType.replaceTypeVariables(tp, Wildcard.extendsBound(new ReferenceTypeImpl(typeSolver.solveType(Object.class.getCanonicalName()), typeSolver))) ==> com.github.javaparser.symbolsolver.model.typesystem.Type.replaceTypeVariables(com.github.javaparser.symbolsolver.model.declarations.TypeParameterDeclaration, com.github.javaparser.symbolsolver.model.typesystem.Type)
  Line 303) Wildcard.extendsBound(new ReferenceTypeImpl(typeSolver.solveType(Object.class.getCanonicalName()), typeSolver)) ==> com.github.javaparser.symbolsolver.model.typesystem.Wildcard.extendsBound(com.github.javaparser.symbolsolver.model.typesystem.Type)
  Line 303) typeSolver.solveType(Object.class.getCanonicalName()) ==> com.github.javaparser.symbolsolver.model.resolution.TypeSolver.solveType(java.lang.String)
  Line 303) Object.class.getCanonicalName() ==> java.lang.Class.getCanonicalName()
  Line 304) tp.getBounds(typeSolver).size() ==> java.util.List.size()
  Line 304) tp.getBounds(typeSolver) ==> com.github.javaparser.symbolsolver.model.declarations.TypeParameterDeclaration.getBounds(com.github.javaparser.symbolsolver.model.resolution.TypeSolver)
  Line 305) tp.getBounds(typeSolver).get(0) ==> java.util.List.get(int)
  Line 305) tp.getBounds(typeSolver) ==> com.github.javaparser.symbolsolver.model.declarations.TypeParameterDeclaration.getBounds(com.github.javaparser.symbolsolver.model.resolution.TypeSolver)
  Line 306) bound.isExtends() ==> com.github.javaparser.symbolsolver.model.declarations.TypeParameterDeclaration.Bound.isExtends()
  Line 308) expectedType.replaceTypeVariables(tp, Wildcard.extendsBound(bound.getType())) ==> com.github.javaparser.symbolsolver.model.typesystem.Type.replaceTypeVariables(com.github.javaparser.symbolsolver.model.declarations.TypeParameterDeclaration, com.github.javaparser.symbolsolver.model.typesystem.Type)
  Line 308) Wildcard.extendsBound(bound.getType()) ==> com.github.javaparser.symbolsolver.model.typesystem.Wildcard.extendsBound(com.github.javaparser.symbolsolver.model.typesystem.Type)
  Line 308) bound.getType() ==> com.github.javaparser.symbolsolver.model.declarations.TypeParameterDeclaration.Bound.getType()
  Line 311) expectedType.replaceTypeVariables(tp, Wildcard.superBound(bound.getType())) ==> com.github.javaparser.symbolsolver.model.typesystem.Type.replaceTypeVariables(com.github.javaparser.symbolsolver.model.declarations.TypeParameterDeclaration, com.github.javaparser.symbolsolver.model.typesystem.Type)
  Line 311) Wildcard.superBound(bound.getType()) ==> com.github.javaparser.symbolsolver.model.typesystem.Wildcard.superBound(com.github.javaparser.symbolsolver.model.typesystem.Type)
  Line 311) bound.getType() ==> com.github.javaparser.symbolsolver.model.declarations.TypeParameterDeclaration.Bound.getType()
  Line 319) tp.getBounds(typeSolver).isEmpty() ==> java.util.List.isEmpty()
  Line 319) tp.getBounds(typeSolver) ==> com.github.javaparser.symbolsolver.model.declarations.TypeParameterDeclaration.getBounds(com.github.javaparser.symbolsolver.model.resolution.TypeSolver)
  Line 320) expectedType2.replaceTypeVariables(tp, new ReferenceTypeImpl(typeSolver.solveType(Object.class.getCanonicalName()), typeSolver)) ==> com.github.javaparser.symbolsolver.model.typesystem.Type.replaceTypeVariables(com.github.javaparser.symbolsolver.model.declarations.TypeParameterDeclaration, com.github.javaparser.symbolsolver.model.typesystem.Type)
  Line 320) typeSolver.solveType(Object.class.getCanonicalName()) ==> com.github.javaparser.symbolsolver.model.resolution.TypeSolver.solveType(java.lang.String)
  Line 320) Object.class.getCanonicalName() ==> java.lang.Class.getCanonicalName()
  Line 321) tp.getBounds(typeSolver).size() ==> java.util.List.size()
  Line 321) tp.getBounds(typeSolver) ==> com.github.javaparser.symbolsolver.model.declarations.TypeParameterDeclaration.getBounds(com.github.javaparser.symbolsolver.model.resolution.TypeSolver)
  Line 322) tp.getBounds(typeSolver).get(0) ==> java.util.List.get(int)
  Line 322) tp.getBounds(typeSolver) ==> com.github.javaparser.symbolsolver.model.declarations.TypeParameterDeclaration.getBounds(com.github.javaparser.symbolsolver.model.resolution.TypeSolver)
  Line 323) bound.isExtends() ==> com.github.javaparser.symbolsolver.model.declarations.TypeParameterDeclaration.Bound.isExtends()
  Line 324) expectedType2.replaceTypeVariables(tp, bound.getType()) ==> com.github.javaparser.symbolsolver.model.typesystem.Type.replaceTypeVariables(com.github.javaparser.symbolsolver.model.declarations.TypeParameterDeclaration, com.github.javaparser.symbolsolver.model.typesystem.Type)
  Line 324) bound.getType() ==> com.github.javaparser.symbolsolver.model.declarations.TypeParameterDeclaration.Bound.getType()
  Line 326) expectedType2.replaceTypeVariables(tp, new ReferenceTypeImpl(typeSolver.solveType(Object.class.getCanonicalName()), typeSolver)) ==> com.github.javaparser.symbolsolver.model.typesystem.Type.replaceTypeVariables(com.github.javaparser.symbolsolver.model.declarations.TypeParameterDeclaration, com.github.javaparser.symbolsolver.model.typesystem.Type)
  Line 326) typeSolver.solveType(Object.class.getCanonicalName()) ==> com.github.javaparser.symbolsolver.model.resolution.TypeSolver.solveType(java.lang.String)
  Line 326) Object.class.getCanonicalName() ==> java.lang.Class.getCanonicalName()
  Line 332) expectedType.isAssignableBy(actualType) ==> com.github.javaparser.symbolsolver.model.typesystem.Type.isAssignableBy(com.github.javaparser.symbolsolver.model.typesystem.Type)
  Line 333) expectedType2.isAssignableBy(actualType) ==> com.github.javaparser.symbolsolver.model.typesystem.Type.isAssignableBy(com.github.javaparser.symbolsolver.model.typesystem.Type)
  Line 334) expectedTypeWithInference.isAssignableBy(actualType) ==> com.github.javaparser.symbolsolver.model.typesystem.Type.isAssignableBy(com.github.javaparser.symbolsolver.model.typesystem.Type)
  Line 335) expectedTypeWithoutSubstitutions.isAssignableBy(actualType) ==> com.github.javaparser.symbolsolver.model.typesystem.Type.isAssignableBy(com.github.javaparser.symbolsolver.model.typesystem.Type)
  Line 347) ((JavaParserMethodDeclaration) m1).getWrappedNode().equals(((JavaParserMethodDeclaration) m2).getWrappedNode()) ==> com.github.javaparser.ast.Node.equals(java.lang.Object)
  Line 347) ((JavaParserMethodDeclaration) m1).getWrappedNode() ==> com.github.javaparser.symbolsolver.javaparsermodel.declarations.JavaParserMethodDeclaration.getWrappedNode()
  Line 347) ((JavaParserMethodDeclaration) m2).getWrappedNode() ==> com.github.javaparser.symbolsolver.javaparsermodel.declarations.JavaParserMethodDeclaration.getWrappedNode()
  Line 353) s.addAll(methods) ==> java.util.Set.addAll(java.util.Collection<? extends E>)
  Line 357) md.getQualifiedSignature() ==> com.github.javaparser.symbolsolver.model.declarations.MethodLikeDeclaration.getQualifiedSignature()
  Line 358) usedSignatures.contains(signature) ==> java.util.Set.contains(java.lang.Object)
  Line 359) usedSignatures.add(signature) ==> java.util.Set.add(E)
  Line 360) res.add(md) ==> java.util.List.add(E)
  Line 374) findMostApplicable(methods, name, argumentsTypes, typeSolver, false) ==> com.github.javaparser.symbolsolver.resolution.MethodResolutionLogic.findMostApplicable(java.util.List<com.github.javaparser.symbolsolver.model.declarations.MethodDeclaration>, java.lang.String, java.util.List<com.github.javaparser.symbolsolver.model.typesystem.Type>, com.github.javaparser.symbolsolver.model.resolution.TypeSolver, boolean)
  Line 375) res.isSolved() ==> com.github.javaparser.symbolsolver.model.resolution.SymbolReference.isSolved()
  Line 378) findMostApplicable(methods, name, argumentsTypes, typeSolver, true) ==> com.github.javaparser.symbolsolver.resolution.MethodResolutionLogic.findMostApplicable(java.util.List<com.github.javaparser.symbolsolver.model.declarations.MethodDeclaration>, java.lang.String, java.util.List<com.github.javaparser.symbolsolver.model.typesystem.Type>, com.github.javaparser.symbolsolver.model.resolution.TypeSolver, boolean)
  Line 382) getMethodsWithoutDuplicates(methods).stream().filter((m) -> isApplicable(m, name, argumentsTypes, typeSolver, wildcardTolerance)).collect(Collectors.toList()) ==> java.util.stream.Stream.collect(java.util.stream.Collector<? super T, A, R>)
  Line 382) getMethodsWithoutDuplicates(methods).stream().filter((m) -> isApplicable(m, name, argumentsTypes, typeSolver, wildcardTolerance)) ==> java.util.stream.Stream.filter(java.util.function.Predicate<? super T>)
  Line 382) getMethodsWithoutDuplicates(methods).stream() ==> java.util.Collection.stream()
  Line 382) getMethodsWithoutDuplicates(methods) ==> com.github.javaparser.symbolsolver.resolution.MethodResolutionLogic.getMethodsWithoutDuplicates(java.util.List<com.github.javaparser.symbolsolver.model.declarations.MethodDeclaration>)
  Line 382) isApplicable(m, name, argumentsTypes, typeSolver, wildcardTolerance) ==> com.github.javaparser.symbolsolver.resolution.MethodResolutionLogic.isApplicable(com.github.javaparser.symbolsolver.model.declarations.MethodDeclaration, java.lang.String, java.util.List<com.github.javaparser.symbolsolver.model.typesystem.Type>, com.github.javaparser.symbolsolver.model.resolution.TypeSolver, boolean)
  Line 382) Collectors.toList() ==> java.util.stream.Collectors.toList()
  Line 383) applicableMethods.isEmpty() ==> java.util.List.isEmpty()
  Line 384) SymbolReference.unsolved(MethodDeclaration.class) ==> com.github.javaparser.symbolsolver.model.resolution.SymbolReference.unsolved(java.lang.Class<S2>)
  Line 387) applicableMethods.size() ==> java.util.List.size()
  Line 389) argumentsTypes.size() ==> java.util.List.size()
  Line 390) argumentsTypes.get(i).isNull() ==> com.github.javaparser.symbolsolver.model.typesystem.Type.isNull()
  Line 390) argumentsTypes.get(i) ==> java.util.List.get(int)
  Line 391) nullParamIndexes.add(i) ==> java.util.List.add(E)
  Line 394) nullParamIndexes.isEmpty() ==> java.util.List.isEmpty()
  Line 399) methDecl.getParam(nullParamIndex.intValue()).getType().isArray() ==> com.github.javaparser.symbolsolver.model.typesystem.Type.isArray()
  Line 399) methDecl.getParam(nullParamIndex.intValue()).getType() ==> com.github.javaparser.symbolsolver.model.declarations.ValueDeclaration.getType()
  Line 399) methDecl.getParam(nullParamIndex.intValue()) ==> com.github.javaparser.symbolsolver.model.declarations.MethodLikeDeclaration.getParam(int)
  Line 399) nullParamIndex.intValue() ==> java.lang.Integer.intValue()
  Line 400) removeCandidates.add(methDecl) ==> java.util.Set.add(E)
  Line 404) removeCandidates.isEmpty() ==> java.util.Set.isEmpty()
  Line 404) removeCandidates.size() ==> java.util.Set.size()
  Line 404) applicableMethods.size() ==> java.util.List.size()
  Line 405) applicableMethods.removeAll(removeCandidates) ==> java.util.List.removeAll(java.util.Collection<? extends java.lang.Object>)
  Line 409) applicableMethods.size() ==> java.util.List.size()
  Line 410) SymbolReference.solved(applicableMethods.get(0)) ==> com.github.javaparser.symbolsolver.model.resolution.SymbolReference.solved(S2)
  Line 410) applicableMethods.get(0) ==> java.util.List.get(int)
  Line 412) applicableMethods.get(0) ==> java.util.List.get(int)
  Line 415) applicableMethods.size() ==> java.util.List.size()
  Line 416) applicableMethods.get(i) ==> java.util.List.get(int)
  Line 417) isMoreSpecific(winningCandidate, other, argumentsTypes, typeSolver) ==> com.github.javaparser.symbolsolver.resolution.MethodResolutionLogic.isMoreSpecific(com.github.javaparser.symbolsolver.model.declarations.MethodDeclaration, com.github.javaparser.symbolsolver.model.declarations.MethodDeclaration, java.util.List<com.github.javaparser.symbolsolver.model.typesystem.Type>, com.github.javaparser.symbolsolver.model.resolution.TypeSolver)
  Line 419) isMoreSpecific(other, winningCandidate, argumentsTypes, typeSolver) ==> com.github.javaparser.symbolsolver.resolution.MethodResolutionLogic.isMoreSpecific(com.github.javaparser.symbolsolver.model.declarations.MethodDeclaration, com.github.javaparser.symbolsolver.model.declarations.MethodDeclaration, java.util.List<com.github.javaparser.symbolsolver.model.typesystem.Type>, com.github.javaparser.symbolsolver.model.resolution.TypeSolver)
  Line 423) winningCandidate.declaringType().getQualifiedName().equals(other.declaringType().getQualifiedName()) ==> java.lang.String.equals(java.lang.Object)
  Line 423) winningCandidate.declaringType().getQualifiedName() ==> com.github.javaparser.symbolsolver.model.declarations.TypeDeclaration.getQualifiedName()
  Line 423) winningCandidate.declaringType() ==> com.github.javaparser.symbolsolver.model.declarations.MethodLikeDeclaration.declaringType()
  Line 423) other.declaringType().getQualifiedName() ==> com.github.javaparser.symbolsolver.model.declarations.TypeDeclaration.getQualifiedName()
  Line 423) other.declaringType() ==> com.github.javaparser.symbolsolver.model.declarations.MethodLikeDeclaration.declaringType()
  Line 432) isExactMatch(winningCandidate, argumentsTypes) ==> com.github.javaparser.symbolsolver.resolution.MethodResolutionLogic.isExactMatch(com.github.javaparser.symbolsolver.model.declarations.MethodLikeDeclaration, java.util.List<com.github.javaparser.symbolsolver.model.typesystem.Type>)
  Line 433) isExactMatch(other, argumentsTypes) ==> com.github.javaparser.symbolsolver.resolution.MethodResolutionLogic.isExactMatch(com.github.javaparser.symbolsolver.model.declarations.MethodLikeDeclaration, java.util.List<com.github.javaparser.symbolsolver.model.typesystem.Type>)
  Line 440) SymbolReference.solved(winningCandidate) ==> com.github.javaparser.symbolsolver.model.resolution.SymbolReference.solved(S2)
  Line 445) method.getNumberOfParams() ==> com.github.javaparser.symbolsolver.model.declarations.MethodLikeDeclaration.getNumberOfParams()
  Line 446) method.getParam(i).getType().equals(argumentsTypes.get(i)) ==> java.lang.Object.equals(java.lang.Object)
  Line 446) method.getParam(i).getType() ==> com.github.javaparser.symbolsolver.model.declarations.ValueDeclaration.getType()
  Line 446) method.getParam(i) ==> com.github.javaparser.symbolsolver.model.declarations.MethodLikeDeclaration.getParam(int)
  Line 446) argumentsTypes.get(i) ==> java.util.List.get(int)
  Line 455) methodA.getNumberOfParams() ==> com.github.javaparser.symbolsolver.model.declarations.MethodLikeDeclaration.getNumberOfParams()
  Line 455) methodB.getNumberOfParams() ==> com.github.javaparser.symbolsolver.model.declarations.MethodLikeDeclaration.getNumberOfParams()
  Line 458) methodA.getNumberOfParams() ==> com.github.javaparser.symbolsolver.model.declarations.MethodLikeDeclaration.getNumberOfParams()
  Line 458) methodB.getNumberOfParams() ==> com.github.javaparser.symbolsolver.model.declarations.MethodLikeDeclaration.getNumberOfParams()
  Line 461) methodA.getNumberOfParams() ==> com.github.javaparser.symbolsolver.model.declarations.MethodLikeDeclaration.getNumberOfParams()
  Line 462) methodA.getParam(i).getType() ==> com.github.javaparser.symbolsolver.model.declarations.ValueDeclaration.getType()
  Line 462) methodA.getParam(i) ==> com.github.javaparser.symbolsolver.model.declarations.MethodLikeDeclaration.getParam(int)
  Line 463) methodB.getParam(i).getType() ==> com.github.javaparser.symbolsolver.model.declarations.ValueDeclaration.getType()
  Line 463) methodB.getParam(i) ==> com.github.javaparser.symbolsolver.model.declarations.MethodLikeDeclaration.getParam(int)
  Line 465) tdB.isAssignableBy(tdA) ==> com.github.javaparser.symbolsolver.model.typesystem.Type.isAssignableBy(com.github.javaparser.symbolsolver.model.typesystem.Type)
  Line 465) tdA.isAssignableBy(tdB) ==> com.github.javaparser.symbolsolver.model.typesystem.Type.isAssignableBy(com.github.javaparser.symbolsolver.model.typesystem.Type)
  Line 469) tdA.isAssignableBy(tdB) ==> com.github.javaparser.symbolsolver.model.typesystem.Type.isAssignableBy(com.github.javaparser.symbolsolver.model.typesystem.Type)
  Line 469) tdB.isAssignableBy(tdA) ==> com.github.javaparser.symbolsolver.model.typesystem.Type.isAssignableBy(com.github.javaparser.symbolsolver.model.typesystem.Type)
  Line 475) argumentTypes.size() ==> java.util.List.size()
  Line 477) methodA.hasVariadicParameter() ==> com.github.javaparser.symbolsolver.model.declarations.MethodLikeDeclaration.hasVariadicParameter()
  Line 477) methodB.hasVariadicParameter() ==> com.github.javaparser.symbolsolver.model.declarations.MethodLikeDeclaration.hasVariadicParameter()
  Line 479) argumentTypes.get(lastIndex).isArray() ==> com.github.javaparser.symbolsolver.model.typesystem.Type.isArray()
  Line 479) argumentTypes.get(lastIndex) ==> java.util.List.get(int)
  Line 483) argumentTypes.get(lastIndex).isArray() ==> com.github.javaparser.symbolsolver.model.typesystem.Type.isArray()
  Line 483) argumentTypes.get(lastIndex) ==> java.util.List.get(int)
  Line 487) methodA.hasVariadicParameter() ==> com.github.javaparser.symbolsolver.model.declarations.MethodLikeDeclaration.hasVariadicParameter()
  Line 487) methodB.hasVariadicParameter() ==> com.github.javaparser.symbolsolver.model.declarations.MethodLikeDeclaration.hasVariadicParameter()
  Line 490) argumentTypes.get(lastIndex).isArray() ==> com.github.javaparser.symbolsolver.model.typesystem.Type.isArray()
  Line 490) argumentTypes.get(lastIndex) ==> java.util.List.get(int)
  Line 494) argumentTypes.get(lastIndex).isArray() ==> com.github.javaparser.symbolsolver.model.typesystem.Type.isArray()
  Line 494) argumentTypes.get(lastIndex) ==> java.util.List.get(int)
  Line 505) methodA.getNoParams() ==> com.github.javaparser.symbolsolver.model.methods.MethodUsage.getNoParams()
  Line 506) methodA.getParamType(i) ==> com.github.javaparser.symbolsolver.model.methods.MethodUsage.getParamType(int)
  Line 507) methodB.getParamType(i) ==> com.github.javaparser.symbolsolver.model.methods.MethodUsage.getParamType(int)
  Line 509) tdA.isAssignableBy(tdB) ==> com.github.javaparser.symbolsolver.model.typesystem.Type.isAssignableBy(com.github.javaparser.symbolsolver.model.typesystem.Type)
  Line 510) tdB.isAssignableBy(tdA) ==> com.github.javaparser.symbolsolver.model.typesystem.Type.isAssignableBy(com.github.javaparser.symbolsolver.model.typesystem.Type)
  Line 525) methods.stream().filter((m) -> isApplicable(m, name, argumentsTypes, typeSolver)).collect(Collectors.toList()) ==> java.util.stream.Stream.collect(java.util.stream.Collector<? super T, A, R>)
  Line 525) methods.stream().filter((m) -> isApplicable(m, name, argumentsTypes, typeSolver)) ==> java.util.stream.Stream.filter(java.util.function.Predicate<? super T>)
  Line 525) methods.stream() ==> java.util.Collection.stream()
  Line 525) isApplicable(m, name, argumentsTypes, typeSolver) ==> com.github.javaparser.symbolsolver.resolution.MethodResolutionLogic.isApplicable(com.github.javaparser.symbolsolver.model.methods.MethodUsage, java.lang.String, java.util.List<com.github.javaparser.symbolsolver.model.typesystem.Type>, com.github.javaparser.symbolsolver.model.resolution.TypeSolver)
  Line 525) Collectors.toList() ==> java.util.stream.Collectors.toList()
  Line 527) applicableMethods.isEmpty() ==> java.util.List.isEmpty()
  Line 528) Optional.empty() ==> java.util.Optional.empty()
  Line 530) applicableMethods.size() ==> java.util.List.size()
  Line 531) Optional.of(applicableMethods.get(0)) ==> java.util.Optional.of(T)
  Line 531) applicableMethods.get(0) ==> java.util.List.get(int)
  Line 533) applicableMethods.get(0) ==> java.util.List.get(int)
  Line 534) applicableMethods.size() ==> java.util.List.size()
  Line 535) applicableMethods.get(i) ==> java.util.List.get(int)
  Line 536) isMoreSpecific(winningCandidate, other, typeSolver) ==> com.github.javaparser.symbolsolver.resolution.MethodResolutionLogic.isMoreSpecific(com.github.javaparser.symbolsolver.model.methods.MethodUsage, com.github.javaparser.symbolsolver.model.methods.MethodUsage, com.github.javaparser.symbolsolver.model.resolution.TypeSolver)
  Line 538) isMoreSpecific(other, winningCandidate, typeSolver) ==> com.github.javaparser.symbolsolver.resolution.MethodResolutionLogic.isMoreSpecific(com.github.javaparser.symbolsolver.model.methods.MethodUsage, com.github.javaparser.symbolsolver.model.methods.MethodUsage, com.github.javaparser.symbolsolver.model.resolution.TypeSolver)
  Line 541) winningCandidate.declaringType().getQualifiedName().equals(other.declaringType().getQualifiedName()) ==> java.lang.String.equals(java.lang.Object)
  Line 541) winningCandidate.declaringType().getQualifiedName() ==> com.github.javaparser.symbolsolver.model.declarations.TypeDeclaration.getQualifiedName()
  Line 541) winningCandidate.declaringType() ==> com.github.javaparser.symbolsolver.model.methods.MethodUsage.declaringType()
  Line 541) other.declaringType().getQualifiedName() ==> com.github.javaparser.symbolsolver.model.declarations.TypeDeclaration.getQualifiedName()
  Line 541) other.declaringType() ==> com.github.javaparser.symbolsolver.model.methods.MethodUsage.declaringType()
  Line 542) areOverride(winningCandidate, other) ==> com.github.javaparser.symbolsolver.resolution.MethodResolutionLogic.areOverride(com.github.javaparser.symbolsolver.model.methods.MethodUsage, com.github.javaparser.symbolsolver.model.methods.MethodUsage)
  Line 543) winningCandidate.declaringType().getQualifiedName() ==> com.github.javaparser.symbolsolver.model.declarations.TypeDeclaration.getQualifiedName()
  Line 543) winningCandidate.declaringType() ==> com.github.javaparser.symbolsolver.model.methods.MethodUsage.declaringType()
  Line 551) Optional.of(winningCandidate) ==> java.util.Optional.of(T)
  Line 556) winningCandidate.getName().equals(other.getName()) ==> java.lang.String.equals(java.lang.Object)
  Line 556) winningCandidate.getName() ==> com.github.javaparser.symbolsolver.model.methods.MethodUsage.getName()
  Line 556) other.getName() ==> com.github.javaparser.symbolsolver.model.methods.MethodUsage.getName()
  Line 559) winningCandidate.getNoParams() ==> com.github.javaparser.symbolsolver.model.methods.MethodUsage.getNoParams()
  Line 559) other.getNoParams() ==> com.github.javaparser.symbolsolver.model.methods.MethodUsage.getNoParams()
  Line 562) winningCandidate.getNoParams() ==> com.github.javaparser.symbolsolver.model.methods.MethodUsage.getNoParams()
  Line 563) winningCandidate.getParamTypes().get(i).equals(other.getParamTypes().get(i)) ==> java.lang.Object.equals(java.lang.Object)
  Line 563) winningCandidate.getParamTypes().get(i) ==> java.util.List.get(int)
  Line 563) winningCandidate.getParamTypes() ==> com.github.javaparser.symbolsolver.model.methods.MethodUsage.getParamTypes()
  Line 563) other.getParamTypes().get(i) ==> java.util.List.get(int)
  Line 563) other.getParamTypes() ==> com.github.javaparser.symbolsolver.model.methods.MethodUsage.getParamTypes()
  Line 571) solveMethodInType(typeDeclaration, name, argumentsTypes, false, typeSolver) ==> com.github.javaparser.symbolsolver.resolution.MethodResolutionLogic.solveMethodInType(com.github.javaparser.symbolsolver.model.declarations.TypeDeclaration, java.lang.String, java.util.List<com.github.javaparser.symbolsolver.model.typesystem.Type>, boolean, com.github.javaparser.symbolsolver.model.resolution.TypeSolver)
  Line 587) ((JavaParserClassDeclaration) typeDeclaration).getContext() ==> com.github.javaparser.symbolsolver.javaparsermodel.declarations.JavaParserClassDeclaration.getContext()
  Line 588) ctx.solveMethod(name, argumentsTypes, staticOnly, typeSolver) ==> com.github.javaparser.symbolsolver.core.resolution.Context.solveMethod(java.lang.String, java.util.List<com.github.javaparser.symbolsolver.model.typesystem.Type>, boolean, com.github.javaparser.symbolsolver.model.resolution.TypeSolver)
  Line 591) ((JavaParserInterfaceDeclaration) typeDeclaration).getContext() ==> com.github.javaparser.symbolsolver.javaparsermodel.declarations.JavaParserInterfaceDeclaration.getContext()
  Line 592) ctx.solveMethod(name, argumentsTypes, staticOnly, typeSolver) ==> com.github.javaparser.symbolsolver.core.resolution.Context.solveMethod(java.lang.String, java.util.List<com.github.javaparser.symbolsolver.model.typesystem.Type>, boolean, com.github.javaparser.symbolsolver.model.resolution.TypeSolver)
  Line 595) name.equals("values") ==> java.lang.String.equals(java.lang.Object)
  Line 595) argumentsTypes.isEmpty() ==> java.util.List.isEmpty()
  Line 596) SymbolReference.solved(new JavaParserEnumDeclaration.ValuesMethod((JavaParserEnumDeclaration) typeDeclaration, typeSolver)) ==> com.github.javaparser.symbolsolver.model.resolution.SymbolReference.solved(S2)
  Line 598) ((JavaParserEnumDeclaration) typeDeclaration).getContext() ==> com.github.javaparser.symbolsolver.javaparsermodel.declarations.JavaParserEnumDeclaration.getContext()
  Line 599) ctx.solveMethod(name, argumentsTypes, staticOnly, typeSolver) ==> com.github.javaparser.symbolsolver.core.resolution.Context.solveMethod(java.lang.String, java.util.List<com.github.javaparser.symbolsolver.model.typesystem.Type>, boolean, com.github.javaparser.symbolsolver.model.resolution.TypeSolver)
  Line 602) ((ReflectionClassDeclaration) typeDeclaration).solveMethod(name, argumentsTypes, staticOnly) ==> com.github.javaparser.symbolsolver.reflectionmodel.ReflectionClassDeclaration.solveMethod(java.lang.String, java.util.List<com.github.javaparser.symbolsolver.model.typesystem.Type>, boolean)
  Line 605) ((ReflectionInterfaceDeclaration) typeDeclaration).solveMethod(name, argumentsTypes, staticOnly) ==> com.github.javaparser.symbolsolver.reflectionmodel.ReflectionInterfaceDeclaration.solveMethod(java.lang.String, java.util.List<com.github.javaparser.symbolsolver.model.typesystem.Type>, boolean)
  Line 608) ((ReflectionEnumDeclaration) typeDeclaration).solveMethod(name, argumentsTypes, staticOnly) ==> com.github.javaparser.symbolsolver.reflectionmodel.ReflectionEnumDeclaration.solveMethod(java.lang.String, java.util.List<com.github.javaparser.symbolsolver.model.typesystem.Type>, boolean)
  Line 611) ((JavassistInterfaceDeclaration) typeDeclaration).solveMethod(name, argumentsTypes, staticOnly) ==> com.github.javaparser.symbolsolver.javassistmodel.JavassistInterfaceDeclaration.solveMethod(java.lang.String, java.util.List<com.github.javaparser.symbolsolver.model.typesystem.Type>, boolean)
  Line 614) ((JavassistClassDeclaration) typeDeclaration).solveMethod(name, argumentsTypes, staticOnly) ==> com.github.javaparser.symbolsolver.javassistmodel.JavassistClassDeclaration.solveMethod(java.lang.String, java.util.List<com.github.javaparser.symbolsolver.model.typesystem.Type>, boolean)
  Line 617) ((JavassistEnumDeclaration) typeDeclaration).solveMethod(name, argumentsTypes, staticOnly) ==> com.github.javaparser.symbolsolver.javassistmodel.JavassistEnumDeclaration.solveMethod(java.lang.String, java.util.List<com.github.javaparser.symbolsolver.model.typesystem.Type>, boolean)
  Line 619) typeDeclaration.getClass().getCanonicalName() ==> java.lang.Class.getCanonicalName()
  Line 619) typeDeclaration.getClass() ==> java.lang.Object.getClass()
  Line 625) source.equals(target) ==> java.lang.Object.equals(java.lang.Object)
  Line 628) source.isReferenceType() ==> com.github.javaparser.symbolsolver.model.typesystem.Type.isReferenceType()
  Line 628) target.isReferenceType() ==> com.github.javaparser.symbolsolver.model.typesystem.Type.isReferenceType()
  Line 629) source.asReferenceType() ==> com.github.javaparser.symbolsolver.model.typesystem.Type.asReferenceType()
  Line 630) target.asReferenceType() ==> com.github.javaparser.symbolsolver.model.typesystem.Type.asReferenceType()
  Line 631) sourceRefType.getQualifiedName().equals(targetRefType.getQualifiedName()) ==> java.lang.String.equals(java.lang.Object)
  Line 631) sourceRefType.getQualifiedName() ==> com.github.javaparser.symbolsolver.model.typesystem.ReferenceType.getQualifiedName()
  Line 631) targetRefType.getQualifiedName() ==> com.github.javaparser.symbolsolver.model.typesystem.ReferenceType.getQualifiedName()
  Line 632) sourceRefType.isRawType() ==> com.github.javaparser.symbolsolver.model.typesystem.ReferenceType.isRawType()
  Line 632) targetRefType.isRawType() ==> com.github.javaparser.symbolsolver.model.typesystem.ReferenceType.isRawType()
  Line 633) sourceRefType.typeParametersValues().size() ==> java.util.List.size()
  Line 633) sourceRefType.typeParametersValues() ==> com.github.javaparser.symbolsolver.model.typesystem.ReferenceType.typeParametersValues()
  Line 634) inferTypes(sourceRefType.typeParametersValues().get(i), targetRefType.typeParametersValues().get(i), mappings) ==> com.github.javaparser.symbolsolver.resolution.MethodResolutionLogic.inferTypes(com.github.javaparser.symbolsolver.model.typesystem.Type, com.github.javaparser.symbolsolver.model.typesystem.Type, java.util.Map<com.github.javaparser.symbolsolver.model.declarations.TypeParameterDeclaration, com.github.javaparser.symbolsolver.model.typesystem.Type>)
  Line 634) sourceRefType.typeParametersValues().get(i) ==> java.util.List.get(int)
  Line 634) sourceRefType.typeParametersValues() ==> com.github.javaparser.symbolsolver.model.typesystem.ReferenceType.typeParametersValues()
  Line 634) targetRefType.typeParametersValues().get(i) ==> java.util.List.get(int)
  Line 634) targetRefType.typeParametersValues() ==> com.github.javaparser.symbolsolver.model.typesystem.ReferenceType.typeParametersValues()
  Line 640) source.isReferenceType() ==> com.github.javaparser.symbolsolver.model.typesystem.Type.isReferenceType()
  Line 640) target.isWildcard() ==> com.github.javaparser.symbolsolver.model.typesystem.Type.isWildcard()
  Line 641) target.asWildcard().isBounded() ==> com.github.javaparser.symbolsolver.model.typesystem.Wildcard.isBounded()
  Line 641) target.asWildcard() ==> com.github.javaparser.symbolsolver.model.typesystem.Type.asWildcard()
  Line 642) inferTypes(source, target.asWildcard().getBoundedType(), mappings) ==> com.github.javaparser.symbolsolver.resolution.MethodResolutionLogic.inferTypes(com.github.javaparser.symbolsolver.model.typesystem.Type, com.github.javaparser.symbolsolver.model.typesystem.Type, java.util.Map<com.github.javaparser.symbolsolver.model.declarations.TypeParameterDeclaration, com.github.javaparser.symbolsolver.model.typesystem.Type>)
  Line 642) target.asWildcard().getBoundedType() ==> com.github.javaparser.symbolsolver.model.typesystem.Wildcard.getBoundedType()
  Line 642) target.asWildcard() ==> com.github.javaparser.symbolsolver.model.typesystem.Type.asWildcard()
  Line 647) source.isWildcard() ==> com.github.javaparser.symbolsolver.model.typesystem.Type.isWildcard()
  Line 647) target.isWildcard() ==> com.github.javaparser.symbolsolver.model.typesystem.Type.isWildcard()
  Line 650) source.isReferenceType() ==> com.github.javaparser.symbolsolver.model.typesystem.Type.isReferenceType()
  Line 650) target.isTypeVariable() ==> com.github.javaparser.symbolsolver.model.typesystem.Type.isTypeVariable()
  Line 651) mappings.put(target.asTypeParameter(), source) ==> java.util.Map.put(K, V)
  Line 651) target.asTypeParameter() ==> com.github.javaparser.symbolsolver.model.typesystem.Type.asTypeParameter()
  Line 655) source.isWildcard() ==> com.github.javaparser.symbolsolver.model.typesystem.Type.isWildcard()
  Line 655) target.isReferenceType() ==> com.github.javaparser.symbolsolver.model.typesystem.Type.isReferenceType()
  Line 656) source.asWildcard().isBounded() ==> com.github.javaparser.symbolsolver.model.typesystem.Wildcard.isBounded()
  Line 656) source.asWildcard() ==> com.github.javaparser.symbolsolver.model.typesystem.Type.asWildcard()
  Line 657) inferTypes(source.asWildcard().getBoundedType(), target, mappings) ==> com.github.javaparser.symbolsolver.resolution.MethodResolutionLogic.inferTypes(com.github.javaparser.symbolsolver.model.typesystem.Type, com.github.javaparser.symbolsolver.model.typesystem.Type, java.util.Map<com.github.javaparser.symbolsolver.model.declarations.TypeParameterDeclaration, com.github.javaparser.symbolsolver.model.typesystem.Type>)
  Line 657) source.asWildcard().getBoundedType() ==> com.github.javaparser.symbolsolver.model.typesystem.Wildcard.getBoundedType()
  Line 657) source.asWildcard() ==> com.github.javaparser.symbolsolver.model.typesystem.Type.asWildcard()
  Line 662) source.isWildcard() ==> com.github.javaparser.symbolsolver.model.typesystem.Type.isWildcard()
  Line 662) target.isTypeVariable() ==> com.github.javaparser.symbolsolver.model.typesystem.Type.isTypeVariable()
  Line 663) mappings.put(target.asTypeParameter(), source) ==> java.util.Map.put(K, V)
  Line 663) target.asTypeParameter() ==> com.github.javaparser.symbolsolver.model.typesystem.Type.asTypeParameter()
  Line 666) source.isTypeVariable() ==> com.github.javaparser.symbolsolver.model.typesystem.Type.isTypeVariable()
  Line 666) target.isTypeVariable() ==> com.github.javaparser.symbolsolver.model.typesystem.Type.isTypeVariable()
  Line 667) mappings.put(target.asTypeParameter(), source) ==> java.util.Map.put(K, V)
  Line 667) target.asTypeParameter() ==> com.github.javaparser.symbolsolver.model.typesystem.Type.asTypeParameter()
  Line 670) source.isPrimitive() ==> com.github.javaparser.symbolsolver.model.typesystem.Type.isPrimitive()
  Line 670) target.isPrimitive() ==> com.github.javaparser.symbolsolver.model.typesystem.Type.isPrimitive()
  Line 673) source.isNull() ==> com.github.javaparser.symbolsolver.model.typesystem.Type.isNull()
