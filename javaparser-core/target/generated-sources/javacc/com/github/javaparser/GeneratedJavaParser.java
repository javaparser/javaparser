/* Generated By:JavaCC: Do not edit this line. GeneratedJavaParser.java */
/*
 * Copyright (C) 2007-2010 JÃºlio Vilmar Gesser.
 * Copyright (C) 2011, 2013-2020 The JavaParser Team.
 *
 * This file is part of JavaParser.
 *
 * JavaParser can be used either under the terms of
 * a) the GNU Lesser General Public License as published by
 *     the Free Software Foundation, either version 3 of the License, or
 *     (at your option) any later version.
 * b) the terms of the Apache License
 *
 * You should have received a copy of both licenses in LICENCE.LGPL and
 * LICENCE.APACHE. Please refer to those files for details.
 *
 * JavaParser is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 */
package com.github.javaparser;

import java.io.*;
import java.util.*;
import com.github.javaparser.ast.*;
import com.github.javaparser.ast.body.*;
import com.github.javaparser.ast.comments.*;
import com.github.javaparser.ast.modules.*;
import com.github.javaparser.ast.expr.*;
import com.github.javaparser.ast.stmt.*;
import com.github.javaparser.ast.type.*;
import com.github.javaparser.utils.*;
import static com.github.javaparser.JavaToken.INVALID;
import static com.github.javaparser.ast.Node.Parsedness.UNPARSABLE;
import static com.github.javaparser.utils.Utils.*;
import static com.github.javaparser.ast.NodeList.*;
import static com.github.javaparser.GeneratedJavaParser.*;
import static com.github.javaparser.Range.*;
import static com.github.javaparser.Position.*;
import static com.github.javaparser.ast.type.ArrayType.*;
import static com.github.javaparser.GeneratedJavaParserTokenManagerBase.*;
import static com.github.javaparser.ast.stmt.SwitchEntry.Type.*;

@Generated("JavaCC")
final class GeneratedJavaParser extends GeneratedJavaParserBase implements GeneratedJavaParserConstants {
    /* Returns the JavaParser specific token type of the last matched token */
    JavaToken jpToken() {
        return token.javaToken;
    }

    /* Changes the amount by which the horizontal position is increased when a tab character is encountered.
        One by default.*/
    void setTabSize(int size) {
        jj_input_stream.setTabSize(size);
    }

    @Override
    GeneratedJavaParserTokenManager getTokenSource() {
        return token_source;
    }

  final public CompilationUnit CompilationUnit() throws ParseException {
    PackageDeclaration packageDeclaration = null;
    NodeList<ImportDeclaration> imports = emptyNodeList();
    ImportDeclaration in = null;
    NodeList<TypeDeclaration<?>> types = emptyNodeList();
    ModifierHolder modifier;
    TypeDeclaration<?> tn = null;
    ModuleDeclaration module = null;
    try {
      label_1:
      while (true) {
        if (jj_2_1(2)) {
          ;
        } else {
          break label_1;
        }
        jj_consume_token(SEMICOLON);
      }
      if (jj_2_2(2147483647)) {
        packageDeclaration = PackageDeclaration();
      } else {
        ;
      }
      label_2:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case ABSTRACT:
        case CLASS:
        case _DEFAULT:
        case ENUM:
        case FINAL:
        case IMPORT:
        case INTERFACE:
        case NATIVE:
        case PRIVATE:
        case PROTECTED:
        case PUBLIC:
        case STATIC:
        case STRICTFP:
        case SYNCHRONIZED:
        case TRANSIENT:
        case VOLATILE:
        case OPEN:
        case MODULE:
        case TRANSITIVE:
        case SEMICOLON:
        case AT:
          ;
          break;
        default:
          jj_la1[0] = jj_gen;
          break label_2;
        }
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case IMPORT:
          in = ImportDeclaration();
                                       imports = add(imports, in);
          break;
        case ABSTRACT:
        case CLASS:
        case _DEFAULT:
        case ENUM:
        case FINAL:
        case INTERFACE:
        case NATIVE:
        case PRIVATE:
        case PROTECTED:
        case PUBLIC:
        case STATIC:
        case STRICTFP:
        case SYNCHRONIZED:
        case TRANSIENT:
        case VOLATILE:
        case OPEN:
        case MODULE:
        case TRANSITIVE:
        case SEMICOLON:
        case AT:
          modifier = Modifiers();
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case CLASS:
          case INTERFACE:
            tn = ClassOrInterfaceDeclaration(modifier);
                                                                 types = add(types, tn);
            break;
          case ENUM:
            tn = EnumDeclaration(modifier);
                                                     types = add(types, tn);
            break;
          case AT:
            tn = AnnotationTypeDeclaration(modifier);
                                                               types = add(types, tn);
            break;
          case OPEN:
          case MODULE:
            module = ModuleDeclaration(modifier);
            break;
          case SEMICOLON:
            jj_consume_token(SEMICOLON);
            break;
          default:
            jj_la1[1] = jj_gen;
            jj_consume_token(-1);
            throw new ParseException();
          }
          break;
        default:
          jj_la1[2] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case 0:
        jj_consume_token(0);
        break;
      case CTRL_Z:
        jj_consume_token(CTRL_Z);
        break;
      default:
        jj_la1[3] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
          {if (true) return new CompilationUnit(range(token_source.getHomejpToken(), jpToken()), packageDeclaration, imports, types, module);}
    } catch (ParseException e) {
        recover(EOF, e);
        final CompilationUnit compilationUnit = new CompilationUnit(range(token_source.getHomejpToken(), jpToken()), null, new NodeList<ImportDeclaration>(), new NodeList<TypeDeclaration<?>>(), null);
        compilationUnit.setParsed(UNPARSABLE);
        {if (true) return compilationUnit;}
    }
    throw new Error("Missing return statement in function");
  }

/**
 * https://docs.oracle.com/javase/specs/jls/se15/html/jls-7.html#jls-7.4.1
 * <pre>{@code
 *     PackageDeclaration:
 *         {PackageModifier} package Identifier {. Identifier} ;
 *     PackageModifier:
 *         Annotation
 * }</pre>
 */
  final public PackageDeclaration PackageDeclaration() throws ParseException {
    NodeList<AnnotationExpr> annotations = new NodeList<AnnotationExpr>();
    Name name;
    JavaToken begin;
    annotations = Annotations();
    jj_consume_token(PACKAGE);
               begin = jpToken();
    name = Name();
    jj_consume_token(SEMICOLON);
      {if (true) return new PackageDeclaration(range(begin, jpToken()), annotations, name);}
    throw new Error("Missing return statement in function");
  }

/**
 * Import declaration types are not differentiated in the class hierarchy.
 * https://docs.oracle.com/javase/specs/jls/se15/html/jls-7.html#jls-7.5
 * <pre>{@code
 *     ImportDeclaration:
 *         SingleTypeImportDeclaration
 *         TypeImportOnDemandDeclaration
 *         SingleStaticImportDeclaration
 *         StaticImportOnDemandDeclaration
 * }</pre>
 * Note that the JLS terminology "On Demand" and JavaParser terminology "Asterisk" are equivalent
 * <pre>{@code
 *     SingleTypeImportDeclaration:
 *         import TypeName ;
 *     TypeImportOnDemandDeclaration:
 *         import PackageOrTypeName . * ;
 *     SingleStaticImportDeclaration:
 *         import static TypeName . Identifier ;
 *     StaticImportOnDemandDeclaration:
 *         import static TypeName . * ;
 * }</pre>
 */
  final public ImportDeclaration ImportDeclaration() throws ParseException {
    Name name;
    boolean isStatic = false;
    boolean isAsterisk = false;
    JavaToken begin;
    jj_consume_token(IMPORT);
              begin = jpToken();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case STATIC:
      jj_consume_token(STATIC);
                 isStatic = true;
      break;
    default:
      jj_la1[4] = jj_gen;
      ;
    }
    name = Name();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case DOT:
      jj_consume_token(DOT);
      jj_consume_token(STAR);
                isAsterisk = true;
      break;
    default:
      jj_la1[5] = jj_gen;
      ;
    }
    jj_consume_token(SEMICOLON);
      {if (true) return new ImportDeclaration(range(begin, jpToken()), name, isStatic, isAsterisk);}
    throw new Error("Missing return statement in function");
  }

/*
 * Modifiers. We match all modifiers in a single rule to reduce the chances of
 * syntax errors for simple modifier mistakes. It will also enable us to give
 * better error messages.
 * Class Modifiers: https://docs.oracle.com/javase/specs/jls/se15/html/jls-8.html#jls-8.1.1
 * <pre>{@code
 *     ClassModifier:
 *         (one of)
 *         Annotation public protected private
 *         abstract static final strictfp
 * }</pre>
 * Field Modifiers: https://docs.oracle.com/javase/specs/jls/se15/html/jls-8.html#jls-8.3.1
 * <pre>{@code
 *     FieldModifier:
 *         (one of)
 *         Annotation public protected private
 *         static final transient volatile
 * }</pre>
 * Method Modifiers: https://docs.oracle.com/javase/specs/jls/se15/html/jls-8.html#jls-8.4.3
 * <pre>{@code
 *     MethodModifier:
 *         (one of)
 *         Annotation public protected private
 *         abstract static final synchronized native strictfp
 * }</pre>
 * Constructor Modifiers: https://docs.oracle.com/javase/specs/jls/se15/html/jls-8.html#jls-8.8.3
 * <pre>{@code
 *     ConstructorModifier:
 *         (one of)
 *         Annotation public protected private
 * }</pre>
 */
  final public ModifierHolder Modifiers() throws ParseException {
    JavaToken begin = INVALID;
    NodeList<Modifier> modifiers = new NodeList<Modifier>();
    NodeList<AnnotationExpr> annotations = new NodeList<AnnotationExpr>();
    AnnotationExpr ann;
    label_3:
    while (true) {
      if (jj_2_3(2)) {
        ;
      } else {
        break label_3;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case PUBLIC:
        jj_consume_token(PUBLIC);
                       add(modifiers, new Modifier(tokenRange(), Modifier.Keyword.PUBLIC)); begin = orIfInvalid(begin, jpToken());
        break;
      case STATIC:
        jj_consume_token(STATIC);
                       add(modifiers, new Modifier(tokenRange(), Modifier.Keyword.STATIC)); begin = orIfInvalid(begin, jpToken());
        break;
      case PROTECTED:
        jj_consume_token(PROTECTED);
                           add(modifiers, new Modifier(tokenRange(), Modifier.Keyword.PROTECTED)); begin = orIfInvalid(begin, jpToken());
        break;
      case PRIVATE:
        jj_consume_token(PRIVATE);
                        add(modifiers, new Modifier(tokenRange(), Modifier.Keyword.PRIVATE)); begin = orIfInvalid(begin, jpToken());
        break;
      case FINAL:
        jj_consume_token(FINAL);
                      add(modifiers, new Modifier(tokenRange(), Modifier.Keyword.FINAL)); begin = orIfInvalid(begin, jpToken());
        break;
      case ABSTRACT:
        jj_consume_token(ABSTRACT);
                         add(modifiers, new Modifier(tokenRange(), Modifier.Keyword.ABSTRACT)); begin = orIfInvalid(begin, jpToken());
        break;
      case SYNCHRONIZED:
        jj_consume_token(SYNCHRONIZED);
                             add(modifiers, new Modifier(tokenRange(), Modifier.Keyword.SYNCHRONIZED)); begin = orIfInvalid(begin, jpToken());
        break;
      case NATIVE:
        jj_consume_token(NATIVE);
                       add(modifiers, new Modifier(tokenRange(), Modifier.Keyword.NATIVE)); begin = orIfInvalid(begin, jpToken());
        break;
      case TRANSIENT:
        jj_consume_token(TRANSIENT);
                          add(modifiers, new Modifier(tokenRange(), Modifier.Keyword.TRANSIENT)); begin = orIfInvalid(begin, jpToken());
        break;
      case VOLATILE:
        jj_consume_token(VOLATILE);
                         add(modifiers, new Modifier(tokenRange(), Modifier.Keyword.VOLATILE)); begin = orIfInvalid(begin, jpToken());
        break;
      case STRICTFP:
        jj_consume_token(STRICTFP);
                         add(modifiers, new Modifier(tokenRange(), Modifier.Keyword.STRICTFP));  begin = orIfInvalid(begin, jpToken());
        break;
      case TRANSITIVE:
        jj_consume_token(TRANSITIVE);
                           add(modifiers, new Modifier(tokenRange(), Modifier.Keyword.TRANSITIVE));  begin = orIfInvalid(begin, jpToken());
        break;
      case _DEFAULT:
        jj_consume_token(_DEFAULT);
                        add(modifiers, new Modifier(tokenRange(), Modifier.Keyword.DEFAULT));  begin = orIfInvalid(begin, jpToken());
        break;
      case AT:
        ann = Annotation();
                                  annotations = add(annotations, ann); begin = orIfInvalid(begin, ann);
        break;
      default:
        jj_la1[6] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
        {if (true) return new ModifierHolder(begin, modifiers, annotations);}
    throw new Error("Missing return statement in function");
  }

/*
 * Declaration syntax follows.
 */

/**
 * <strong>
 *   Note that this grammar is deliberately permissive. As a result, this grammar allows any combinations of
 *   class/interface and extends/implements (e.g. an interface implementing an interface).
 * </strong>
 * Validations of these combinations are handled at the same time as validating language features used.
 * Also note that JavaParser handles the hierarchy/specialisations of classes, interfaces, and enums differently to the JLS.
 * <ul>
 *   <li>This {@code ClassOrInterfaceDeclaration} refers to the {@code NormalClassDeclaration} and {@code NormalInterfaceDeclaration},</li>
 *   <li>while {@code AnnotationTypeDeclaration} and {@code EnumDeclaration} are handled separately within this grammar.</li>
 * </ul>
 * https://docs.oracle.com/javase/specs/jls/se15/html/jls-8.html#jls-8.1
 * <pre>{@code
 *     ClassDeclaration:
 *         NormalClassDeclaration
 *         EnumDeclaration
 *     NormalClassDeclaration:
 *         {ClassModifier} class TypeIdentifier [TypeParameters] [Superclass] [Superinterfaces] ClassBody
 * }</pre>
 * https://docs.oracle.com/javase/specs/jls/se15/html/jls-9.html#jls-9.1
 * <pre>{@code
 *     InterfaceDeclaration:
 *         NormalInterfaceDeclaration
 *         AnnotationTypeDeclaration
 *     NormalInterfaceDeclaration:
 *         {InterfaceModifier} interface TypeIdentifier [TypeParameters] [ExtendsInterfaces] InterfaceBody
 * }</pre>
 */
  final public ClassOrInterfaceDeclaration ClassOrInterfaceDeclaration(ModifierHolder modifier) throws ParseException {
    boolean isInterface;
    SimpleName name;
    RangedList<TypeParameter> typePar = new RangedList<TypeParameter>(emptyNodeList());
    NodeList<ClassOrInterfaceType> extList = emptyNodeList();
    NodeList<ClassOrInterfaceType> impList = emptyNodeList();
    NodeList<BodyDeclaration<?>> members = emptyNodeList();
    JavaToken begin = modifier.begin;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case CLASS:
      jj_consume_token(CLASS);
                  isInterface = false;
      break;
    case INTERFACE:
      jj_consume_token(INTERFACE);
                      isInterface = true;
      break;
    default:
      jj_la1[7] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
        begin = orIfInvalid(begin, jpToken());
    name = SimpleName();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case LT:
      typePar = TypeParameters();
      break;
    default:
      jj_la1[8] = jj_gen;
      ;
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case EXTENDS:
      extList = ExtendsList();
      break;
    default:
      jj_la1[9] = jj_gen;
      ;
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case IMPLEMENTS:
      impList = ImplementsList();
      break;
    default:
      jj_la1[10] = jj_gen;
      ;
    }
    members = ClassOrInterfaceBody();
      {if (true) return new ClassOrInterfaceDeclaration(range(begin, jpToken()), modifier.modifiers, modifier.annotations, isInterface, name, typePar.list, extList, impList, members);}
    throw new Error("Missing return statement in function");
  }

/**
 * https://docs.oracle.com/javase/specs/jls/se15/html/jls-8.html#jls-8.1.4
 * <pre>{@code
 *     Superclass:
 *         extends ClassType
 * }</pre>
 * For convenience:
 * https://docs.oracle.com/javase/specs/jls/se15/html/jls-4.html#jls-4.3
 * <pre>{@code
 *     ClassOrInterfaceType:
 *         ClassType
 *         InterfaceType
 *     ClassType:
 *         {Annotation} TypeIdentifier [TypeArguments]
 *         PackageName . {Annotation} TypeIdentifier [TypeArguments]
 *         ClassOrInterfaceType . {Annotation} TypeIdentifier [TypeArguments]
 *     InterfaceType:
 *         ClassType
 * }</pre>
 */
  final public NodeList<ClassOrInterfaceType> ExtendsList() throws ParseException {
    boolean extendsMoreThanOne = false;
    NodeList<ClassOrInterfaceType> ret = new NodeList<ClassOrInterfaceType>();
    ClassOrInterfaceType cit;
    jj_consume_token(EXTENDS);
    cit = AnnotatedClassOrInterfaceType();
                                                      ret.add(cit);
    label_4:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case COMMA:
        ;
        break;
      default:
        jj_la1[11] = jj_gen;
        break label_4;
      }
      jj_consume_token(COMMA);
      cit = AnnotatedClassOrInterfaceType();
                                                  ret.add(cit); extendsMoreThanOne = true;
    }
      {if (true) return ret;}
    throw new Error("Missing return statement in function");
  }

/**
 * https://docs.oracle.com/javase/specs/jls/se15/html/jls-8.html#jls-8.1.5
 * <pre>{@code
 *     Superinterfaces:
 *         implements InterfaceTypeList
 *     InterfaceTypeList:
 *         InterfaceType {, InterfaceType}
 * }</pre>
 * For convenience:
 * https://docs.oracle.com/javase/specs/jls/se15/html/jls-4.html#jls-4.3
 * <pre>{@code
 *     ClassOrInterfaceType:
 *         ClassType
 *         InterfaceType
 *     ClassType:
 *         {Annotation} TypeIdentifier [TypeArguments]
 *         PackageName . {Annotation} TypeIdentifier [TypeArguments]
 *         ClassOrInterfaceType . {Annotation} TypeIdentifier [TypeArguments]
 *     InterfaceType:
 *         ClassType
 * }</pre>
 */
  final public NodeList<ClassOrInterfaceType> ImplementsList() throws ParseException {
    NodeList<ClassOrInterfaceType> ret = new NodeList<ClassOrInterfaceType>();
    ClassOrInterfaceType cit;
    jj_consume_token(IMPLEMENTS);
    cit = AnnotatedClassOrInterfaceType();
                                                         ret.add(cit);
    label_5:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case COMMA:
        ;
        break;
      default:
        jj_la1[12] = jj_gen;
        break label_5;
      }
      jj_consume_token(COMMA);
      cit = AnnotatedClassOrInterfaceType();
                                                  ret.add(cit);
    }
      {if (true) return ret;}
    throw new Error("Missing return statement in function");
  }

/**
 * https://docs.oracle.com/javase/specs/jls/se15/html/jls-8.html#jls-8.9
 * <pre>{@code
 *     EnumDeclaration:
 *         {ClassModifier} enum TypeIdentifier [Superinterfaces] EnumBody
 * }</pre>
 * https://docs.oracle.com/javase/specs/jls/se15/html/jls-8.html#jls-8.9.1
 * <pre>{@code
 *     EnumBody:
 *         { [EnumConstantList] [,] [EnumBodyDeclarations] }
 *     EnumConstantList:
 *         EnumConstant {, EnumConstant}
 *     EnumConstant:
 *         {EnumConstantModifier} Identifier [( [ArgumentList] )] [ClassBody]
 *     EnumConstantModifier:
 *         Annotation
 * }</pre>
 * https://docs.oracle.com/javase/specs/jls/se15/html/jls-8.html#jls-8.9.2
 * <pre>{@code
 *     EnumBodyDeclarations:
 *         ; {ClassBodyDeclaration}
 * }</pre>
 */
  final public EnumDeclaration EnumDeclaration(ModifierHolder modifier) throws ParseException {
    SimpleName name;
    NodeList<ClassOrInterfaceType> impList = emptyNodeList();
    EnumConstantDeclaration entry;
    NodeList<EnumConstantDeclaration> entries = emptyNodeList();
    BodyDeclaration<?> member;
    NodeList<BodyDeclaration<?>> members = emptyNodeList();
    JavaToken begin = modifier.begin;
    jj_consume_token(ENUM);
             begin = orIfInvalid(begin, jpToken());
    name = SimpleName();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case IMPLEMENTS:
      impList = ImplementsList();
      break;
    default:
      jj_la1[13] = jj_gen;
      ;
    }
    jj_consume_token(LBRACE);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case ENUM:
    case STRICTFP:
    case YIELD:
    case REQUIRES:
    case TO:
    case WITH:
    case OPEN:
    case OPENS:
    case USES:
    case MODULE:
    case EXPORTS:
    case PROVIDES:
    case TRANSITIVE:
    case IDENTIFIER:
    case AT:
      entry = EnumConstantDeclaration();
                                            entries.add(entry);
      label_6:
      while (true) {
        if (jj_2_4(2)) {
          ;
        } else {
          break label_6;
        }
        jj_consume_token(COMMA);
        entry = EnumConstantDeclaration();
                                                               entries.add(entry);
      }
      break;
    default:
      jj_la1[14] = jj_gen;
      ;
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case COMMA:
      jj_consume_token(COMMA);
      break;
    default:
      jj_la1[15] = jj_gen;
      ;
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case SEMICOLON:
      jj_consume_token(SEMICOLON);
      label_7:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case ABSTRACT:
        case BOOLEAN:
        case BYTE:
        case CHAR:
        case CLASS:
        case _DEFAULT:
        case DOUBLE:
        case ENUM:
        case FINAL:
        case FLOAT:
        case INT:
        case INTERFACE:
        case LONG:
        case NATIVE:
        case PRIVATE:
        case PROTECTED:
        case PUBLIC:
        case SHORT:
        case STATIC:
        case STRICTFP:
        case SYNCHRONIZED:
        case TRANSIENT:
        case VOID:
        case VOLATILE:
        case YIELD:
        case REQUIRES:
        case TO:
        case WITH:
        case OPEN:
        case OPENS:
        case USES:
        case MODULE:
        case EXPORTS:
        case PROVIDES:
        case TRANSITIVE:
        case IDENTIFIER:
        case LBRACE:
        case SEMICOLON:
        case AT:
        case LT:
          ;
          break;
        default:
          jj_la1[16] = jj_gen;
          break label_7;
        }
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case ABSTRACT:
        case BOOLEAN:
        case BYTE:
        case CHAR:
        case CLASS:
        case _DEFAULT:
        case DOUBLE:
        case ENUM:
        case FINAL:
        case FLOAT:
        case INT:
        case INTERFACE:
        case LONG:
        case NATIVE:
        case PRIVATE:
        case PROTECTED:
        case PUBLIC:
        case SHORT:
        case STATIC:
        case STRICTFP:
        case SYNCHRONIZED:
        case TRANSIENT:
        case VOID:
        case VOLATILE:
        case YIELD:
        case REQUIRES:
        case TO:
        case WITH:
        case OPEN:
        case OPENS:
        case USES:
        case MODULE:
        case EXPORTS:
        case PROVIDES:
        case TRANSITIVE:
        case IDENTIFIER:
        case LBRACE:
        case AT:
        case LT:
          member = ClassOrInterfaceBodyDeclaration();
                                                         members = add(members, member);
          break;
        case SEMICOLON:
          jj_consume_token(SEMICOLON);
          break;
        default:
          jj_la1[17] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
      }
      break;
    default:
      jj_la1[18] = jj_gen;
      ;
    }
    jj_consume_token(RBRACE);
      {if (true) return new EnumDeclaration(range(begin, jpToken()), modifier.modifiers, modifier.annotations, name, impList, entries, members);}
    throw new Error("Missing return statement in function");
  }

/**
 * Note that the {@code EnumConstantModifier} is defined as an {@code Annotation}.
 * https://docs.oracle.com/javase/specs/jls/se15/html/jls-8.html#jls-8.9.1
 * <pre>{@code
 *     EnumConstant:
 *         {EnumConstantModifier} Identifier [( [ArgumentList] )] [ClassBody]
 *     EnumConstantModifier:
 *         Annotation
 * }</pre>
 * https://docs.oracle.com/javase/specs/jls/se15/html/jls-8.html#jls-8.9.2
 * <pre>{@code
 *     EnumBodyDeclarations:
 *         ; {ClassBodyDeclaration}
 * }</pre>
 */
  final public EnumConstantDeclaration EnumConstantDeclaration() throws ParseException {
    NodeList<AnnotationExpr> annotations = new NodeList<AnnotationExpr>();
    AnnotationExpr ann;
    SimpleName name;
    NodeList<Expression> args = emptyNodeList();
    NodeList<BodyDeclaration<?>> classBody = emptyNodeList();
    JavaToken begin = INVALID;
    label_8:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case AT:
        ;
        break;
      default:
        jj_la1[19] = jj_gen;
        break label_8;
      }
      ann = Annotation();
                           annotations = add(annotations, ann); begin = orIfInvalid(begin, ann);
    }
    name = SimpleName();
                          begin = orIfInvalid(begin, jpToken());
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case LPAREN:
      args = Arguments();
      break;
    default:
      jj_la1[20] = jj_gen;
      ;
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case LBRACE:
      classBody = ClassOrInterfaceBody();
      break;
    default:
      jj_la1[21] = jj_gen;
      ;
    }
        {if (true) return new EnumConstantDeclaration(range(begin, jpToken()), annotations, name, args, classBody);}
    throw new Error("Missing return statement in function");
  }

/**
 * If the list inside the returned RangedList is null, there are no brackets.
 * If it is empty, there are brackets, but nothing is in them <>.
 * The normal case is that it contains TypeParameters, like <A, B, C>.
 * https://docs.oracle.com/javase/specs/jls/se15/html/jls-8.html#jls-8.1.2
 * <pre>{@code
 *     TypeParameters:
 *         < TypeParameterList >
 *     TypeParameterList:
 *         TypeParameter {, TypeParameter}
 * }</pre>
 * For Convenience:
 * https://docs.oracle.com/javase/specs/jls/se15/html/jls-4.html#jls-4.4
 * <pre>{@code
 *     TypeParameter:
 *         {TypeParameterModifier} TypeIdentifier [TypeBound]
 *     TypeParameterModifier:
 *         Annotation
 *     TypeBound:
 *         extends TypeVariable
 *         extends ClassOrInterfaceType {AdditionalBound}
 *     AdditionalBound:
 *         & InterfaceType
 * }</pre>
 */
  final public RangedList<TypeParameter> TypeParameters() throws ParseException {
    RangedList<TypeParameter> ret = new RangedList<TypeParameter>(new NodeList<TypeParameter>());
    TypeParameter tp;
    NodeList<AnnotationExpr> annotations;
    jj_consume_token(LT);
          ret.beginAt(jpToken());
    annotations = Annotations();
    tp = TypeParameter(annotations);
                                      ret.add(tp); annotations = null;
    label_9:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case COMMA:
        ;
        break;
      default:
        jj_la1[22] = jj_gen;
        break label_9;
      }
      jj_consume_token(COMMA);
      annotations = Annotations();
      tp = TypeParameter(annotations);
                                          ret.add(tp); annotations = null;
    }
    jj_consume_token(GT);
          ret.endAt(jpToken());
      {if (true) return ret;}
    throw new Error("Missing return statement in function");
  }

/**
 * Note that the {@code TypeParameterModifier} is defined as an {@code Annotation}.
 * Note that the annotations are passed as a parameter to this grammar entry.
 * https://docs.oracle.com/javase/specs/jls/se15/html/jls-4.html#jls-4.4
 * <pre>{@code
 *     TypeParameter:
 *         {TypeParameterModifier} TypeIdentifier [TypeBound]
 *     TypeParameterModifier:
 *         Annotation
 *     TypeBound:
 *         extends TypeVariable
 *         extends ClassOrInterfaceType {AdditionalBound}
 *     AdditionalBound:
 *         & InterfaceType
 * }</pre>
 */
  final public TypeParameter TypeParameter(NodeList<AnnotationExpr> annotations) throws ParseException {
    SimpleName name;
    NodeList<ClassOrInterfaceType> typeBound  = emptyNodeList();
    JavaToken begin;
    // Annotations are passed as a parameter to this grammar entry.
        name = SimpleName();
                          begin=jpToken();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case EXTENDS:
      typeBound = TypeBound();
      break;
    default:
      jj_la1[23] = jj_gen;
      ;
    }
      {if (true) return new TypeParameter(range(begin, jpToken()), name, typeBound, annotations);}
    throw new Error("Missing return statement in function");
  }

/**
 * https://docs.oracle.com/javase/specs/jls/se15/html/jls-4.html#jls-4.4
 * <pre>{@code
 *     TypeBound:
 *         extends TypeVariable
 *         extends ClassOrInterfaceType {AdditionalBound}
 *     AdditionalBound:
 *         & InterfaceType
 * }</pre>
 * For Convenience:
 * https://docs.oracle.com/javase/specs/jls/se15/html/jls-4.html#jls-4.3
 * <pre>{@code
 *     ClassOrInterfaceType:
 *         ClassType
 *         InterfaceType
 *     ClassType:
 *         {Annotation} TypeIdentifier [TypeArguments]
 *         PackageName . {Annotation} TypeIdentifier [TypeArguments]
 *         ClassOrInterfaceType . {Annotation} TypeIdentifier [TypeArguments]
 *     InterfaceType:
 *         ClassType
 *     TypeVariable:
 *         {Annotation} TypeIdentifier
 * }</pre>
 */
  final public NodeList<ClassOrInterfaceType> TypeBound() throws ParseException {
    NodeList<ClassOrInterfaceType> ret = emptyNodeList();
    ClassOrInterfaceType cit;
    jj_consume_token(EXTENDS);
    cit = AnnotatedClassOrInterfaceType();
                                                      ret.add(cit);
    label_10:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case BIT_AND:
        ;
        break;
      default:
        jj_la1[24] = jj_gen;
        break label_10;
      }
      jj_consume_token(BIT_AND);
      cit = AnnotatedClassOrInterfaceType();
                                                ret.add(cit);
    }
      {if (true) return ret;}
    throw new Error("Missing return statement in function");
  }

/**
 * https://docs.oracle.com/javase/specs/jls/se15/html/jls-8.html#jls-8.1.6
 * <pre>{@code
 *     ClassBody:
 *         { {ClassBodyDeclaration} }
 *     ClassBodyDeclaration:
 *         ClassMemberDeclaration
 *         InstanceInitializer
 *         StaticInitializer
 *         ConstructorDeclaration
 *     ClassMemberDeclaration:
 *         FieldDeclaration
 *         MethodDeclaration
 *         ClassDeclaration
 *         InterfaceDeclaration
 *         ;
 * }</pre>
 * https://docs.oracle.com/javase/specs/jls/se15/html/jls-9.html#jls-9.1.4
 * <pre>{@code
 *     InterfaceBody:
 *         { {InterfaceMemberDeclaration} }
 *     InterfaceMemberDeclaration:
 *         ConstantDeclaration
 *         InterfaceMethodDeclaration
 *         ClassDeclaration
 *         InterfaceDeclaration
 *         ;
 * }</pre>
 */
  final public NodeList<BodyDeclaration<?>> ClassOrInterfaceBody() throws ParseException {
    NodeList<BodyDeclaration<?>> ret = emptyNodeList();
    BodyDeclaration member;
    jj_consume_token(LBRACE);
    label_11:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case ABSTRACT:
      case BOOLEAN:
      case BYTE:
      case CHAR:
      case CLASS:
      case _DEFAULT:
      case DOUBLE:
      case ENUM:
      case FINAL:
      case FLOAT:
      case INT:
      case INTERFACE:
      case LONG:
      case NATIVE:
      case PRIVATE:
      case PROTECTED:
      case PUBLIC:
      case SHORT:
      case STATIC:
      case STRICTFP:
      case SYNCHRONIZED:
      case TRANSIENT:
      case VOID:
      case VOLATILE:
      case YIELD:
      case REQUIRES:
      case TO:
      case WITH:
      case OPEN:
      case OPENS:
      case USES:
      case MODULE:
      case EXPORTS:
      case PROVIDES:
      case TRANSITIVE:
      case IDENTIFIER:
      case LBRACE:
      case SEMICOLON:
      case AT:
      case LT:
        ;
        break;
      default:
        jj_la1[25] = jj_gen;
        break label_11;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case ABSTRACT:
      case BOOLEAN:
      case BYTE:
      case CHAR:
      case CLASS:
      case _DEFAULT:
      case DOUBLE:
      case ENUM:
      case FINAL:
      case FLOAT:
      case INT:
      case INTERFACE:
      case LONG:
      case NATIVE:
      case PRIVATE:
      case PROTECTED:
      case PUBLIC:
      case SHORT:
      case STATIC:
      case STRICTFP:
      case SYNCHRONIZED:
      case TRANSIENT:
      case VOID:
      case VOLATILE:
      case YIELD:
      case REQUIRES:
      case TO:
      case WITH:
      case OPEN:
      case OPENS:
      case USES:
      case MODULE:
      case EXPORTS:
      case PROVIDES:
      case TRANSITIVE:
      case IDENTIFIER:
      case LBRACE:
      case AT:
      case LT:
        member = ClassOrInterfaceBodyDeclaration();
                                                     ret.add(member);
        break;
      case SEMICOLON:
        jj_consume_token(SEMICOLON);
        break;
      default:
        jj_la1[26] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
    jj_consume_token(RBRACE);
      {if (true) return ret;}
    throw new Error("Missing return statement in function");
  }

/**
 * Note that {@code ClassDeclaration} and {@code InterfaceDeclaration} (in the JLS) include enum and annotation declarations.
 * Note that {@code InstanceInitializer} and {@code StaticInitializer} are treated as an {@code Initializer} with an
 * optional {@code static} modifier in JavaParser.
 * TODO: Investigate the {@code ClassBodyDeclaration} parts existing within an interface - is permitting this a potential problem?
 * https://docs.oracle.com/javase/specs/jls/se15/html/jls-8.html#jls-8.1.6
 * <pre>{@code
 *     ClassBody:
 *         { {ClassBodyDeclaration} }
 *     ClassBodyDeclaration:
 *         ClassMemberDeclaration
 *         InstanceInitializer
 *         StaticInitializer
 *         ConstructorDeclaration
 *     ClassMemberDeclaration:
 *         FieldDeclaration
 *         MethodDeclaration
 *         ClassDeclaration
 *         InterfaceDeclaration
 *         ;
 * }</pre>
 * https://docs.oracle.com/javase/specs/jls/se15/html/jls-9.html#jls-9.1.4
 * <pre>{@code
 *     InterfaceBody:
 *         { {InterfaceMemberDeclaration} }
 *     InterfaceMemberDeclaration:
 *         ConstantDeclaration
 *         InterfaceMethodDeclaration
 *         ClassDeclaration
 *         InterfaceDeclaration
 *         ;
 * }</pre>
 */
  final public BodyDeclaration<?> ClassOrInterfaceBodyDeclaration() throws ParseException {
    ModifierHolder modifiers;
    BodyDeclaration<?> ret;
    if (jj_2_9(2)) {
      ret = InitializerDeclaration();
    } else {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case ABSTRACT:
      case BOOLEAN:
      case BYTE:
      case CHAR:
      case CLASS:
      case _DEFAULT:
      case DOUBLE:
      case ENUM:
      case FINAL:
      case FLOAT:
      case INT:
      case INTERFACE:
      case LONG:
      case NATIVE:
      case PRIVATE:
      case PROTECTED:
      case PUBLIC:
      case SHORT:
      case STATIC:
      case STRICTFP:
      case SYNCHRONIZED:
      case TRANSIENT:
      case VOID:
      case VOLATILE:
      case YIELD:
      case REQUIRES:
      case TO:
      case WITH:
      case OPEN:
      case OPENS:
      case USES:
      case MODULE:
      case EXPORTS:
      case PROVIDES:
      case TRANSITIVE:
      case IDENTIFIER:
      case AT:
      case LT:
        // Just get all the modifiers out of the way. If you want to do
                // more checks, pass the modifiers down to the member
                modifiers = Modifiers();
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case CLASS:
        case INTERFACE:
          ret = ClassOrInterfaceDeclaration(modifiers);
          break;
        default:
          jj_la1[27] = jj_gen;
          if (jj_2_5(2147483647)) {
            ret = EnumDeclaration(modifiers);
          } else if (jj_2_6(2147483647)) {
            ret = AnnotationTypeDeclaration(modifiers);
          } else if (jj_2_7(2147483647)) {
            ret = ConstructorDeclaration(modifiers);
          } else if (jj_2_8(2147483647)) {
            ret = FieldDeclaration(modifiers);
          } else {
            switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
            case BOOLEAN:
            case BYTE:
            case CHAR:
            case DOUBLE:
            case ENUM:
            case FLOAT:
            case INT:
            case LONG:
            case SHORT:
            case STRICTFP:
            case VOID:
            case YIELD:
            case REQUIRES:
            case TO:
            case WITH:
            case OPEN:
            case OPENS:
            case USES:
            case MODULE:
            case EXPORTS:
            case PROVIDES:
            case TRANSITIVE:
            case IDENTIFIER:
            case AT:
            case LT:
              ret = MethodDeclaration(modifiers);
              break;
            default:
              jj_la1[28] = jj_gen;
              jj_consume_token(-1);
              throw new ParseException();
            }
          }
        }
        break;
      default:
        jj_la1[29] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
      {if (true) return ret;}
    throw new Error("Missing return statement in function");
  }

/**
 * https://docs.oracle.com/javase/specs/jls/se15/html/jls-8.html#jls-8.3
 * <pre>{@code
 *     FieldDeclaration:
 *         {FieldModifier} UnannType VariableDeclaratorList ;
 *     VariableDeclaratorList:
 *         VariableDeclarator {, VariableDeclarator}
 *     VariableDeclarator:
 *         VariableDeclaratorId [= VariableInitializer]
 *     VariableDeclaratorId:
 *         Identifier [Dims]
 *     VariableInitializer:
 *         Expression
 *         ArrayInitializer
 * }</pre>
 */
  final public FieldDeclaration FieldDeclaration(ModifierHolder modifier) throws ParseException {
    Type partialType;
    NodeList<VariableDeclarator> variables = new NodeList<VariableDeclarator>();
    VariableDeclarator val;
    // Modifiers are already matched in the caller
        partialType = Type(emptyNodeList());
    val = VariableDeclarator(partialType);
                                            variables.add(val);
    label_12:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case COMMA:
        ;
        break;
      default:
        jj_la1[30] = jj_gen;
        break label_12;
      }
      jj_consume_token(COMMA);
      val = VariableDeclarator(partialType);
                                                variables.add(val);
    }
    jj_consume_token(SEMICOLON);
        JavaToken begin = orIfInvalid(modifier.begin, partialType);
        {if (true) return new FieldDeclaration(range(begin, jpToken()), modifier.modifiers, modifier.annotations, variables);}
    throw new Error("Missing return statement in function");
  }

/**
 * https://docs.oracle.com/javase/specs/jls/se15/html/jls-8.html#jls-8.3
 * <pre>{@code
 *     VariableDeclarator:
 *         VariableDeclaratorId [= VariableInitializer]
 *     VariableDeclaratorId:
 *         Identifier [Dims]
 *     VariableInitializer:
 *         Expression
 *         ArrayInitializer
 * }</pre>
 */
  final public VariableDeclarator VariableDeclarator(Type partialType) throws ParseException {
    Pair<SimpleName, List<ArrayBracketPair>> id;
    Expression init = null;
    id = VariableDeclaratorId();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case ASSIGN:
      jj_consume_token(ASSIGN);
      init = VariableInitializer();
      break;
    default:
      jj_la1[31] = jj_gen;
      ;
    }
      {if (true) return new VariableDeclarator(range(id.a, jpToken()), juggleArrayType(partialType, id.b), id.a, init);}
    throw new Error("Missing return statement in function");
  }

/**
 * https://docs.oracle.com/javase/specs/jls/se15/html/jls-8.html#jls-8.3
 * <pre>{@code
 *     VariableDeclaratorId:
 *         Identifier [Dims]
 * }</pre>
 * For convenience:
 * https://docs.oracle.com/javase/specs/jls/se15/html/jls-3.html#jls-Identifier
 * <pre>{@code
 *     Identifier:
 *         IdentifierChars but not a Keyword or BooleanLiteral or NullLiteral
 *     IdentifierChars:
 *         JavaLetter {JavaLetterOrDigit}
 *     JavaLetter:
 *         any Unicode character that is a "Java letter"
 *     JavaLetterOrDigit:
 *         any Unicode character that is a "Java letter-or-digit"
 * }</pre>
 * For convenience:
 * https://docs.oracle.com/javase/specs/jls/se15/html/jls-4.html#jls-Dims
 * <pre>{@code
 *     Dims:
 *         {Annotation} [ ] {{Annotation} [ ]}
 * }</pre>
 */
  final public Pair<SimpleName, List<ArrayBracketPair>> VariableDeclaratorId() throws ParseException {
    SimpleName name;
    JavaToken begin;
    ArrayBracketPair arrayBracketPair;
    List<ArrayBracketPair> arrayBracketPairs = new ArrayList<ArrayBracketPair>(0);
    name = SimpleName();
                          begin=jpToken();
    label_13:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case LBRACKET:
      case AT:
        ;
        break;
      default:
        jj_la1[32] = jj_gen;
        break label_13;
      }
      arrayBracketPair = ArrayBracketPair(Origin.NAME);
                                                           arrayBracketPairs=add(arrayBracketPairs, arrayBracketPair);
    }
        if(storeTokens) {
            name.setTokenRange(name.getTokenRange().get().withEnd(jpToken()));
        }
        {if (true) return new Pair(name, arrayBracketPairs);}
    throw new Error("Missing return statement in function");
  }

/**
 * https://docs.oracle.com/javase/specs/jls/se15/html/jls-8.html#jls-8.3
 * <pre>{@code
 *     VariableInitializer:
 *         Expression
 *         ArrayInitializer
 * }</pre>
 */
  final public Expression VariableInitializer() throws ParseException {
    Expression ret;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case LBRACE:
      ret = ArrayInitializer();
      break;
    case BOOLEAN:
    case BYTE:
    case CHAR:
    case DOUBLE:
    case ENUM:
    case FALSE:
    case FLOAT:
    case INT:
    case LONG:
    case NEW:
    case NULL:
    case SHORT:
    case STRICTFP:
    case SUPER:
    case SWITCH:
    case THIS:
    case TRUE:
    case VOID:
    case YIELD:
    case REQUIRES:
    case TO:
    case WITH:
    case OPEN:
    case OPENS:
    case USES:
    case MODULE:
    case EXPORTS:
    case PROVIDES:
    case TRANSITIVE:
    case LONG_LITERAL:
    case INTEGER_LITERAL:
    case FLOATING_POINT_LITERAL:
    case CHARACTER_LITERAL:
    case STRING_LITERAL:
    case TEXT_BLOCK_LITERAL:
    case IDENTIFIER:
    case LPAREN:
    case AT:
    case BANG:
    case TILDE:
    case INCR:
    case DECR:
    case PLUS:
    case MINUS:
      ret = Expression();
      break;
    default:
      jj_la1[33] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
      {if (true) return ret;}
    throw new Error("Missing return statement in function");
  }

/**
 * An array initializer is written as a comma-separated list of expressions, enclosed by braces { and }.
 * A trailing comma may appear after the last expression in an array initializer and is ignored.
 * https://docs.oracle.com/javase/specs/jls/se15/html/jls-10.html#jls-10.6
 * <pre>{@code
 *     ArrayInitializer:
 *         { [VariableInitializerList] [,] }
 *     VariableInitializerList:
 *         VariableInitializer {, VariableInitializer}
 * }</pre>
 * <pre>{@code
 *     VariableInitializer:
 *         Expression
 *         ArrayInitializer
 * }</pre>
 */
  final public ArrayInitializerExpr ArrayInitializer() throws ParseException {
    NodeList<Expression> values = emptyNodeList();
    Expression val;
    JavaToken begin;
    jj_consume_token(LBRACE);
          begin=jpToken();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case BOOLEAN:
    case BYTE:
    case CHAR:
    case DOUBLE:
    case ENUM:
    case FALSE:
    case FLOAT:
    case INT:
    case LONG:
    case NEW:
    case NULL:
    case SHORT:
    case STRICTFP:
    case SUPER:
    case SWITCH:
    case THIS:
    case TRUE:
    case VOID:
    case YIELD:
    case REQUIRES:
    case TO:
    case WITH:
    case OPEN:
    case OPENS:
    case USES:
    case MODULE:
    case EXPORTS:
    case PROVIDES:
    case TRANSITIVE:
    case LONG_LITERAL:
    case INTEGER_LITERAL:
    case FLOATING_POINT_LITERAL:
    case CHARACTER_LITERAL:
    case STRING_LITERAL:
    case TEXT_BLOCK_LITERAL:
    case IDENTIFIER:
    case LPAREN:
    case LBRACE:
    case AT:
    case BANG:
    case TILDE:
    case INCR:
    case DECR:
    case PLUS:
    case MINUS:
      val = VariableInitializer();
                                      values = add(values, val);
      label_14:
      while (true) {
        if (jj_2_10(2)) {
          ;
        } else {
          break label_14;
        }
        jj_consume_token(COMMA);
        val = VariableInitializer();
                                                         values = add(values, val);
      }
      break;
    default:
      jj_la1[34] = jj_gen;
      ;
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case COMMA:
      jj_consume_token(COMMA);
      break;
    default:
      jj_la1[35] = jj_gen;
      ;
    }
    jj_consume_token(RBRACE);
        {if (true) return new ArrayInitializerExpr(range(begin, jpToken()), values);}
    throw new Error("Missing return statement in function");
  }

/**
 * https://docs.oracle.com/javase/specs/jls/se15/html/jls-8.html#jls-8.4
 * <pre>{@code
 *     MethodDeclaration:
 *         {MethodModifier} MethodHeader MethodBody
 *     MethodHeader:
 *         Result MethodDeclarator [Throws]
 *         TypeParameters {Annotation} Result MethodDeclarator [Throws]
 *     MethodDeclarator:
 *         Identifier ( [ReceiverParameter ,] [FormalParameterList] ) [Dims]
 *     ReceiverParameter:
 *         {Annotation} UnannType [Identifier .] this
 * }</pre>
 */
  final public MethodDeclaration MethodDeclaration(ModifierHolder modifier) throws ParseException {
    RangedList<TypeParameter> typeParameters = new RangedList<TypeParameter>(emptyNodeList());
    Type type;
    SimpleName name;
    Pair<NodeList<Parameter>, ReceiverParameter> parameters = new Pair<NodeList<Parameter>, ReceiverParameter>(emptyNodeList(), null);
    ArrayBracketPair arrayBracketPair;
    List<ArrayBracketPair> arrayBracketPairs = new ArrayList<ArrayBracketPair>(0);
    NodeList<ReferenceType> throws_ = emptyNodeList();
    BlockStmt body = null;
    NodeList<AnnotationExpr> annotations;
    JavaToken begin = modifier.begin;
    ReferenceType throwType;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case LT:
      typeParameters = TypeParameters();
                                          begin = orIfInvalid(begin, typeParameters.range.getBegin());
      break;
    default:
      jj_la1[36] = jj_gen;
      ;
    }
    annotations = Annotations();
                                  modifier.annotations.addAll(annotations); begin = orIfInvalid(begin, nodeListBegin(annotations));
    type = ResultType(emptyNodeList());
                                         begin = orIfInvalid(begin, type);
    name = SimpleName();
    parameters = Parameters();
    label_15:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case LBRACKET:
      case AT:
        ;
        break;
      default:
        jj_la1[37] = jj_gen;
        break label_15;
      }
      arrayBracketPair = ArrayBracketPair(Origin.NAME);
                                                         arrayBracketPairs=add(arrayBracketPairs, arrayBracketPair);
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case THROWS:
      jj_consume_token(THROWS);
      throwType = AnnotatedReferenceType();
                                               throws_ = add(throws_, throwType);
      label_16:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case COMMA:
          ;
          break;
        default:
          jj_la1[38] = jj_gen;
          break label_16;
        }
        jj_consume_token(COMMA);
        throwType = AnnotatedReferenceType();
                                                    throws_ = add(throws_, throwType);
      }
      break;
    default:
      jj_la1[39] = jj_gen;
      ;
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case LBRACE:
      body = Block();
      break;
    case SEMICOLON:
      jj_consume_token(SEMICOLON);
      break;
    default:
      jj_la1[40] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
        type = juggleArrayType(type, arrayBracketPairs);
        {if (true) return new MethodDeclaration(range(begin, jpToken()), modifier.modifiers, modifier.annotations, typeParameters.list, type, name, parameters.a, throws_, body, parameters.b);}
    throw new Error("Missing return statement in function");
  }

// TODO: JLS Has type and unannotated type, while JavaParser has type and annotated type.
  final public ReferenceType AnnotatedReferenceType() throws ParseException {
    NodeList<AnnotationExpr> annotations;
    ReferenceType type;
    annotations = Annotations();
    type = ReferenceType(annotations);
      {if (true) return type;}
    throw new Error("Missing return statement in function");
  }

// TODO: JLS Has type and unannotated type, while JavaParser has type and annotated type.
  final public Type AnnotatedType() throws ParseException {
    NodeList<AnnotationExpr> annotations;
    Type type;
    annotations = Annotations();
    type = Type(annotations);
      {if (true) return type;}
    throw new Error("Missing return statement in function");
  }

/**
 * The JLS refers to parameters as {@code FormalParameter}.
 * https://docs.oracle.com/javase/specs/jls/se15/html/jls-8.html#jls-8.4.1
 * <pre>{@code
 *     FormalParameterList:
 *         FormalParameter {, FormalParameter}
 *     FormalParameter:
 *         {VariableModifier} UnannType VariableDeclaratorId
 *         VariableArityParameter
 *     VariableArityParameter:
 *         {VariableModifier} UnannType {Annotation} ... Identifier
 *     VariableModifier:
 *         Annotation
 *         final
 * }</pre>
 * https://docs.oracle.com/javase/specs/jls/se15/html/jls-8.html#jls-8.4
 * https://docs.oracle.com/javase/specs/jls/se15/html/jls-8.html#jls-ReceiverParameter
 * <pre>{@code
 *     MethodDeclarator:
 *         Identifier ( [ReceiverParameter ,] [FormalParameterList] ) [Dims]
 *     ReceiverParameter:
 *         {Annotation} UnannType [Identifier .] this
 * }</pre>
 */
  final public Pair<NodeList<Parameter>, ReceiverParameter> Parameters() throws ParseException {
    NodeList<Parameter> ret = emptyNodeList();
    Parameter par;
    ReceiverParameter rp = null;
    jj_consume_token(LPAREN);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case ABSTRACT:
    case BOOLEAN:
    case BYTE:
    case CHAR:
    case _DEFAULT:
    case DOUBLE:
    case ENUM:
    case FINAL:
    case FLOAT:
    case INT:
    case LONG:
    case NATIVE:
    case PRIVATE:
    case PROTECTED:
    case PUBLIC:
    case SHORT:
    case STATIC:
    case STRICTFP:
    case SYNCHRONIZED:
    case TRANSIENT:
    case VOLATILE:
    case YIELD:
    case REQUIRES:
    case TO:
    case WITH:
    case OPEN:
    case OPENS:
    case USES:
    case MODULE:
    case EXPORTS:
    case PROVIDES:
    case TRANSITIVE:
    case IDENTIFIER:
    case AT:
      if (jj_2_11(2147483647)) {
        rp = ReceiverParameter();
      } else {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case ABSTRACT:
        case BOOLEAN:
        case BYTE:
        case CHAR:
        case _DEFAULT:
        case DOUBLE:
        case ENUM:
        case FINAL:
        case FLOAT:
        case INT:
        case LONG:
        case NATIVE:
        case PRIVATE:
        case PROTECTED:
        case PUBLIC:
        case SHORT:
        case STATIC:
        case STRICTFP:
        case SYNCHRONIZED:
        case TRANSIENT:
        case VOLATILE:
        case YIELD:
        case REQUIRES:
        case TO:
        case WITH:
        case OPEN:
        case OPENS:
        case USES:
        case MODULE:
        case EXPORTS:
        case PROVIDES:
        case TRANSITIVE:
        case IDENTIFIER:
        case AT:
          par = Parameter();
                                ret = add(ret, par);
          break;
        default:
          jj_la1[41] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
      }
      label_17:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case COMMA:
          ;
          break;
        default:
          jj_la1[42] = jj_gen;
          break label_17;
        }
        jj_consume_token(COMMA);
        par = Parameter();
                                  ret = add(ret, par);
      }
      break;
    default:
      jj_la1[43] = jj_gen;
      ;
    }
    jj_consume_token(RPAREN);
      {if (true) return new Pair(ret, rp);}
    throw new Error("Missing return statement in function");
  }

/**
 * Note: Similar, but not identical to, {@code FormalParameter}.
 * Note: Distinction between {@code LambdaParameters} and {@code InferredLambdaParameters} is presence of types.
 * https://docs.oracle.com/javase/specs/jls/se15/html/jls-15.html#jls-15.27.1
 * <pre>{@code
 *     LambdaParameters:
 *         ( [LambdaParameterList] )
 *         Identifier
 *     LambdaParameterList:
 *         LambdaParameter {, LambdaParameter}
 *         Identifier {, Identifier}
 *     LambdaParameter:
 *         {VariableModifier} LambdaParameterType VariableDeclaratorId
 *         VariableArityParameter
 *     LambdaParameterType:
 *         UnannType
 *         var
 * }</pre>
 * For Convenience:
 * <pre>{@code
 *     VariableArityParameter:
 *          {VariableModifier} UnannType {Annotation} ... Identifier
 *     VariableModifier:
 *         Annotation
 *         final
 *     VariableDeclaratorId:
 *         Identifier [Dims]
 *     Dims:
 *         {Annotation} [ ] {{Annotation} [ ]}
 * }</pre>
 */
  final public NodeList<Parameter> LambdaParameters() throws ParseException {
    NodeList<Parameter> ret = null;
    Parameter par;
    par = Parameter();
                        ret = add(ret, par);
    label_18:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case COMMA:
        ;
        break;
      default:
        jj_la1[44] = jj_gen;
        break label_18;
      }
      jj_consume_token(COMMA);
      par = Parameter();
                              ret = add(ret, par);
    }
      {if (true) return ret;}
    throw new Error("Missing return statement in function");
  }

/**
 * Note: Similar, but not identical to, {@code FormalParameter}.
 * Note: Distinction between {@code LambdaParameters} and {@code InferredLambdaParameters} is presence of types.
 * https://docs.oracle.com/javase/specs/jls/se15/html/jls-15.html#jls-15.27.1
 * <pre>{@code
 *     LambdaParameters:
 *         ( [LambdaParameterList] )
 *         Identifier
 *     LambdaParameterList:
 *         LambdaParameter {, LambdaParameter}
 *         Identifier {, Identifier}
 *     LambdaParameter:
 *         {VariableModifier} LambdaParameterType VariableDeclaratorId
 *         VariableArityParameter
 *     LambdaParameterType:
 *         UnannType
 *         var
 * }</pre>
 * For Convenience:
 * <pre>{@code
 *     VariableArityParameter:
 *          {VariableModifier} UnannType {Annotation} ... Identifier
 *     VariableModifier:
 *         Annotation
 *         final
 *     VariableDeclaratorId:
 *         Identifier [Dims]
 *     Dims:
 *         {Annotation} [ ] {{Annotation} [ ]}
 * }</pre>
 */
  final public NodeList<Parameter> InferredLambdaParameters() throws ParseException {
    NodeList<Parameter> ret = null;
    Pair<SimpleName, List<ArrayBracketPair>> id;
    id = VariableDeclaratorId();
                                  ret = add(ret, new Parameter(range(id.a, id.a), new NodeList<Modifier>(), emptyNodeList(), new UnknownType(), false, emptyNodeList(), id.a));
    label_19:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case COMMA:
        ;
        break;
      default:
        jj_la1[45] = jj_gen;
        break label_19;
      }
      jj_consume_token(COMMA);
      id = VariableDeclaratorId();
                                          ret = add(ret, new Parameter(range(id.a, id.a), new NodeList<Modifier>(), emptyNodeList(), new UnknownType(), false, emptyNodeList(), id.a));
    }
      {if (true) return ret;}
    throw new Error("Missing return statement in function");
  }

/**
 * https://docs.oracle.com/javase/specs/jls/se15/html/jls-8.html#jls-8.4.1
 * <pre>{@code
 *     FormalParameter:
 *         {VariableModifier} UnannType VariableDeclaratorId
 *         VariableArityParameter
 *     VariableArityParameter:
 *         {VariableModifier} UnannType {Annotation} ... Identifier
 *     VariableModifier:
 *         Annotation
 *         final
 * }</pre>
 */
  final public Parameter Parameter() throws ParseException {
    ModifierHolder modifier;
    Type partialType;
    boolean isVarArg = false;
    Pair<SimpleName, List<ArrayBracketPair>> id;
    NodeList<AnnotationExpr> varArgAnnotations = emptyNodeList();
    modifier = Modifiers();
    partialType = Type(emptyNodeList());
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case AT:
    case ELLIPSIS:
      varArgAnnotations = Annotations();
      jj_consume_token(ELLIPSIS);
                isVarArg = true;
      break;
    default:
      jj_la1[46] = jj_gen;
      ;
    }
    id = VariableDeclaratorId();
        JavaToken begin = orIfInvalid(modifier.begin, partialType);
        {if (true) return new Parameter(range(begin, jpToken()), modifier.modifiers, modifier.annotations, juggleArrayType(partialType, id.b), isVarArg, varArgAnnotations, id.a);}
    throw new Error("Missing return statement in function");
  }

/**
 * https://docs.oracle.com/javase/specs/jls/se15/html/jls-8.html#jls-8.4
 * https://docs.oracle.com/javase/specs/jls/se15/html/jls-8.html#jls-ReceiverParameter
 * <pre>{@code
 *     MethodDeclarator:
 *         Identifier ( [ReceiverParameter ,] [FormalParameterList] ) [Dims]
 *     ReceiverParameter:
 *         {Annotation} UnannType [Identifier .] this
 * }</pre>
 */
  final public ReceiverParameter ReceiverParameter() throws ParseException {
    Type partialType;
    Name id;
    NodeList<AnnotationExpr> annotations = emptyNodeList();
    annotations = Annotations();
    partialType = Type(emptyNodeList());
    id = ReceiverParameterId();
        {if (true) return new ReceiverParameter(range(partialType, jpToken()), annotations, partialType, id);}
    throw new Error("Missing return statement in function");
  }

/**
 * https://docs.oracle.com/javase/specs/jls/se15/html/jls-8.html#jls-8.4
 * https://docs.oracle.com/javase/specs/jls/se15/html/jls-8.html#jls-ReceiverParameter
 * <pre>{@code
 *     MethodDeclarator:
 *         Identifier ( [ReceiverParameter ,] [FormalParameterList] ) [Dims]
 *     ReceiverParameter:
 *         {Annotation} UnannType [Identifier .] this
 * }</pre>
 */
  final public Name ReceiverParameterId() throws ParseException {
    Name ret = null;
    if (jj_2_12(2147483647)) {
      ret = Name();
      jj_consume_token(DOT);
    } else {
      ;
    }
    jj_consume_token(THIS);
      {if (true) return new Name(tokenRange(), ret, token.image);}
    throw new Error("Missing return statement in function");
  }

/**
 * https://docs.oracle.com/javase/specs/jls/se15/html/jls-8.html#jls-8.8
 * <pre>{@code
 *     ConstructorDeclaration:
 *         {ConstructorModifier} ConstructorDeclarator [Throws] ConstructorBody
 *     ConstructorDeclarator:
 *         [TypeParameters] SimpleTypeName ( [ReceiverParameter ,] [FormalParameterList] )
 *     SimpleTypeName:
 *         TypeIdentifier
 * }</pre>
 * https://docs.oracle.com/javase/specs/jls/se15/html/jls-8.html#jls-8.8.7
 * <pre>{@code
 *     ConstructorBody:
 *         { [ExplicitConstructorInvocation] [BlockStatements] }
 * }</pre>
 * https://docs.oracle.com/javase/specs/jls/se15/html/jls-8.html#jls-8.8.7.1
 * <pre>{@code
 *     ExplicitConstructorInvocation:
 *         [TypeArguments] this ( [ArgumentList] ) ;
 *         [TypeArguments] super ( [ArgumentList] ) ;
 *         ExpressionName . [TypeArguments] super ( [ArgumentList] ) ;
 *         Primary . [TypeArguments] super ( [ArgumentList] ) ;
 * }</pre>
 */
  final public ConstructorDeclaration ConstructorDeclaration(ModifierHolder modifier) throws ParseException {
    RangedList<TypeParameter> typeParameters = new RangedList<TypeParameter>(emptyNodeList());
    SimpleName name;
    Pair<NodeList<Parameter>, ReceiverParameter> parameters = new Pair<NodeList<Parameter>, ReceiverParameter>(emptyNodeList(), null);
    NodeList<ReferenceType> throws_ = emptyNodeList();
    ExplicitConstructorInvocationStmt exConsInv = null;
    NodeList<Statement> stmts = emptyNodeList();
    JavaToken begin = modifier.begin;
    JavaToken blockBegin = INVALID;
    ReferenceType throwType;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case LT:
      typeParameters = TypeParameters();
                                          begin = orIfInvalid(begin, typeParameters.range.getBegin());
      break;
    default:
      jj_la1[47] = jj_gen;
      ;
    }
    // Modifiers matched in the caller
        name = SimpleName();
                          begin = orIfInvalid(begin, typeParameters.range.getBegin()); begin = orIfInvalid(begin, jpToken());
    parameters = Parameters();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case THROWS:
      jj_consume_token(THROWS);
      throwType = AnnotatedReferenceType();
                                               throws_ = add(throws_, throwType);
      label_20:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case COMMA:
          ;
          break;
        default:
          jj_la1[48] = jj_gen;
          break label_20;
        }
        jj_consume_token(COMMA);
        throwType = AnnotatedReferenceType();
                                                    throws_ = add(throws_, throwType);
      }
      break;
    default:
      jj_la1[49] = jj_gen;
      ;
    }
    jj_consume_token(LBRACE);
          blockBegin=jpToken();
    if (jj_2_13(2147483647)) {
      exConsInv = ExplicitConstructorInvocation();
    } else {
      ;
    }
    stmts = Statements();
    jj_consume_token(RBRACE);
        if (exConsInv != null) {
            stmts = prepend(stmts, exConsInv);
        }
        {if (true) return new ConstructorDeclaration(range(begin, jpToken()), modifier.modifiers, modifier.annotations, typeParameters.list, name, parameters.a, throws_, new BlockStmt(range(blockBegin, jpToken()), stmts), parameters.b);}
    throw new Error("Missing return statement in function");
  }

/**
 * https://docs.oracle.com/javase/specs/jls/se15/html/jls-8.html#jls-8.8.7.1
 * <pre>{@code
 *     ExplicitConstructorInvocation:
 *         [TypeArguments] this ( [ArgumentList] ) ;
 *         [TypeArguments] super ( [ArgumentList] ) ;
 *         ExpressionName . [TypeArguments] super ( [ArgumentList] ) ;
 *         Primary . [TypeArguments] super ( [ArgumentList] ) ;
 * }</pre>
 * The same, but aligned on {@code super}, to emphasise how this grammar relates:
 * <pre>{@code
 *     ExplicitConstructorInvocation:
 *         [TypeArguments] this ( [ArgumentList] ) ;
 *                          [TypeArguments] super ( [ArgumentList] ) ;
 *         ExpressionName . [TypeArguments] super ( [ArgumentList] ) ;
 *                Primary . [TypeArguments] super ( [ArgumentList] ) ;
 * }</pre>
 */
  final public ExplicitConstructorInvocationStmt ExplicitConstructorInvocation() throws ParseException {
    boolean isThis = false;
    NodeList<Expression> args;
    Expression expr = null;
    RangedList<Type> typeArgs = new RangedList<Type>(null);
    JavaToken begin = INVALID;
    if (jj_2_15(2147483647)) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case LT:
        typeArgs = TypeArguments();
                                       begin=typeArgs.range.getBegin();
        break;
      default:
        jj_la1[50] = jj_gen;
        ;
      }
      jj_consume_token(THIS);
                 begin = orIfInvalid(begin, jpToken()); isThis = true;
      args = Arguments();
      jj_consume_token(SEMICOLON);
    } else {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case BOOLEAN:
      case BYTE:
      case CHAR:
      case DOUBLE:
      case ENUM:
      case FALSE:
      case FLOAT:
      case INT:
      case LONG:
      case NEW:
      case NULL:
      case SHORT:
      case STRICTFP:
      case SUPER:
      case THIS:
      case TRUE:
      case VOID:
      case YIELD:
      case REQUIRES:
      case TO:
      case WITH:
      case OPEN:
      case OPENS:
      case USES:
      case MODULE:
      case EXPORTS:
      case PROVIDES:
      case TRANSITIVE:
      case LONG_LITERAL:
      case INTEGER_LITERAL:
      case FLOATING_POINT_LITERAL:
      case CHARACTER_LITERAL:
      case STRING_LITERAL:
      case TEXT_BLOCK_LITERAL:
      case IDENTIFIER:
      case LPAREN:
      case AT:
      case LT:
        if (jj_2_14(2147483647)) {
          expr = PrimaryExpressionWithoutSuperSuffix();
          jj_consume_token(DOT);
                                                               begin = orIfInvalid(begin, expr);
        } else {
          ;
        }
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case LT:
          typeArgs = TypeArguments();
                                         begin = orIfInvalid(begin, typeArgs.range.getBegin());
          break;
        default:
          jj_la1[51] = jj_gen;
          ;
        }
        jj_consume_token(SUPER);
                  begin = orIfInvalid(begin, jpToken());
        args = Arguments();
        jj_consume_token(SEMICOLON);
        break;
      default:
        jj_la1[52] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
      {if (true) return new ExplicitConstructorInvocationStmt(range(begin, jpToken()),typeArgs.list, isThis, expr, args);}
    throw new Error("Missing return statement in function");
  }

/**
 * https://docs.oracle.com/javase/specs/jls/se15/html/jls-14.html#jls-14.5
 * <pre>{@code
 *     Statement:
 *         StatementWithoutTrailingSubstatement
 *         LabeledStatement
 *         IfThenStatement
 *         IfThenElseStatement
 *         WhileStatement
 *         ForStatement
 *     StatementNoShortIf:
 *         StatementWithoutTrailingSubstatement
 *         LabeledStatementNoShortIf
 *         IfThenElseStatementNoShortIf
 *         WhileStatementNoShortIf
 *         ForStatementNoShortIf
 *     StatementWithoutTrailingSubstatement:
 *         Block
 *         EmptyStatement
 *         ExpressionStatement
 *         AssertStatement
 *         SwitchStatement
 *         DoStatement
 *         BreakStatement
 *         ContinueStatement
 *         ReturnStatement
 *         SynchronizedStatement
 *         ThrowStatement
 *         TryStatement
 *         YieldStatement
 * }</pre>
 */
  final public NodeList<Statement> Statements() throws ParseException {
    NodeList<Statement> ret = emptyNodeList();
    Statement stmt;
    label_21:
    while (true) {
      if (jj_2_16(2)) {
        ;
      } else {
        break label_21;
      }
      stmt = BlockStatement();
                                             ret = add(ret, stmt);
    }
      {if (true) return ret;}
    throw new Error("Missing return statement in function");
  }

/**
 * https://docs.oracle.com/javase/specs/jls/se15/html/jls-8.html#jls-8.6
 * https://docs.oracle.com/javase/specs/jls/se15/html/jls-8.html#jls-8.
 * <pre>{@code
 *     InstanceInitializer:
 *         Block
 * }</pre>
 * <pre>{@code
 *     StaticInitializer:
 *         static Block
 * }</pre>
 */
  final public InitializerDeclaration InitializerDeclaration() throws ParseException {
    BlockStmt body;
    JavaToken begin = INVALID;
    boolean isStatic = false;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case STATIC:
      jj_consume_token(STATIC);
                 isStatic = true; begin=jpToken();
      break;
    default:
      jj_la1[53] = jj_gen;
      ;
    }
    body = Block();
                    begin = orIfInvalid(begin, body);
      {if (true) return new InitializerDeclaration(range(begin, jpToken()), isStatic, body);}
    throw new Error("Missing return statement in function");
  }

/*
 * Type, name and expression syntax follows.
 */


/**
 * https://docs.oracle.com/javase/specs/jls/se15/html/jls-4.html#jls-4.1
 * <pre>{@code
 *     Type:
 *         PrimitiveType
 *         ReferenceType
 * }<pre>
 */
  final public Type Type(NodeList<AnnotationExpr> annotations) throws ParseException {
    Type ret;
    if (jj_2_17(2)) {
      ret = ReferenceType(annotations);
    } else {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case BOOLEAN:
      case BYTE:
      case CHAR:
      case DOUBLE:
      case FLOAT:
      case INT:
      case LONG:
      case SHORT:
        ret = PrimitiveType(annotations);
        break;
      default:
        jj_la1[54] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
      {if (true) return ret;}
    throw new Error("Missing return statement in function");
  }

/**
 * // TODO: JLS Has type and unannotated type, while JavaParser has type and annotated type.
 * Note that an array of primitives is considered a reference type.
 * https://docs.oracle.com/javase/specs/jls/se15/html/jls-4.html#jls-4.1
 * <pre>{@code
 *     ReferenceType:
 *         ClassOrInterfaceType
 *         TypeVariable
 *         ArrayType
 *     ClassOrInterfaceType:
 *         ClassType
 *         InterfaceType
 *     ClassType:
 *         {Annotation} TypeIdentifier [TypeArguments]
 *         PackageName . {Annotation} TypeIdentifier [TypeArguments]
 *         ClassOrInterfaceType . {Annotation} TypeIdentifier [TypeArguments]
 *     InterfaceType:
 *         ClassType
 *     TypeVariable:
 *         {Annotation} TypeIdentifier
 *     ArrayType:
 *         PrimitiveType Dims
 *         ClassOrInterfaceType Dims
 *         TypeVariable Dims
 *     Dims:
 *         {Annotation} [ ] {{Annotation} [ ]}
 * }<pre>
 */
  final public ReferenceType ReferenceType(NodeList<AnnotationExpr> annotations) throws ParseException {
    Type type;
    ArrayBracketPair arrayBracketPair;
    List<ArrayBracketPair> arrayBracketPairs = new ArrayList<ArrayBracketPair>(0);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case BOOLEAN:
    case BYTE:
    case CHAR:
    case DOUBLE:
    case FLOAT:
    case INT:
    case LONG:
    case SHORT:
      // Note that an array of primitives is considered a reference type.
              type = PrimitiveType(annotations);
      label_22:
      while (true) {
        arrayBracketPair = ArrayBracketPair(Origin.TYPE);
                                                               arrayBracketPairs=add(arrayBracketPairs, arrayBracketPair);
        if (jj_2_18(2147483647)) {
          ;
        } else {
          break label_22;
        }
      }
      break;
    case ENUM:
    case STRICTFP:
    case YIELD:
    case REQUIRES:
    case TO:
    case WITH:
    case OPEN:
    case OPENS:
    case USES:
    case MODULE:
    case EXPORTS:
    case PROVIDES:
    case TRANSITIVE:
    case IDENTIFIER:
      type = ClassOrInterfaceType(annotations);
      label_23:
      while (true) {
        if (jj_2_19(2147483647)) {
          ;
        } else {
          break label_23;
        }
        arrayBracketPair = ArrayBracketPair(Origin.TYPE);
                                                               arrayBracketPairs=add(arrayBracketPairs, arrayBracketPair);
      }
      break;
    default:
      jj_la1[55] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
      {if (true) return (ReferenceType)wrapInArrayTypes(type, arrayBracketPairs);}
    throw new Error("Missing return statement in function");
  }

/**
 * Array bracket pairs is referred to as {@code Dims} within the JLS.
 * <pre>{@code
 *     Dims:
 *         {Annotation} [ ] {{Annotation} [ ]}
 * }</pre>
 *
 */
  final public ArrayBracketPair ArrayBracketPair(Origin origin) throws ParseException {
    NodeList<AnnotationExpr> annotations;
    JavaToken begin = INVALID;
    annotations = Annotations();
    jj_consume_token(LBRACKET);
          begin = orIfInvalid(begin, jpToken());
    jj_consume_token(RBRACKET);
      {if (true) return new ArrayBracketPair(range(begin, jpToken()), origin, annotations);}
    throw new Error("Missing return statement in function");
  }

/**
 * https://docs.oracle.com/javase/specs/jls/se15/html/jls-4.html#jls-4.9
 * <blockquote>
 * An intersection type takes the form T1 & ... & Tn (n > 0), where Ti (1 â¤ i â¤ n) are types.
 * </blockquote>
 */
  final public IntersectionType IntersectionType(NodeList<AnnotationExpr> annotations) throws ParseException {
    JavaToken begin = INVALID;
    ReferenceType elementType;
    NodeList<ReferenceType> elements = emptyNodeList();
    elementType = ReferenceType(annotations);
                                               begin = orIfInvalid(begin, elementType); elements = add(elements, elementType);
    jj_consume_token(BIT_AND);
    label_24:
    while (true) {
      elementType = AnnotatedReferenceType();
                                              elements = add(elements, elementType);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case BOOLEAN:
      case BYTE:
      case CHAR:
      case DOUBLE:
      case ENUM:
      case FLOAT:
      case INT:
      case LONG:
      case SHORT:
      case STRICTFP:
      case YIELD:
      case REQUIRES:
      case TO:
      case WITH:
      case OPEN:
      case OPENS:
      case USES:
      case MODULE:
      case EXPORTS:
      case PROVIDES:
      case TRANSITIVE:
      case IDENTIFIER:
      case AT:
        ;
        break;
      default:
        jj_la1[56] = jj_gen;
        break label_24;
      }
    }
      {if (true) return new IntersectionType(range(begin, jpToken()), elements);}
    throw new Error("Missing return statement in function");
  }

// TODO: JLS Has type and unannotated type, while JavaParser has type and annotated type.
  final public ClassOrInterfaceType AnnotatedClassOrInterfaceType() throws ParseException {
    NodeList<AnnotationExpr> annotations = new NodeList<AnnotationExpr>();
    ClassOrInterfaceType cit;
    annotations = Annotations();
    cit = ClassOrInterfaceType(annotations);
      {if (true) return cit;}
    throw new Error("Missing return statement in function");
  }

// TODO: JLS Has type and unannotated type, while JavaParser has type and annotated type.
  final public ClassOrInterfaceType ClassOrInterfaceType(NodeList<AnnotationExpr> firstAnnotations) throws ParseException {
    ClassOrInterfaceType ret;
    SimpleName name;
    RangedList<Type> typeArgs = new RangedList<Type>(null);
    JavaToken begin;
    NodeList<AnnotationExpr> annotations = new NodeList<AnnotationExpr>();
    name = SimpleName();
                          begin=jpToken();
    if (jj_2_20(2)) {
      typeArgs = TypeArguments();
    } else {
      ;
    }
        ret = new ClassOrInterfaceType(range(begin, jpToken()), null, name, typeArgs.list, firstAnnotations);
        typeArgs = new RangedList<Type>(null);
    label_25:
    while (true) {
      if (jj_2_21(2)) {
        ;
      } else {
        break label_25;
      }
      jj_consume_token(DOT);
      annotations = Annotations();
      name = SimpleName();
      if (jj_2_22(2)) {
        typeArgs = TypeArguments();
      } else {
        ;
      }
            ret = new ClassOrInterfaceType(range(begin, jpToken()), ret, name, typeArgs.list, annotations);
            typeArgs = new RangedList<Type>(null);
    }
      {if (true) return ret;}
    throw new Error("Missing return statement in function");
  }

/**
 * https://docs.oracle.com/javase/specs/jls/se15/html/jls-4.html#jls-4.5.1
 * <pre>{@code
 *     TypeArguments:
 *         < TypeArgumentList >
 *     TypeArgumentList:
 *         TypeArgument {, TypeArgument}
 *     TypeArgument:
 *         ReferenceType
 *         Wildcard
 * }<pre>
 */
  final public RangedList<Type> TypeArguments() throws ParseException {
    RangedList<Type> ret = new RangedList<Type>(new NodeList<Type>());
    Type type;
    jj_consume_token(LT);
          ret.beginAt(jpToken());
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case BOOLEAN:
    case BYTE:
    case CHAR:
    case DOUBLE:
    case ENUM:
    case FLOAT:
    case INT:
    case LONG:
    case SHORT:
    case STRICTFP:
    case YIELD:
    case REQUIRES:
    case TO:
    case WITH:
    case OPEN:
    case OPENS:
    case USES:
    case MODULE:
    case EXPORTS:
    case PROVIDES:
    case TRANSITIVE:
    case IDENTIFIER:
    case AT:
    case HOOK:
      type = TypeArgument();
                                ret.add(type);
      label_26:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case COMMA:
          ;
          break;
        default:
          jj_la1[57] = jj_gen;
          break label_26;
        }
        jj_consume_token(COMMA);
        type = TypeArgument();
                                      ret.add(type);
      }
      break;
    default:
      jj_la1[58] = jj_gen;
      ;
    }
    jj_consume_token(GT);
          ret.endAt(jpToken());
      {if (true) return ret;}
    throw new Error("Missing return statement in function");
  }

/**
 * https://docs.oracle.com/javase/specs/jls/se15/html/jls-4.html#jls-4.5.1
 * <pre>{@code
 *     TypeArguments:
 *         < TypeArgumentList >
 *     TypeArgumentList:
 *         TypeArgument {, TypeArgument}
 *     TypeArgument:
 *         ReferenceType
 *         Wildcard
 * }<pre>
 */
  final public Type TypeArgument() throws ParseException {
    Type ret;
    NodeList<AnnotationExpr> annotations;
    annotations = Annotations();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case BOOLEAN:
    case BYTE:
    case CHAR:
    case DOUBLE:
    case ENUM:
    case FLOAT:
    case INT:
    case LONG:
    case SHORT:
    case STRICTFP:
    case YIELD:
    case REQUIRES:
    case TO:
    case WITH:
    case OPEN:
    case OPENS:
    case USES:
    case MODULE:
    case EXPORTS:
    case PROVIDES:
    case TRANSITIVE:
    case IDENTIFIER:
      ret = Type(annotations);
      break;
    case HOOK:
      ret = Wildcard(annotations);
      break;
    default:
      jj_la1[59] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
      {if (true) return ret;}
    throw new Error("Missing return statement in function");
  }

/**
 * https://docs.oracle.com/javase/specs/jls/se15/html/jls-4.html#jls-4.5.1
 * <pre>{@code
 *     Wildcard:
 *         {Annotation} ? [WildcardBounds]
 *     WildcardBounds:
 *         extends ReferenceType
 *         super ReferenceType
 * }<pre>
 */
  final public WildcardType Wildcard(NodeList<AnnotationExpr> firstAnnotations) throws ParseException {
    ReferenceType ext = null;
    ReferenceType sup = null;
    JavaToken begin;
    NodeList<AnnotationExpr> annotations = new NodeList<AnnotationExpr>();
    jj_consume_token(HOOK);
          begin=jpToken();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case EXTENDS:
    case SUPER:
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case EXTENDS:
        jj_consume_token(EXTENDS);
        annotations = Annotations();
        ext = ReferenceType(annotations);
        break;
      case SUPER:
        jj_consume_token(SUPER);
        annotations = Annotations();
        sup = ReferenceType(annotations);
        break;
      default:
        jj_la1[60] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      break;
    default:
      jj_la1[61] = jj_gen;
      ;
    }
      {if (true) return new WildcardType(range(begin, jpToken()), ext, sup, firstAnnotations);}
    throw new Error("Missing return statement in function");
  }

/**
 * Note that {@code char} and {@code byte} are treated as an {@code IntegralType}, which is a subtype of {@code NumericType}.
 * https://docs.oracle.com/javase/specs/jls/se15/html/jls-4.html#jls-4.2
 * <pre>{@code
 *     PrimitiveType:
 *         {Annotation} NumericType
 *         {Annotation} boolean
 *     NumericType:
 *         IntegralType
 *         FloatingPointType
 *     IntegralType:
 *         (one of)
 *         byte short int long char
 *     FloatingPointType:
 *         (one of)
 *         float double
 * }<pre>
 */
  final public PrimitiveType PrimitiveType(NodeList<AnnotationExpr> annotations) throws ParseException {
    PrimitiveType ret;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case BOOLEAN:
      jj_consume_token(BOOLEAN);
                    ret = new PrimitiveType(tokenRange(), PrimitiveType.Primitive.BOOLEAN, annotations);
      break;
    case CHAR:
      jj_consume_token(CHAR);
                 ret = new PrimitiveType(tokenRange(), PrimitiveType.Primitive.CHAR, annotations);
      break;
    case BYTE:
      jj_consume_token(BYTE);
                 ret = new PrimitiveType(tokenRange(), PrimitiveType.Primitive.BYTE, annotations);
      break;
    case SHORT:
      jj_consume_token(SHORT);
                  ret = new PrimitiveType(tokenRange(), PrimitiveType.Primitive.SHORT, annotations);
      break;
    case INT:
      jj_consume_token(INT);
                ret = new PrimitiveType(tokenRange(), PrimitiveType.Primitive.INT, annotations);
      break;
    case LONG:
      jj_consume_token(LONG);
                 ret = new PrimitiveType(tokenRange(), PrimitiveType.Primitive.LONG, annotations);
      break;
    case FLOAT:
      jj_consume_token(FLOAT);
                  ret = new PrimitiveType(tokenRange(), PrimitiveType.Primitive.FLOAT, annotations);
      break;
    case DOUBLE:
      jj_consume_token(DOUBLE);
                   ret = new PrimitiveType(tokenRange(), PrimitiveType.Primitive.DOUBLE, annotations);
      break;
    default:
      jj_la1[62] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
      {if (true) return ret;}
    throw new Error("Missing return statement in function");
  }

/**
 * https://docs.oracle.com/javase/specs/jls/se15/html/jls-8.html#jls-8.4.5
 * <pre>{@code
 *     Result:
 *         UnannType
 *         void
 * }<pre>
 */
  final public Type ResultType(NodeList<AnnotationExpr> annotations) throws ParseException {
    Type ret;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case VOID:
      jj_consume_token(VOID);
                 ret = new VoidType(tokenRange());
      break;
    case BOOLEAN:
    case BYTE:
    case CHAR:
    case DOUBLE:
    case ENUM:
    case FLOAT:
    case INT:
    case LONG:
    case SHORT:
    case STRICTFP:
    case YIELD:
    case REQUIRES:
    case TO:
    case WITH:
    case OPEN:
    case OPENS:
    case USES:
    case MODULE:
    case EXPORTS:
    case PROVIDES:
    case TRANSITIVE:
    case IDENTIFIER:
      ret = Type(annotations);
      break;
    default:
      jj_la1[63] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
      {if (true) return ret;}
    throw new Error("Missing return statement in function");
  }

/**
 * A {@code SimpleName} is just an identifier.
 * A {@code Name} can be a {@code SimpleName} or a {@code SimpleName} with qualifiers (e.g. a class or object reference).
 * Note that no disambiguation is made as to exactly what type of name it is - e.g. whether it is a package, subclass, or field. That happens within JavaParser, rather than the grammar.
 */
  final public Name Name() throws ParseException {
    Name ret;
    Identifier();
                   ret = new Name(tokenRange(), null, token.image);
    label_27:
    while (true) {
      if (jj_2_23(2)) {
        ;
      } else {
        break label_27;
      }
      jj_consume_token(DOT);
      Identifier();
          ret = new Name(range(ret, jpToken()), ret, token.image);
    }
      {if (true) return ret;}
    throw new Error("Missing return statement in function");
  }

/**
 * A {@code SimpleName} is just an identifier.
 * A {@code Name} can be a {@code SimpleName} or a {@code SimpleName} with qualifiers (e.g. a class or object reference).
 * Note that no disambiguation is made as to exactly what type of name it is - e.g. whether it is a package, subclass, or field. That happens within JavaParser, rather than the grammar.
 */
  final public SimpleName SimpleName() throws ParseException {
    SimpleName ret;
    Identifier();
                   ret = new SimpleName(tokenRange(), token.image);
      {if (true) return ret;}
    throw new Error("Missing return statement in function");
  }

/**
 * https://docs.oracle.com/javase/specs/jls/se15/html/jls-3.html#jls-3.8
 * <pre>{@code
 *     Identifier:
 *         IdentifierChars but not a Keyword or BooleanLiteral or NullLiteral
 *     IdentifierChars:
 *         JavaLetter {JavaLetterOrDigit}
 *     JavaLetter:
 *         any Unicode character that is a "Java letter"
 * }</pre>
 * For Convenience:
 * https://docs.oracle.com/javase/specs/jls/se15/html/jls-3.html#jls-3.9
 * <blockquote>
 * 51 character sequences, formed from ASCII letters, are reserved for use as keywords and cannot be used as identifiers (Â§3.8).
 * </blockquote>
 * <pre>{@code
 *     Keyword:
 *         (one of)
 *
 *         abstract   continue   for          new         switch
 *         assert     default    if           package     synchronized
 *         boolean    do         goto         private     this
 *         break      double     implements   protected   throw
 *         byte       else       import       public      throws
 *         case       enum       instanceof   return      transient
 *         catch      extends    int          short       try
 *         char       final      interface    static      void
 *         class      finally    long         strictfp    volatile
 *         const      float      native       super       while
 *         _ (underscore)
 * }</pre>
 */
  final public String Identifier() throws ParseException {
    String ret;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case MODULE:
      jj_consume_token(MODULE);
      break;
    case REQUIRES:
      jj_consume_token(REQUIRES);
      break;
    case TO:
      jj_consume_token(TO);
      break;
    case WITH:
      jj_consume_token(WITH);
      break;
    case OPEN:
      jj_consume_token(OPEN);
      break;
    case OPENS:
      jj_consume_token(OPENS);
      break;
    case USES:
      jj_consume_token(USES);
      break;
    case EXPORTS:
      jj_consume_token(EXPORTS);
      break;
    case PROVIDES:
      jj_consume_token(PROVIDES);
      break;
    case TRANSITIVE:
      jj_consume_token(TRANSITIVE);
      break;
    case ENUM:
      jj_consume_token(ENUM);
      break;
    case STRICTFP:
      jj_consume_token(STRICTFP);
      break;
    case YIELD:
      jj_consume_token(YIELD);
      break;
    case IDENTIFIER:
      jj_consume_token(IDENTIFIER);
      break;
    default:
      jj_la1[64] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
        ret = token.image; setTokenKind(IDENTIFIER);
      {if (true) return ret;}
    throw new Error("Missing return statement in function");
  }

/*
 * Expression syntax follows.
 */
  final public Expression Expression() throws ParseException {
    Expression ret;
    AssignExpr.Operator op;
    Expression value;
    Statement lambdaBody = null;
    RangedList<Type> typeArgs = new RangedList<Type>(null);
    ret = ConditionalExpression();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case ASSIGN:
    case ARROW:
    case PLUSASSIGN:
    case MINUSASSIGN:
    case STARASSIGN:
    case SLASHASSIGN:
    case ANDASSIGN:
    case ORASSIGN:
    case XORASSIGN:
    case REMASSIGN:
    case LSHIFTASSIGN:
    case RSIGNEDSHIFTASSIGN:
    case RUNSIGNEDSHIFTASSIGN:
    case DOUBLECOLON:
      if (jj_2_24(2)) {
        op = AssignmentOperator();
        value = Expression();
                                   ret = new AssignExpr(range(ret, jpToken()), ret, value, op);
      } else {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case ARROW:
          jj_consume_token(ARROW);
          lambdaBody = LambdaBody();
                if (ret instanceof CastExpr) {
                    ret = generateLambda(ret, lambdaBody);
                } else if (ret instanceof ConditionalExpr) {
                    ConditionalExpr ce = (ConditionalExpr) ret;
                    if(ce.getElseExpr() != null) {
                        ce.setElseExpr(generateLambda(ce.getElseExpr(), lambdaBody));
                    }
                } else {
                    ret = generateLambda(ret, lambdaBody);
                }
          break;
        case DOUBLECOLON:
          jj_consume_token(DOUBLECOLON);
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case LT:
            typeArgs = TypeArguments();
            break;
          default:
            jj_la1[65] = jj_gen;
            ;
          }
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case ENUM:
          case STRICTFP:
          case YIELD:
          case REQUIRES:
          case TO:
          case WITH:
          case OPEN:
          case OPENS:
          case USES:
          case MODULE:
          case EXPORTS:
          case PROVIDES:
          case TRANSITIVE:
          case IDENTIFIER:
            Identifier();
            break;
          case NEW:
            jj_consume_token(NEW);
            break;
          default:
            jj_la1[66] = jj_gen;
            jj_consume_token(-1);
            throw new ParseException();
          }
                                     ret = new MethodReferenceExpr(range(ret, jpToken()), ret, typeArgs.list, token.image);
          break;
        default:
          jj_la1[67] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
      }
      break;
    default:
      jj_la1[68] = jj_gen;
      ;
    }
      {if (true) return ret;}
    throw new Error("Missing return statement in function");
  }

/**
 * https://docs.oracle.com/javase/specs/jls/se15/html/jls-15.html#jls-15.26
 * <pre>{@code
 *     AssignmentExpression:
 *         ConditionalExpression
 *         Assignment
 *     Assignment:
 *         LeftHandSide AssignmentOperator Expression
 *     LeftHandSide:
 *         ExpressionName
 *         FieldAccess
 *         ArrayAccess
 *     AssignmentOperator:
 *         (one of)
 *         =  *=  /=  %=  +=  -=  <<=  >>=  >>>=  &=  ^=  |=
 * }<pre>
 */
  final public AssignExpr.Operator AssignmentOperator() throws ParseException {
    AssignExpr.Operator ret;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case ASSIGN:
      jj_consume_token(ASSIGN);
                 ret = AssignExpr.Operator.ASSIGN;
      break;
    case STARASSIGN:
      jj_consume_token(STARASSIGN);
                 ret = AssignExpr.Operator.MULTIPLY;
      break;
    case SLASHASSIGN:
      jj_consume_token(SLASHASSIGN);
                 ret = AssignExpr.Operator.DIVIDE;
      break;
    case REMASSIGN:
      jj_consume_token(REMASSIGN);
                 ret = AssignExpr.Operator.REMAINDER;
      break;
    case PLUSASSIGN:
      jj_consume_token(PLUSASSIGN);
                 ret = AssignExpr.Operator.PLUS;
      break;
    case MINUSASSIGN:
      jj_consume_token(MINUSASSIGN);
                 ret = AssignExpr.Operator.MINUS;
      break;
    case LSHIFTASSIGN:
      jj_consume_token(LSHIFTASSIGN);
                 ret = AssignExpr.Operator.LEFT_SHIFT;
      break;
    case RSIGNEDSHIFTASSIGN:
      jj_consume_token(RSIGNEDSHIFTASSIGN);
                 ret = AssignExpr.Operator.SIGNED_RIGHT_SHIFT;
      break;
    case RUNSIGNEDSHIFTASSIGN:
      jj_consume_token(RUNSIGNEDSHIFTASSIGN);
                 ret = AssignExpr.Operator.UNSIGNED_RIGHT_SHIFT;
      break;
    case ANDASSIGN:
      jj_consume_token(ANDASSIGN);
                 ret = AssignExpr.Operator.BINARY_AND;
      break;
    case XORASSIGN:
      jj_consume_token(XORASSIGN);
                 ret = AssignExpr.Operator.XOR;
      break;
    case ORASSIGN:
      jj_consume_token(ORASSIGN);
                 ret = AssignExpr.Operator.BINARY_OR;
      break;
    default:
      jj_la1[69] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
      {if (true) return ret;}
    throw new Error("Missing return statement in function");
  }

/**
 * // TODO: Examine further re: missing(?) {@code LambdaExpression} or whether it is permissive enough to include it.
 * https://docs.oracle.com/javase/specs/jls/se15/html/jls-15.html#jls-15.25
 * <pre>{@code
 *     ConditionalExpression:
 *         ConditionalOrExpression
 *         ConditionalOrExpression ? Expression : ConditionalExpression
 *         ConditionalOrExpression ? Expression : LambdaExpression
 * }<pre>
 */
  final public Expression ConditionalExpression() throws ParseException {
    Expression ret;
    Expression left;
    Expression right;
    ret = ConditionalOrExpression();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case HOOK:
      jj_consume_token(HOOK);
      left = Expression();
      jj_consume_token(COLON);
      right = ConditionalExpression();
            ret = new ConditionalExpr(range(ret, jpToken()), ret, left, right);
      break;
    default:
      jj_la1[70] = jj_gen;
      ;
    }
      {if (true) return ret;}
    throw new Error("Missing return statement in function");
  }

/**
 * <strong>
 * Note subtle distinctions between inclusive and exclusive expressions.
 * </strong>
 * // TODO/FIXME: Investigate --  The JLS specifies {@code AND}, or {@code OR || AND}, but the grammar below is {@code AND || AND}
 * https://docs.oracle.com/javase/specs/jls/se15/html/jls-15.html#jls-15.24
 * <pre>{@code
 *     ConditionalOrExpression:
 *         ConditionalAndExpression
 *         ConditionalOrExpression || ConditionalAndExpression
 * }<pre>
 */
  final public Expression ConditionalOrExpression() throws ParseException {
    Expression ret;
    Expression right;
    // TODO/FIXME: Investigate --  The JLS specifies {@code AND}, or {@code OR || AND}, but the grammar below is {@code AND || AND}
        ret = ConditionalAndExpression();
    label_28:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case SC_OR:
        ;
        break;
      default:
        jj_la1[71] = jj_gen;
        break label_28;
      }
      jj_consume_token(SC_OR);
      right = ConditionalAndExpression();
                                             ret = new BinaryExpr(range(ret, jpToken()), ret, right, BinaryExpr.Operator.OR);
    }
      {if (true) return ret;}
    throw new Error("Missing return statement in function");
  }

/**
 * <strong>
 * Note subtle distinctions between inclusive and exclusive expressions.
 * </strong>
 * // TODO/FIXME: Investigate --  The JLS specifies {@code OR}, or {@code AND && OR}, but the grammar below is {@code OR && OR}
 * https://docs.oracle.com/javase/specs/jls/se15/html/jls-15.html#jls-15.23
 * <pre>{@code
 *     ConditionalAndExpression:
 *         InclusiveOrExpression
 *         ConditionalAndExpression && InclusiveOrExpression
 * }<pre>
 * For Convenience:
 * <pre>{@code
 *     AndExpression:
 *         EqualityExpression
 *         AndExpression & EqualityExpression
 *     ExclusiveOrExpression:
 *         AndExpression
 *         ExclusiveOrExpression ^ AndExpression
 *     InclusiveOrExpression:
 *         ExclusiveOrExpression
 *         InclusiveOrExpression | ExclusiveOrExpression
 * }<pre>
 */
  final public Expression ConditionalAndExpression() throws ParseException {
    Expression ret;
    Expression right;
    // TODO/FIXME: Investigate --  The JLS specifies {@code OR}, or {@code AND && OR}, but the grammar below is {@code OR && OR}
        ret = InclusiveOrExpression();
    label_29:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case SC_AND:
        ;
        break;
      default:
        jj_la1[72] = jj_gen;
        break label_29;
      }
      jj_consume_token(SC_AND);
      right = InclusiveOrExpression();
                                          ret = new BinaryExpr(range(ret, jpToken()), ret, right, BinaryExpr.Operator.AND);
    }
      {if (true) return ret;}
    throw new Error("Missing return statement in function");
  }

/**
 * <strong>
 * Note subtle distinctions between inclusive and exclusive expressions.
 * </strong>
 * https://docs.oracle.com/javase/specs/jls/se15/html/jls-15.html#jls-15.22
 * https://docs.oracle.com/javase/specs/jls/se15/html/jls-15.html#jls-InclusiveOrExpression
 * <pre>{@code
 *     AndExpression:
 *         EqualityExpression
 *         AndExpression & EqualityExpression
 *     ExclusiveOrExpression:
 *         AndExpression
 *         ExclusiveOrExpression ^ AndExpression
 *     InclusiveOrExpression:
 *         ExclusiveOrExpression
 *         InclusiveOrExpression | ExclusiveOrExpression
 * }<pre>
 */
  final public Expression InclusiveOrExpression() throws ParseException {
    Expression ret;
    Expression right;
    ret = ExclusiveOrExpression();
    label_30:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case BIT_OR:
        ;
        break;
      default:
        jj_la1[73] = jj_gen;
        break label_30;
      }
      jj_consume_token(BIT_OR);
      right = ExclusiveOrExpression();
                                          ret = new BinaryExpr(range(ret, jpToken()), ret, right, BinaryExpr.Operator.BINARY_OR);
    }
      {if (true) return ret;}
    throw new Error("Missing return statement in function");
  }

/**
 * <strong>
 * Note subtle distinctions between inclusive and exclusive expressions.
 * </strong>
 * https://docs.oracle.com/javase/specs/jls/se15/html/jls-15.html#jls-15.22
 * https://docs.oracle.com/javase/specs/jls/se15/html/jls-15.html#jls-ExclusiveOrExpression
 * <pre>{@code
 *     AndExpression:
 *         EqualityExpression
 *         AndExpression & EqualityExpression
 *     ExclusiveOrExpression:
 *         AndExpression
 *         ExclusiveOrExpression ^ AndExpression
 *     InclusiveOrExpression:
 *         ExclusiveOrExpression
 *         InclusiveOrExpression | ExclusiveOrExpression
 * }<pre>
 */
  final public Expression ExclusiveOrExpression() throws ParseException {
    Expression ret;
    Expression right;
    ret = AndExpression();
    label_31:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case XOR:
        ;
        break;
      default:
        jj_la1[74] = jj_gen;
        break label_31;
      }
      jj_consume_token(XOR);
      right = AndExpression();
                                  ret = new BinaryExpr(range(ret, jpToken()), ret, right, BinaryExpr.Operator.XOR);
    }
      {if (true) return ret;}
    throw new Error("Missing return statement in function");
  }

/**
 * <strong>
 * Note subtle distinctions between inclusive and exclusive expressions.
 * </strong>
 * https://docs.oracle.com/javase/specs/jls/se15/html/jls-15.html#jls-15.22
 * https://docs.oracle.com/javase/specs/jls/se15/html/jls-15.html#jls-AndExpression
 * <pre>{@code
 *     AndExpression:
 *         EqualityExpression
 *         AndExpression & EqualityExpression
 *     ExclusiveOrExpression:
 *         AndExpression
 *         ExclusiveOrExpression ^ AndExpression
 *     InclusiveOrExpression:
 *         ExclusiveOrExpression
 *         InclusiveOrExpression | ExclusiveOrExpression
 * }<pre>
 */
  final public Expression AndExpression() throws ParseException {
    Expression ret;
    Expression right;
    ret = EqualityExpression();
    label_32:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case BIT_AND:
        ;
        break;
      default:
        jj_la1[75] = jj_gen;
        break label_32;
      }
      jj_consume_token(BIT_AND);
      right = EqualityExpression();
                                       ret = new BinaryExpr(range(ret, jpToken()), ret, right, BinaryExpr.Operator.BINARY_AND);
    }
      {if (true) return ret;}
    throw new Error("Missing return statement in function");
  }

/**
 * // Note that instanceof is a {@code RelationalExpression} within the JLS, which differs from JavaParser
 * https://docs.oracle.com/javase/specs/jls/se15/html/jls-15.html#jls-15.21
 * <pre>{@code
 *     EqualityExpression:
 *         RelationalExpression
 *         EqualityExpression == RelationalExpression
 *         EqualityExpression != RelationalExpression
 * }<pre>
 * For Convenience:
 * https://docs.oracle.com/javase/specs/jls/se15/html/jls-15.html#jls-15.20
 * <pre>{@code
 *     RelationalExpression:
 *         ShiftExpression
 *         RelationalExpression < ShiftExpression
 *         RelationalExpression > ShiftExpression
 *         RelationalExpression <= ShiftExpression
 *         RelationalExpression >= ShiftExpression
 *         RelationalExpression instanceof ReferenceType
 * }<pre>
 */
  final public Expression EqualityExpression() throws ParseException {
    Expression ret;
    Expression right;
    BinaryExpr.Operator op;
    // Note that instanceof is a {@code RelationalExpression} within the JLS, which differs from JavaParser
        ret = InstanceOfExpression();
    label_33:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case EQ:
      case NE:
        ;
        break;
      default:
        jj_la1[76] = jj_gen;
        break label_33;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case EQ:
        jj_consume_token(EQ);
                   op = BinaryExpr.Operator.EQUALS;
        break;
      case NE:
        jj_consume_token(NE);
                   op = BinaryExpr.Operator.NOT_EQUALS;
        break;
      default:
        jj_la1[77] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      right = InstanceOfExpression();
                                         ret = new BinaryExpr(range(ret, jpToken()), ret, right, op);
    }
      {if (true) return ret;}
    throw new Error("Missing return statement in function");
  }

/**
 * // Note that instanceof is a {@code RelationalExpression} within the JLS, which differs from JavaParser
 * https://docs.oracle.com/javase/specs/jls/se15/html/jls-15.html#jls-15.20
 * <pre>{@code
 *     RelationalExpression:
 *         ShiftExpression
 *         RelationalExpression < ShiftExpression
 *         RelationalExpression > ShiftExpression
 *         RelationalExpression <= ShiftExpression
 *         RelationalExpression >= ShiftExpression
 *         RelationalExpression instanceof ReferenceType
 * }<pre>
 */
  final public Expression InstanceOfExpression() throws ParseException {
    Expression ret;
    ReferenceType type;
    NodeList<AnnotationExpr> annotations;
    ret = RelationalExpression();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case INSTANCEOF:
      jj_consume_token(INSTANCEOF);
      type = AnnotatedReferenceType();
        ret = new InstanceOfExpr(range(ret, jpToken()), ret, type);
      break;
    default:
      jj_la1[78] = jj_gen;
      ;
    }
      {if (true) return ret;}
    throw new Error("Missing return statement in function");
  }

/**
 * // Note that instanceof is a {@code RelationalExpression} within the JLS, which differs from JavaParser
 * https://docs.oracle.com/javase/specs/jls/se15/html/jls-15.html#jls-15.20
 * <pre>{@code
 *     RelationalExpression:
 *         ShiftExpression
 *         RelationalExpression < ShiftExpression
 *         RelationalExpression > ShiftExpression
 *         RelationalExpression <= ShiftExpression
 *         RelationalExpression >= ShiftExpression
 *         RelationalExpression instanceof ReferenceType
 * }<pre>
 */
  final public Expression RelationalExpression() throws ParseException {
    Expression ret;
    Expression right;
    BinaryExpr.Operator op;
    ret = ShiftExpression();
    label_34:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case LT:
      case GE:
      case LE:
      case GT:
        ;
        break;
      default:
        jj_la1[79] = jj_gen;
        break label_34;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case LT:
        jj_consume_token(LT);
                   op = BinaryExpr.Operator.LESS;
        break;
      case GT:
        jj_consume_token(GT);
                   op = BinaryExpr.Operator.GREATER;
        break;
      case LE:
        jj_consume_token(LE);
                   op = BinaryExpr.Operator.LESS_EQUALS;
        break;
      case GE:
        jj_consume_token(GE);
                   op = BinaryExpr.Operator.GREATER_EQUALS;
        break;
      default:
        jj_la1[80] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      right = ShiftExpression();
            ret = new BinaryExpr(range(ret, jpToken()), ret, right, op);
    }
      {if (true) return ret;}
    throw new Error("Missing return statement in function");
  }

/**
 * https://docs.oracle.com/javase/specs/jls/se15/html/jls-15.html#jls-15.19
 * <pre>{@code
 *     ShiftExpression:
 *         AdditiveExpression
 *         ShiftExpression << AdditiveExpression
 *         ShiftExpression >> AdditiveExpression
 *         ShiftExpression >>> AdditiveExpression
 * }<pre>
 */
  final public Expression ShiftExpression() throws ParseException {
    Expression ret;
    Expression right;
    BinaryExpr.Operator op;
    ret = AdditiveExpression();
    label_35:
    while (true) {
      if (jj_2_25(1)) {
        ;
      } else {
        break label_35;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case LSHIFT:
        jj_consume_token(LSHIFT);
                               op = BinaryExpr.Operator.LEFT_SHIFT;
        break;
      default:
        jj_la1[81] = jj_gen;
        if (jj_2_26(1)) {
          RSIGNEDSHIFT();
                               op = BinaryExpr.Operator.SIGNED_RIGHT_SHIFT;
        } else if (jj_2_27(1)) {
          RUNSIGNEDSHIFT();
                               op = BinaryExpr.Operator.UNSIGNED_RIGHT_SHIFT;
        } else {
          jj_consume_token(-1);
          throw new ParseException();
        }
      }
      right = AdditiveExpression();
                                       ret = new BinaryExpr(range(ret, jpToken()), ret, right, op);
    }
      {if (true) return ret;}
    throw new Error("Missing return statement in function");
  }

/**
 * https://docs.oracle.com/javase/specs/jls/se15/html/jls-15.html#jls-15.18
 * <pre>{@code
 *     AdditiveExpression:
 *         MultiplicativeExpression
 *         AdditiveExpression + MultiplicativeExpression
 *         AdditiveExpression - MultiplicativeExpression
 * }<pre>
 */
  final public Expression AdditiveExpression() throws ParseException {
    Expression ret;
    Expression right;
    BinaryExpr.Operator op;
    ret = MultiplicativeExpression();
    label_36:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case PLUS:
      case MINUS:
        ;
        break;
      default:
        jj_la1[82] = jj_gen;
        break label_36;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case PLUS:
        jj_consume_token(PLUS);
                  op = BinaryExpr.Operator.PLUS;
        break;
      case MINUS:
        jj_consume_token(MINUS);
                  op = BinaryExpr.Operator.MINUS;
        break;
      default:
        jj_la1[83] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      right = MultiplicativeExpression();
                                             ret = new BinaryExpr(range(ret, jpToken()), ret, right, op);
    }
      {if (true) return ret;}
    throw new Error("Missing return statement in function");
  }

/**
 * https://docs.oracle.com/javase/specs/jls/se15/html/jls-15.html#jls-15.17
 * <pre>{@code
 *     MultiplicativeExpression:
 *         UnaryExpression
 *         MultiplicativeExpression * UnaryExpression
 *         MultiplicativeExpression / UnaryExpression
 *         MultiplicativeExpression % UnaryExpression
 * }<pre>
 */
  final public Expression MultiplicativeExpression() throws ParseException {
    Expression ret;
    Expression right;
    BinaryExpr.Operator op;
    ret = UnaryExpression();
    label_37:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case STAR:
      case SLASH:
      case REM:
        ;
        break;
      default:
        jj_la1[84] = jj_gen;
        break label_37;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case STAR:
        jj_consume_token(STAR);
                  op = BinaryExpr.Operator.MULTIPLY;
        break;
      case SLASH:
        jj_consume_token(SLASH);
                  op = BinaryExpr.Operator.DIVIDE;
        break;
      case REM:
        jj_consume_token(REM);
                  op = BinaryExpr.Operator.REMAINDER;
        break;
      default:
        jj_la1[85] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      right = UnaryExpression();
                                    ret = new BinaryExpr(range(ret, jpToken()), ret, right, op);
    }
      {if (true) return ret;}
    throw new Error("Missing return statement in function");
  }

/**
 * https://docs.oracle.com/javase/specs/jls/se15/html/jls-15.html#jls-15.15
 * <pre>{@code
 *     UnaryExpression:
 *         PreIncrementExpression
 *         PreDecrementExpression
 *         + UnaryExpression
 *         - UnaryExpression
 *         UnaryExpressionNotPlusMinus
 *     PreIncrementExpression:
 *         ++ UnaryExpression
 *     PreDecrementExpression:
 *         -- UnaryExpression
 *     UnaryExpressionNotPlusMinus:
 *         PostfixExpression
 *         ~ UnaryExpression
 *         ! UnaryExpression
 *         CastExpression
 *         SwitchExpression
 * }<pre>
 */
  final public Expression UnaryExpression() throws ParseException {
    Expression ret;
    UnaryExpr.Operator op;
    JavaToken begin = INVALID;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case INCR:
      ret = PreIncrementExpression();
      break;
    case DECR:
      ret = PreDecrementExpression();
      break;
    case PLUS:
    case MINUS:
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case PLUS:
        jj_consume_token(PLUS);
                  op = UnaryExpr.Operator.PLUS; begin=jpToken();
        break;
      case MINUS:
        jj_consume_token(MINUS);
                  op = UnaryExpr.Operator.MINUS; begin=jpToken();
        break;
      default:
        jj_la1[86] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      ret = UnaryExpression();
                                 ret = new UnaryExpr(range(begin, jpToken()), ret, op);
      break;
    case BOOLEAN:
    case BYTE:
    case CHAR:
    case DOUBLE:
    case ENUM:
    case FALSE:
    case FLOAT:
    case INT:
    case LONG:
    case NEW:
    case NULL:
    case SHORT:
    case STRICTFP:
    case SUPER:
    case SWITCH:
    case THIS:
    case TRUE:
    case VOID:
    case YIELD:
    case REQUIRES:
    case TO:
    case WITH:
    case OPEN:
    case OPENS:
    case USES:
    case MODULE:
    case EXPORTS:
    case PROVIDES:
    case TRANSITIVE:
    case LONG_LITERAL:
    case INTEGER_LITERAL:
    case FLOATING_POINT_LITERAL:
    case CHARACTER_LITERAL:
    case STRING_LITERAL:
    case TEXT_BLOCK_LITERAL:
    case IDENTIFIER:
    case LPAREN:
    case AT:
    case BANG:
    case TILDE:
      ret = UnaryExpressionNotPlusMinus();
      break;
    default:
      jj_la1[87] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
      {if (true) return ret;}
    throw new Error("Missing return statement in function");
  }

/**
 * https://docs.oracle.com/javase/specs/jls/se15/html/jls-15.html#jls-15.15
 * <pre>{@code
 *     PreIncrementExpression:
 *         ++ UnaryExpression
 * }<pre>
 */
  final public Expression PreIncrementExpression() throws ParseException {
    Expression ret;
    JavaToken begin = INVALID;
    jj_consume_token(INCR);
           begin=jpToken();
    ret = UnaryExpression();
                              ret = new UnaryExpr(range(begin, jpToken()), ret, UnaryExpr.Operator.PREFIX_INCREMENT);
      {if (true) return ret;}
    throw new Error("Missing return statement in function");
  }

/**
 * https://docs.oracle.com/javase/specs/jls/se15/html/jls-15.html#jls-15.15
 * <pre>{@code
 *     PreDecrementExpression:
 *         -- UnaryExpression
 * }<pre>
 */
  final public Expression PreDecrementExpression() throws ParseException {
    Expression ret;
    JavaToken begin;
    jj_consume_token(DECR);
           begin=jpToken();
    ret = UnaryExpression();
                              ret = new UnaryExpr(range(begin, jpToken()), ret, UnaryExpr.Operator.PREFIX_DECREMENT);
      {if (true) return ret;}
    throw new Error("Missing return statement in function");
  }

/**
 * https://docs.oracle.com/javase/specs/jls/se15/html/jls-15.html#jls-15.15
 * <pre>{@code
 *     UnaryExpressionNotPlusMinus:
 *         PostfixExpression
 *         ~ UnaryExpression
 *         ! UnaryExpression
 *         CastExpression
 *         SwitchExpression
 * }<pre>
 */
  final public Expression UnaryExpressionNotPlusMinus() throws ParseException {
    Expression ret;
    UnaryExpr.Operator op;
    JavaToken begin = INVALID;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case BANG:
    case TILDE:
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case TILDE:
        jj_consume_token(TILDE);
                  op = UnaryExpr.Operator.BITWISE_COMPLEMENT; begin=jpToken();
        break;
      case BANG:
        jj_consume_token(BANG);
                  op = UnaryExpr.Operator.LOGICAL_COMPLEMENT; begin=jpToken();
        break;
      default:
        jj_la1[88] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      ret = UnaryExpression();
                                  ret = new UnaryExpr(range(begin, jpToken()), ret, op);
      break;
    default:
      jj_la1[89] = jj_gen;
      if (jj_2_28(2147483647)) {
        ret = CastExpression();
      } else {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case BOOLEAN:
        case BYTE:
        case CHAR:
        case DOUBLE:
        case ENUM:
        case FALSE:
        case FLOAT:
        case INT:
        case LONG:
        case NEW:
        case NULL:
        case SHORT:
        case STRICTFP:
        case SUPER:
        case THIS:
        case TRUE:
        case VOID:
        case YIELD:
        case REQUIRES:
        case TO:
        case WITH:
        case OPEN:
        case OPENS:
        case USES:
        case MODULE:
        case EXPORTS:
        case PROVIDES:
        case TRANSITIVE:
        case LONG_LITERAL:
        case INTEGER_LITERAL:
        case FLOATING_POINT_LITERAL:
        case CHARACTER_LITERAL:
        case STRING_LITERAL:
        case TEXT_BLOCK_LITERAL:
        case IDENTIFIER:
        case LPAREN:
        case AT:
          ret = PostfixExpression();
          break;
        case SWITCH:
          ret = SwitchExpression();
          break;
        default:
          jj_la1[90] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
      }
    }
      {if (true) return ret;}
    throw new Error("Missing return statement in function");
  }

/**
 * https://docs.oracle.com/javase/specs/jls/se15/html/jls-15.html#jls-15.15
 * <pre>{@code
 *     PostfixExpression:
 *         Primary
 *         ExpressionName
 *         PostIncrementExpression
 *         PostDecrementExpression
 * }<pre>
 */
  final public Expression PostfixExpression() throws ParseException {
    Expression ret;
    UnaryExpr.Operator op;
    ret = PrimaryExpression();
    if (jj_2_29(2)) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case INCR:
        jj_consume_token(INCR);
                   op = UnaryExpr.Operator.POSTFIX_INCREMENT;
        break;
      case DECR:
        jj_consume_token(DECR);
                   op = UnaryExpr.Operator.POSTFIX_DECREMENT;
        break;
      default:
        jj_la1[91] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
          ret = new UnaryExpr(range(ret, jpToken()), ret, op);
    } else {
      ;
    }
      {if (true) return ret;}
    throw new Error("Missing return statement in function");
  }

/**
 * https://docs.oracle.com/javase/specs/jls/se15/html/jls-15.html#jls-15.16
 * <pre>{@code
 *     CastExpression:
 *         ( PrimitiveType ) UnaryExpression
 *         ( ReferenceType {AdditionalBound} ) UnaryExpressionNotPlusMinus
 *         ( ReferenceType {AdditionalBound} ) LambdaExpression
 * }<pre>
 * For Convenience:
 * <pre>{@code
 *     AdditionalBound:
 *         & InterfaceType
 * }<pre>
 */
  final public Expression CastExpression() throws ParseException {
    Expression ret;
    ReferenceType referenceType;
    PrimitiveType primitiveType;
    JavaToken begin = INVALID;
    NodeList<AnnotationExpr> annotations;
    NodeList<ReferenceType> typesOfMultiCast = emptyNodeList();
    jj_consume_token(LPAREN);
          begin=jpToken();
    annotations = Annotations();
    if (jj_2_30(2)) {
      primitiveType = PrimitiveType(annotations);
      jj_consume_token(RPAREN);
      ret = UnaryExpression();
          ret = new CastExpr(range(begin, jpToken()), primitiveType, ret);
    } else {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case BOOLEAN:
      case BYTE:
      case CHAR:
      case DOUBLE:
      case ENUM:
      case FLOAT:
      case INT:
      case LONG:
      case SHORT:
      case STRICTFP:
      case YIELD:
      case REQUIRES:
      case TO:
      case WITH:
      case OPEN:
      case OPENS:
      case USES:
      case MODULE:
      case EXPORTS:
      case PROVIDES:
      case TRANSITIVE:
      case IDENTIFIER:
        // ( ReferenceType {AdditionalBound} ) UnaryExpressionNotPlusMinus
                // ( ReferenceType {AdditionalBound} ) LambdaExpression
                referenceType = ReferenceType(annotations);
                                                     typesOfMultiCast = add(typesOfMultiCast, referenceType);
        label_38:
        while (true) {
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case BIT_AND:
            ;
            break;
          default:
            jj_la1[92] = jj_gen;
            break label_38;
          }
          jj_consume_token(BIT_AND);
          referenceType = AnnotatedReferenceType();
                                                       typesOfMultiCast = add(typesOfMultiCast, referenceType);
        }
        jj_consume_token(RPAREN);
        ret = UnaryExpressionNotPlusMinus();
            if (typesOfMultiCast.size() > 1) {
                ret = new CastExpr(range(begin, jpToken()), new IntersectionType(range(typesOfMultiCast.get(0), typesOfMultiCast.get(typesOfMultiCast.size() -1)), typesOfMultiCast), ret);
            } else {
                ret = new CastExpr(range(begin, jpToken()), referenceType, ret);
            }
        break;
      default:
        jj_la1[93] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
      {if (true) return ret;}
    throw new Error("Missing return statement in function");
  }

/**
 * https://docs.oracle.com/javase/specs/jls/se15/html/jls-15.html#jls-15.8
 * <pre>{@code
 *     Primary:
 *         PrimaryNoNewArray
 *         ArrayCreationExpression
 *     PrimaryNoNewArray:
 *         Literal
 *         ClassLiteral
 *         this
 *         TypeName . this
 *         ( Expression )
 *         ClassInstanceCreationExpression
 *         FieldAccess
 *         ArrayAccess
 *         MethodInvocation
 *         MethodReference
 * }<pre>
 */
  final public Expression PrimaryExpression() throws ParseException {
    Expression ret;
    ret = PrimaryPrefix();
    label_39:
    while (true) {
      if (jj_2_31(2)) {
        ;
      } else {
        break label_39;
      }
      ret = PrimarySuffix(ret);
    }
      {if (true) return ret;}
    throw new Error("Missing return statement in function");
  }

/**
 * // TODO: Unclear exactly which part of the JLS this relates to - a JavaParser-specific thing with no 1:1 mapping, perhaps?
 */
  final public Expression PrimaryExpressionWithoutSuperSuffix() throws ParseException {
    Expression ret;
    ret = PrimaryPrefix();
    label_40:
    while (true) {
      if (jj_2_32(2147483647)) {
        ;
      } else {
        break label_40;
      }
      ret = PrimarySuffixWithoutSuper(ret);
    }
      {if (true) return ret;}
    throw new Error("Missing return statement in function");
  }

/**
 * // TODO: Unclear exactly which part of the JLS this relates to - a JavaParser-specific thing with no 1:1 mapping, perhaps?
 */
  final public Expression PrimaryPrefix() throws ParseException {
    Expression ret = null;
    SimpleName name;
    RangedList<Type> typeArgs = new RangedList<Type>(null);
    NodeList<Expression> args = emptyNodeList();
    NodeList<Parameter> params = emptyNodeList();
    boolean hasArgs = false;
    boolean isLambda = false;
    Type type;
    JavaToken begin;
    Parameter p = null;
    SimpleName id = null;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case FALSE:
    case NULL:
    case TRUE:
    case LONG_LITERAL:
    case INTEGER_LITERAL:
    case FLOATING_POINT_LITERAL:
    case CHARACTER_LITERAL:
    case STRING_LITERAL:
    case TEXT_BLOCK_LITERAL:
      ret = Literal();
      break;
    case THIS:
      jj_consume_token(THIS);
                 ret = new ThisExpr(tokenRange(), null);
      break;
    case SUPER:
      jj_consume_token(SUPER);
                  ret = new SuperExpr(tokenRange(), null);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case DOT:
        jj_consume_token(DOT);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case LT:
          typeArgs = TypeArguments();
          break;
        default:
          jj_la1[94] = jj_gen;
          ;
        }
        name = SimpleName();
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case LPAREN:
          args = Arguments();
                                   hasArgs=true;
          break;
        default:
          jj_la1[95] = jj_gen;
          ;
        }
                if (hasArgs) {
                    ret = new MethodCallExpr(range(ret, jpToken()), ret, typeArgs.list, name, args);
                } else {
                    ret = new FieldAccessExpr(range(ret, jpToken()), ret, emptyNodeList(), name);
                }
        break;
      case DOUBLECOLON:
        jj_consume_token(DOUBLECOLON);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case LT:
          typeArgs = TypeArguments();
          break;
        default:
          jj_la1[96] = jj_gen;
          ;
        }
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case ENUM:
        case STRICTFP:
        case YIELD:
        case REQUIRES:
        case TO:
        case WITH:
        case OPEN:
        case OPENS:
        case USES:
        case MODULE:
        case EXPORTS:
        case PROVIDES:
        case TRANSITIVE:
        case IDENTIFIER:
          Identifier();
          break;
        case NEW:
          jj_consume_token(NEW);
          break;
        default:
          jj_la1[97] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
                ret = new MethodReferenceExpr(range(ret, jpToken()), ret, typeArgs.list, token.image);
        break;
      default:
        jj_la1[98] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      break;
    case LPAREN:
      jj_consume_token(LPAREN);
              begin=jpToken();
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case RPAREN:
        jj_consume_token(RPAREN);
              ret = new LambdaExpr(range(begin, jpToken()), params, new BlockStmt(), true);
        break;
      default:
        jj_la1[99] = jj_gen;
        if (jj_2_33(2147483647)) {
          params = LambdaParameters();
          jj_consume_token(RPAREN);
              ret = new LambdaExpr(range(begin, jpToken()), params, new BlockStmt(), true);
        } else if (jj_2_34(2147483647)) {
          params = InferredLambdaParameters();
          jj_consume_token(RPAREN);
              ret = new LambdaExpr(range(begin, jpToken()), params, new BlockStmt(), true);
        } else {
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case BOOLEAN:
          case BYTE:
          case CHAR:
          case DOUBLE:
          case ENUM:
          case FALSE:
          case FLOAT:
          case INT:
          case LONG:
          case NEW:
          case NULL:
          case SHORT:
          case STRICTFP:
          case SUPER:
          case SWITCH:
          case THIS:
          case TRUE:
          case VOID:
          case YIELD:
          case REQUIRES:
          case TO:
          case WITH:
          case OPEN:
          case OPENS:
          case USES:
          case MODULE:
          case EXPORTS:
          case PROVIDES:
          case TRANSITIVE:
          case LONG_LITERAL:
          case INTEGER_LITERAL:
          case FLOATING_POINT_LITERAL:
          case CHARACTER_LITERAL:
          case STRING_LITERAL:
          case TEXT_BLOCK_LITERAL:
          case IDENTIFIER:
          case LPAREN:
          case AT:
          case BANG:
          case TILDE:
          case INCR:
          case DECR:
          case PLUS:
          case MINUS:
            // This could still be a lambda expression, but this is handled after matching -> elsewhere
                        ret = Expression();
            jj_consume_token(RPAREN);
              ret = new EnclosedExpr(range(begin, jpToken()), ret);
            break;
          default:
            jj_la1[100] = jj_gen;
            jj_consume_token(-1);
            throw new ParseException();
          }
        }
      }
      break;
    case NEW:
      ret = AllocationExpression(null);
      break;
    default:
      jj_la1[104] = jj_gen;
      if (jj_2_35(2147483647)) {
        type = ResultType(emptyNodeList());
        jj_consume_token(DOT);
        jj_consume_token(CLASS);
          ret = new ClassExpr(range(type, jpToken()), type);
      } else if (jj_2_36(2147483647)) {
        type = AnnotatedType();
        jj_consume_token(DOUBLECOLON);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case LT:
          typeArgs = TypeArguments();
          break;
        default:
          jj_la1[101] = jj_gen;
          ;
        }
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case ENUM:
        case STRICTFP:
        case YIELD:
        case REQUIRES:
        case TO:
        case WITH:
        case OPEN:
        case OPENS:
        case USES:
        case MODULE:
        case EXPORTS:
        case PROVIDES:
        case TRANSITIVE:
        case IDENTIFIER:
          Identifier();
          break;
        case NEW:
          jj_consume_token(NEW);
          break;
        default:
          jj_la1[102] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
            ret = new TypeExpr(range(type, type), type);
            ret = new MethodReferenceExpr(range(ret, jpToken()), ret, typeArgs.list, token.image);
      } else {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case ENUM:
        case STRICTFP:
        case YIELD:
        case REQUIRES:
        case TO:
        case WITH:
        case OPEN:
        case OPENS:
        case USES:
        case MODULE:
        case EXPORTS:
        case PROVIDES:
        case TRANSITIVE:
        case IDENTIFIER:
          name = SimpleName();
                              begin=jpToken();
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case LPAREN:
            args = Arguments();
                               hasArgs=true;
            break;
          default:
            jj_la1[103] = jj_gen;
            ;
          }
            if (hasArgs) {
                ret = new MethodCallExpr(range(begin, jpToken()), null, null, name, args);
            } else {
                ret = new NameExpr(name);
            }
          break;
        default:
          jj_la1[105] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
      }
    }
      {if (true) return ret;}
    throw new Error("Missing return statement in function");
  }

/**
 * // TODO: Unclear exactly which part of the JLS this relates to - a JavaParser-specific thing with no 1:1 mapping, perhaps?
 */
  final public Expression PrimarySuffix(Expression scope) throws ParseException {
    Expression ret;
    if (jj_2_37(2)) {
      ret = PrimarySuffixWithoutSuper(scope);
    } else {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case DOT:
        jj_consume_token(DOT);
        jj_consume_token(SUPER);
          ret = new SuperExpr(range(scope, jpToken()), scopeToName(scope));
        break;
      default:
        jj_la1[106] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
      {if (true) return ret;}
    throw new Error("Missing return statement in function");
  }

/**
 * // TODO: Unclear exactly which part of the JLS this relates to - a JavaParser-specific thing with no 1:1 mapping, perhaps?
 */
  final public Expression PrimarySuffixWithoutSuper(Expression scope) throws ParseException {
    Expression ret;
    RangedList<Type> typeArgs = new RangedList<Type>(null);
    NodeList<Expression> args = emptyNodeList();
    boolean hasArgs = false;
    SimpleName name;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case DOT:
      jj_consume_token(DOT);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case THIS:
        jj_consume_token(THIS);
              ret = new ThisExpr(range(scope, jpToken()), scopeToName(scope));
        break;
      case NEW:
        ret = AllocationExpression(scope);
        break;
      default:
        jj_la1[109] = jj_gen;
        if (jj_2_38(2147483647)) {
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case LT:
            typeArgs = TypeArguments();
            break;
          default:
            jj_la1[107] = jj_gen;
            ;
          }
          name = SimpleName();
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case LPAREN:
            args = Arguments();
                                  hasArgs=true;
            break;
          default:
            jj_la1[108] = jj_gen;
            ;
          }
                if (hasArgs) {
                    ret = new MethodCallExpr(range(scope, jpToken()), scope, typeArgs.list, name, args);
                } else {
                    ret =  new FieldAccessExpr(range(scope, jpToken()), scope, typeArgs.list, name);
                }
        } else {
          jj_consume_token(-1);
          throw new ParseException();
        }
      }
      break;
    case LBRACKET:
      jj_consume_token(LBRACKET);
      ret = Expression();
      jj_consume_token(RBRACKET);
          ret = new ArrayAccessExpr(range(scope, jpToken()), scope, ret);
      break;
    default:
      jj_la1[110] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
      {if (true) return ret;}
    throw new Error("Missing return statement in function");
  }

/**
 * Note that a Long Literal is defined as an {@code IntegerLiteral}, suffixed by "L"
 * https://docs.oracle.com/javase/specs/jls/se15/html/jls-3.html#jls-3.10.1
 * <pre>{@code
 *     Literal:
 *         IntegerLiteral
 *         FloatingPointLiteral
 *         BooleanLiteral
 *         CharacterLiteral
 *         StringLiteral
 *         TextBlock
 *         NullLiteral
 * }</pre>
 */
  final public Expression Literal() throws ParseException {
    Expression ret;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case INTEGER_LITERAL:
      jj_consume_token(INTEGER_LITERAL);
                            ret = new IntegerLiteralExpr(tokenRange(), token.image);
      break;
    case LONG_LITERAL:
      jj_consume_token(LONG_LITERAL);
                         ret = new LongLiteralExpr(tokenRange(), token.image);
      break;
    case FLOATING_POINT_LITERAL:
      jj_consume_token(FLOATING_POINT_LITERAL);
                                   ret = new DoubleLiteralExpr(tokenRange(), token.image);
      break;
    case CHARACTER_LITERAL:
      jj_consume_token(CHARACTER_LITERAL);
                              ret = new CharLiteralExpr(tokenRange(), unquote(token.image));
      break;
    case STRING_LITERAL:
      jj_consume_token(STRING_LITERAL);
                           ret = new StringLiteralExpr(tokenRange(), unquote(token.image));
      break;
    case TEXT_BLOCK_LITERAL:
      jj_consume_token(TEXT_BLOCK_LITERAL);
                               ret = new TextBlockLiteralExpr(tokenRange(), unTripleQuote(token.image));
      break;
    case FALSE:
    case TRUE:
      ret = BooleanLiteral();
      break;
    case NULL:
      ret = NullLiteral();
      break;
    default:
      jj_la1[111] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
      {if (true) return ret;}
    throw new Error("Missing return statement in function");
  }

/**
 * https://docs.oracle.com/javase/specs/jls/se15/html/jls-3.html#jls-3.10.3
 * <pre>{@code
 *     BooleanLiteral:
 *         (one of)
 *         true false
 * }</pre>
 */
  final public Expression BooleanLiteral() throws ParseException {
    Expression ret;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case TRUE:
      jj_consume_token(TRUE);
                 ret = new BooleanLiteralExpr(tokenRange(), true);
      break;
    case FALSE:
      jj_consume_token(FALSE);
                  ret = new BooleanLiteralExpr(tokenRange(), false);
      break;
    default:
      jj_la1[112] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
      {if (true) return ret;}
    throw new Error("Missing return statement in function");
  }

/**
 * https://docs.oracle.com/javase/specs/jls/se15/html/jls-3.html#jls-3.10.8
 * <pre>{@code
 *     NullLiteral:
 *         null
 * }</pre>
 */
  final public Expression NullLiteral() throws ParseException {
    jj_consume_token(NULL);
      {if (true) return new NullLiteralExpr(tokenRange());}
    throw new Error("Missing return statement in function");
  }

/**
 * https://docs.oracle.com/javase/specs/jls/se15/html/jls-15.html#jls-15.12
 * <pre>{@code
 *     MethodInvocation:
 *         MethodName ( [ArgumentList] )
 *         TypeName . [TypeArguments] Identifier ( [ArgumentList] )
 *         ExpressionName . [TypeArguments] Identifier ( [ArgumentList] )
 *         Primary . [TypeArguments] Identifier ( [ArgumentList] )
 *         super . [TypeArguments] Identifier ( [ArgumentList] )
 *         TypeName . super . [TypeArguments] Identifier ( [ArgumentList] )
 *     ArgumentList:
 *         Expression {, Expression}
 * }</pre>
 */
  final public NodeList<Expression> Arguments() throws ParseException {
    NodeList<Expression> ret = emptyNodeList();
    jj_consume_token(LPAREN);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case BOOLEAN:
    case BYTE:
    case CHAR:
    case DOUBLE:
    case ENUM:
    case FALSE:
    case FLOAT:
    case INT:
    case LONG:
    case NEW:
    case NULL:
    case SHORT:
    case STRICTFP:
    case SUPER:
    case SWITCH:
    case THIS:
    case TRUE:
    case VOID:
    case YIELD:
    case REQUIRES:
    case TO:
    case WITH:
    case OPEN:
    case OPENS:
    case USES:
    case MODULE:
    case EXPORTS:
    case PROVIDES:
    case TRANSITIVE:
    case LONG_LITERAL:
    case INTEGER_LITERAL:
    case FLOATING_POINT_LITERAL:
    case CHARACTER_LITERAL:
    case STRING_LITERAL:
    case TEXT_BLOCK_LITERAL:
    case IDENTIFIER:
    case LPAREN:
    case AT:
    case BANG:
    case TILDE:
    case INCR:
    case DECR:
    case PLUS:
    case MINUS:
      ret = ArgumentList();
      break;
    default:
      jj_la1[113] = jj_gen;
      ;
    }
    jj_consume_token(RPAREN);
      {if (true) return ret;}
    throw new Error("Missing return statement in function");
  }

/**
 * https://docs.oracle.com/javase/specs/jls/se15/html/jls-15.html#jls-15.12
 * <pre>{@code
 *     ArgumentList:
 *         Expression {, Expression}
 * }</pre>
 */
  final public NodeList<Expression> ArgumentList() throws ParseException {
    NodeList<Expression> ret = emptyNodeList();
    Expression expr;
    expr = Expression();
                          ret.add(expr);
    label_41:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case COMMA:
        ;
        break;
      default:
        jj_la1[114] = jj_gen;
        break label_41;
      }
      jj_consume_token(COMMA);
      expr = Expression();
                              ret.add(expr);
    }
      {if (true) return ret;}
    throw new Error("Missing return statement in function");
  }

/**
 * https://docs.oracle.com/javase/specs/jls/se15/html/jls-15.html#jls-15.9
 * <pre>{@code
 *     ClassInstanceCreationExpression:
 *         UnqualifiedClassInstanceCreationExpression
 *         ExpressionName . UnqualifiedClassInstanceCreationExpression
 *         Primary . UnqualifiedClassInstanceCreationExpression
 *     UnqualifiedClassInstanceCreationExpression:
 *         new [TypeArguments] ClassOrInterfaceTypeToInstantiate ( [ArgumentList] ) [ClassBody]
 *     ClassOrInterfaceTypeToInstantiate:
 *         {Annotation} Identifier {. {Annotation} Identifier} [TypeArgumentsOrDiamond]
 *     TypeArgumentsOrDiamond:
 *         TypeArguments
 *         <>
 * }</pre>
 * For Convenience:
 * <pre>{@code
 *     ArgumentList:
 *         Expression {, Expression}
 * }</pre>
 * https://docs.oracle.com/javase/specs/jls/se15/html/jls-15.html#jls-15.10
 * <pre>{@code
 *     ArrayCreationExpression:
 *         new PrimitiveType DimExprs [Dims]
 *         new ClassOrInterfaceType DimExprs [Dims]
 *         new PrimitiveType Dims ArrayInitializer
 *         new ClassOrInterfaceType Dims ArrayInitializer
 *     DimExprs:
 *         DimExpr {DimExpr}
 *     DimExpr:
 *         {Annotation} [ Expression ]
 * }</pre>
 * For Convenience:
 * <pre>{@code
 *     Dims:
 *         {Annotation} [ ] {{Annotation} [ ]}
 * }</pre>
 */
  final public Expression AllocationExpression(Expression scope) throws ParseException {
    Expression ret;
    Type type;
    RangedList<Type> typeArgs = new RangedList<Type>(null);
    NodeList<BodyDeclaration<?>> anonymousBody = null;
    NodeList<Expression> args;
    JavaToken begin = INVALID;
    NodeList<AnnotationExpr> annotations = new NodeList<AnnotationExpr>();
    jj_consume_token(NEW);
            if(scope==null) { begin=jpToken(); } else { begin = orIfInvalid(begin, scope); }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case LT:
      typeArgs = TypeArguments();
      break;
    default:
      jj_la1[115] = jj_gen;
      ;
    }
    annotations = Annotations();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case BOOLEAN:
    case BYTE:
    case CHAR:
    case DOUBLE:
    case FLOAT:
    case INT:
    case LONG:
    case SHORT:
      // new array of primitives
              type = PrimitiveType(annotations);
      ret = ArrayCreation(begin, type);
      break;
    case ENUM:
    case STRICTFP:
    case YIELD:
    case REQUIRES:
    case TO:
    case WITH:
    case OPEN:
    case OPENS:
    case USES:
    case MODULE:
    case EXPORTS:
    case PROVIDES:
    case TRANSITIVE:
    case IDENTIFIER:
      // new reference type e.g. class (or an array of those)
              type = ClassOrInterfaceType(annotations);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case LBRACKET:
      case AT:
        // new Integer[6] -- the array doesn't have parameters.
                    ret = ArrayCreation(begin, type);
        break;
      case LPAREN:
        // new Integer(6) -- not an array if parameters being passed.
                    args = Arguments();
        if (jj_2_39(2)) {
          anonymousBody = ClassOrInterfaceBody();
        } else {
          ;
        }
              ret = new ObjectCreationExpr(range(begin, jpToken()), scope, (ClassOrInterfaceType) type, typeArgs.list, args, anonymousBody);
        break;
      default:
        jj_la1[116] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      break;
    default:
      jj_la1[117] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
      {if (true) return ret;}
    throw new Error("Missing return statement in function");
  }

/**
 * https://docs.oracle.com/javase/specs/jls/se15/html/jls-15.html#jls-15.10
 * <pre>{@code
 *     ArrayCreationExpression:
 *         new PrimitiveType DimExprs [Dims]
 *         new ClassOrInterfaceType DimExprs [Dims]
 *         new PrimitiveType Dims ArrayInitializer
 *         new ClassOrInterfaceType Dims ArrayInitializer
 *     DimExprs:
 *         DimExpr {DimExpr}
 *     DimExpr:
 *         {Annotation} [ Expression ]
 * }</pre>
 * For Convenience:
 * <pre>{@code
 *     Dims:
 *         {Annotation} [ ] {{Annotation} [ ]}
 * }</pre>
 */
  final public ArrayCreationExpr ArrayCreation(JavaToken begin, Type type) throws ParseException {
    Expression expr = null;
    ArrayInitializerExpr arrayInitializerExpr = null;
    NodeList<Expression> inits = emptyNodeList();
    List<NodeList<AnnotationExpr>> accum = new ArrayList<NodeList<AnnotationExpr>>();
    NodeList<AnnotationExpr> annotations = new NodeList<AnnotationExpr>();
    JavaToken arrayCreationLevelStart = INVALID;
    List<TokenRange> levelRanges = new ArrayList<TokenRange>();
    label_42:
    while (true) {
      annotations = Annotations();
      jj_consume_token(LBRACKET);
              arrayCreationLevelStart = annotations.isEmpty() ? jpToken() : orIfInvalid(arrayCreationLevelStart, annotations.get(0));
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case BOOLEAN:
      case BYTE:
      case CHAR:
      case DOUBLE:
      case ENUM:
      case FALSE:
      case FLOAT:
      case INT:
      case LONG:
      case NEW:
      case NULL:
      case SHORT:
      case STRICTFP:
      case SUPER:
      case SWITCH:
      case THIS:
      case TRUE:
      case VOID:
      case YIELD:
      case REQUIRES:
      case TO:
      case WITH:
      case OPEN:
      case OPENS:
      case USES:
      case MODULE:
      case EXPORTS:
      case PROVIDES:
      case TRANSITIVE:
      case LONG_LITERAL:
      case INTEGER_LITERAL:
      case FLOATING_POINT_LITERAL:
      case CHARACTER_LITERAL:
      case STRING_LITERAL:
      case TEXT_BLOCK_LITERAL:
      case IDENTIFIER:
      case LPAREN:
      case AT:
      case BANG:
      case TILDE:
      case INCR:
      case DECR:
      case PLUS:
      case MINUS:
        expr = Expression();
        break;
      default:
        jj_la1[118] = jj_gen;
        ;
      }
                                accum = add(accum, annotations); inits = add(inits, expr); annotations=null; expr=null;
      jj_consume_token(RBRACKET);
              levelRanges.add(range(arrayCreationLevelStart, jpToken()));
      if (jj_2_40(2)) {
        ;
      } else {
        break label_42;
      }
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case LBRACE:
      arrayInitializerExpr = ArrayInitializer();
      break;
    default:
      jj_la1[119] = jj_gen;
      ;
    }
        {if (true) return juggleArrayCreation(range(begin, jpToken()), levelRanges, type, inits, accum, arrayInitializerExpr);}
    throw new Error("Missing return statement in function");
  }

/*
 * Statement syntax follows.
 */

/**
 * https://docs.oracle.com/javase/specs/jls/se15/html/jls-14.html#jls-14.5
 * <pre>{@code
 *     Statement:
 *         StatementWithoutTrailingSubstatement
 *         LabeledStatement
 *         IfThenStatement
 *         IfThenElseStatement
 *         WhileStatement
 *         ForStatement
 *     StatementNoShortIf:
 *         StatementWithoutTrailingSubstatement
 *         LabeledStatementNoShortIf
 *         IfThenElseStatementNoShortIf
 *         WhileStatementNoShortIf
 *         ForStatementNoShortIf
 *     StatementWithoutTrailingSubstatement:
 *         Block
 *         EmptyStatement
 *         ExpressionStatement
 *         AssertStatement
 *         SwitchStatement
 *         DoStatement
 *         BreakStatement
 *         ContinueStatement
 *         ReturnStatement
 *         SynchronizedStatement
 *         ThrowStatement
 *         TryStatement
 *         YieldStatement
 * }</pre>
 */
  final public Statement Statement() throws ParseException {
    Statement ret;
    try {
      if (jj_2_41(2)) {
        ret = LabeledStatement();
      } else {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case ASSERT:
          ret = AssertStatement();
          break;
        default:
          jj_la1[120] = jj_gen;
          if (jj_2_42(3)) {
            ret = YieldStatement();
          } else {
            switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
            case LBRACE:
              ret = Block();
              break;
            case SEMICOLON:
              ret = EmptyStatement();
              break;
            case BOOLEAN:
            case BYTE:
            case CHAR:
            case DOUBLE:
            case ENUM:
            case FALSE:
            case FLOAT:
            case INT:
            case LONG:
            case NEW:
            case NULL:
            case SHORT:
            case STRICTFP:
            case SUPER:
            case THIS:
            case TRUE:
            case VOID:
            case YIELD:
            case REQUIRES:
            case TO:
            case WITH:
            case OPEN:
            case OPENS:
            case USES:
            case MODULE:
            case EXPORTS:
            case PROVIDES:
            case TRANSITIVE:
            case LONG_LITERAL:
            case INTEGER_LITERAL:
            case FLOATING_POINT_LITERAL:
            case CHARACTER_LITERAL:
            case STRING_LITERAL:
            case TEXT_BLOCK_LITERAL:
            case IDENTIFIER:
            case LPAREN:
            case AT:
            case INCR:
            case DECR:
              ret = StatementExpression();
              break;
            case SWITCH:
              ret = SwitchStatement();
              break;
            case IF:
              ret = IfStatement();
              break;
            case WHILE:
              ret = WhileStatement();
              break;
            case DO:
              ret = DoStatement();
              break;
            case FOR:
              ret = ForStatement();
              break;
            case BREAK:
              ret = BreakStatement();
              break;
            case CONTINUE:
              ret = ContinueStatement();
              break;
            case RETURN:
              ret = ReturnStatement();
              break;
            case THROW:
              ret = ThrowStatement();
              break;
            case SYNCHRONIZED:
              ret = SynchronizedStatement();
              break;
            case TRY:
              ret = TryStatement();
              break;
            default:
              jj_la1[121] = jj_gen;
              jj_consume_token(-1);
              throw new ParseException();
            }
          }
        }
      }
          {if (true) return ret;}
    } catch (ParseException e) {
        TokenRange errorRange = recover(SEMICOLON, e);
        {if (true) return new UnparsableStmt(errorRange);}
    }
    throw new Error("Missing return statement in function");
  }

/**
 * https://docs.oracle.com/javase/specs/jls/se15/html/jls-14.html#jls-14.10
 * <pre>{@code
 *     AssertStatement:
 *         assert Expression ;
 *         assert Expression : Expression ;
 * }</pre>
 */
  final public AssertStmt AssertStatement() throws ParseException {
    Expression check;
    Expression msg = null;
    JavaToken begin;
    jj_consume_token(ASSERT);
               begin=jpToken();
    check = Expression();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case COLON:
      jj_consume_token(COLON);
      msg = Expression();
      break;
    default:
      jj_la1[122] = jj_gen;
      ;
    }
    jj_consume_token(SEMICOLON);
      {if (true) return new AssertStmt(range(begin, jpToken()), check, msg);}
    throw new Error("Missing return statement in function");
  }

/**
 * // TODO: Examine more closely.
 * https://docs.oracle.com/javase/specs/jls/se15/html/jls-14.html#jls-14.7
 * <pre>{@code
 *     LabeledStatement:
 *         Identifier : Statement
 *     LabeledStatementNoShortIf:
 *         Identifier : StatementNoShortIf
 * }</pre>
 */
  final public LabeledStmt LabeledStatement() throws ParseException {
    SimpleName label;
    Statement stmt;
    JavaToken begin;
    label = SimpleName();
                           begin=jpToken();
    jj_consume_token(COLON);
    stmt = Statement();
      {if (true) return new LabeledStmt(range(begin, jpToken()), label, stmt);}
    throw new Error("Missing return statement in function");
  }

/**
 * https://docs.oracle.com/javase/specs/jls/se15/html/jls-14.html#jls-14.2
 * <pre>{@code
 *     Block:
 *         { [BlockStatements] }
 *     BlockStatements:
 *         BlockStatement {BlockStatement}
 *     BlockStatement:
 *         LocalVariableDeclarationStatement
 *         ClassDeclaration
 *         Statement
 * }</pre>
 */
  final public BlockStmt Block() throws ParseException {
    NodeList<Statement> stmts = emptyNodeList();
    JavaToken begin;
    jj_consume_token(LBRACE);
          begin=jpToken();
    try {
      stmts = Statements();
      jj_consume_token(RBRACE);
          {if (true) return new BlockStmt(range(begin, jpToken()), stmts);}
    } catch (ParseException e) {
        recover(RBRACE, e);
        BlockStmt block = new BlockStmt(range(begin, jpToken()), new NodeList<Statement>());
        block.setParsed(UNPARSABLE);
        {if (true) return block;}
    }
    throw new Error("Missing return statement in function");
  }

/**
 * Classes inside body statements can only be abstract or final. The semantic checks must check it.
 * TODO/FIXME: Note that the JLS specifies {@code ClassDeclaration} (thus {@code NormalClassDeclaration} and {@code EnumDeclaration}, but not interface.
 * TODO/FIXME: Is this a bug in the grammar?
 * https://docs.oracle.com/javase/specs/jls/se15/html/jls-14.html#jls-Statement
 * <pre>{@code
 *     Block:
 *         { [BlockStatements] }
 *     BlockStatements:
 *         BlockStatement {BlockStatement}
 *     BlockStatement:
 *         LocalVariableDeclarationStatement
 *         ClassDeclaration
 *         Statement
 * }</pre>
 * For Convenience:
 * https://docs.oracle.com/javase/specs/jls/se15/html/jls-8.html#jls-8.1
 * <pre>{@code
 *     ClassDeclaration:
 *         NormalClassDeclaration
 *         EnumDeclaration
 *     NormalClassDeclaration:
 *         {ClassModifier} class TypeIdentifier [TypeParameters] [Superclass] [Superinterfaces] ClassBody
 * }</pre>
 * For Convenience:
 * https://docs.oracle.com/javase/specs/jls/se15/html/jls-8.html#jls-8.9
 * <pre>{@code
 *     EnumDeclaration:
 *         {ClassModifier} enum TypeIdentifier [Superinterfaces] EnumBody
 * }</pre>
 *
 */
  final public Statement BlockStatement() throws ParseException {
    Statement ret;
    Expression expr;
    ClassOrInterfaceDeclaration typeDecl;
    ModifierHolder modifier;
    try {
      if (jj_2_43(2147483647)) {
        // TODO/FIXME: Is this a bug in the grammar? JLS specifies class or enum, not interface.
                    modifier = Modifiers();
        typeDecl = ClassOrInterfaceDeclaration(modifier);
                                                               ret = new LocalClassDeclarationStmt(range(typeDecl, jpToken()), typeDecl);
      } else if (jj_2_44(2147483647)) {
        expr = VariableDeclarationExpression();
        jj_consume_token(SEMICOLON);
              ret = new ExpressionStmt(range(expr, jpToken()), expr);
      } else {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case ASSERT:
        case BOOLEAN:
        case BREAK:
        case BYTE:
        case CHAR:
        case CONTINUE:
        case DO:
        case DOUBLE:
        case ENUM:
        case FALSE:
        case FLOAT:
        case FOR:
        case IF:
        case INT:
        case LONG:
        case NEW:
        case NULL:
        case RETURN:
        case SHORT:
        case STRICTFP:
        case SUPER:
        case SWITCH:
        case SYNCHRONIZED:
        case THIS:
        case THROW:
        case TRUE:
        case TRY:
        case VOID:
        case WHILE:
        case YIELD:
        case REQUIRES:
        case TO:
        case WITH:
        case OPEN:
        case OPENS:
        case USES:
        case MODULE:
        case EXPORTS:
        case PROVIDES:
        case TRANSITIVE:
        case LONG_LITERAL:
        case INTEGER_LITERAL:
        case FLOATING_POINT_LITERAL:
        case CHARACTER_LITERAL:
        case STRING_LITERAL:
        case TEXT_BLOCK_LITERAL:
        case IDENTIFIER:
        case LPAREN:
        case LBRACE:
        case SEMICOLON:
        case AT:
        case INCR:
        case DECR:
          ret = Statement();
          break;
        default:
          jj_la1[123] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
      }
          {if (true) return ret;}
    } catch (ParseException e) {
        TokenRange errorRange = recover(SEMICOLON, e);
        {if (true) return new UnparsableStmt(errorRange);}
    }
    throw new Error("Missing return statement in function");
  }

  final public VariableDeclarationExpr VariableDeclarationExpression() throws ParseException {
    ModifierHolder modifier;
    Type partialType;
    NodeList<VariableDeclarator> variables = new NodeList<VariableDeclarator>();
    VariableDeclarator var;
    modifier = Modifiers();
    partialType = Type(emptyNodeList());
    var = VariableDeclarator(partialType);
                                            variables.add(var);
    label_43:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case COMMA:
        ;
        break;
      default:
        jj_la1[124] = jj_gen;
        break label_43;
      }
      jj_consume_token(COMMA);
      var = VariableDeclarator(partialType);
                                                variables.add(var);
    }
        JavaToken begin=orIfInvalid(modifier.begin, partialType);
        {if (true) return new VariableDeclarationExpr(range(begin, jpToken()), modifier.modifiers, modifier.annotations, variables);}
    throw new Error("Missing return statement in function");
  }

/**
 * https://docs.oracle.com/javase/specs/jls/se15/html/jls-14.html#jls-14.6
 * <pre>{@code
 *     EmptyStatement:
 *         ;
 * }</pre>
 */
  final public EmptyStmt EmptyStatement() throws ParseException {
    jj_consume_token(SEMICOLON);
      {if (true) return new EmptyStmt(tokenRange());}
    throw new Error("Missing return statement in function");
  }

/**
 * https://docs.oracle.com/javase/specs/jls/se15/html/jls-15.html#jls-15.27.2
 * <pre>{@code
 *     LambdaBody:
 *         Expression
 *         Block
 * }</pre>
 */
  final public Statement LambdaBody() throws ParseException {
    Expression expr;
    Statement n = null;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case BOOLEAN:
    case BYTE:
    case CHAR:
    case DOUBLE:
    case ENUM:
    case FALSE:
    case FLOAT:
    case INT:
    case LONG:
    case NEW:
    case NULL:
    case SHORT:
    case STRICTFP:
    case SUPER:
    case SWITCH:
    case THIS:
    case TRUE:
    case VOID:
    case YIELD:
    case REQUIRES:
    case TO:
    case WITH:
    case OPEN:
    case OPENS:
    case USES:
    case MODULE:
    case EXPORTS:
    case PROVIDES:
    case TRANSITIVE:
    case LONG_LITERAL:
    case INTEGER_LITERAL:
    case FLOATING_POINT_LITERAL:
    case CHARACTER_LITERAL:
    case STRING_LITERAL:
    case TEXT_BLOCK_LITERAL:
    case IDENTIFIER:
    case LPAREN:
    case AT:
    case BANG:
    case TILDE:
    case INCR:
    case DECR:
    case PLUS:
    case MINUS:
      expr = Expression();
                              n = new ExpressionStmt(range(expr, jpToken()), expr);
      break;
    case LBRACE:
      n = Block();
      break;
    default:
      jj_la1[125] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
      {if (true) return n;}
    throw new Error("Missing return statement in function");
  }

  final public ExpressionStmt StatementExpression() throws ParseException {
    Expression expr;
    AssignExpr.Operator op;
    Expression value;
    RangedList<Type> typeArgs = new RangedList<Type>(null);
    Statement lambdaBody;
    if (jj_2_45(2)) {
      expr = PreIncrementExpression();
    } else {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case DECR:
        expr = PreDecrementExpression();
        break;
      case BOOLEAN:
      case BYTE:
      case CHAR:
      case DOUBLE:
      case ENUM:
      case FALSE:
      case FLOAT:
      case INT:
      case LONG:
      case NEW:
      case NULL:
      case SHORT:
      case STRICTFP:
      case SUPER:
      case THIS:
      case TRUE:
      case VOID:
      case YIELD:
      case REQUIRES:
      case TO:
      case WITH:
      case OPEN:
      case OPENS:
      case USES:
      case MODULE:
      case EXPORTS:
      case PROVIDES:
      case TRANSITIVE:
      case LONG_LITERAL:
      case INTEGER_LITERAL:
      case FLOATING_POINT_LITERAL:
      case CHARACTER_LITERAL:
      case STRING_LITERAL:
      case TEXT_BLOCK_LITERAL:
      case IDENTIFIER:
      case LPAREN:
      case AT:
        expr = PrimaryExpression();
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case ASSIGN:
        case INCR:
        case DECR:
        case PLUSASSIGN:
        case MINUSASSIGN:
        case STARASSIGN:
        case SLASHASSIGN:
        case ANDASSIGN:
        case ORASSIGN:
        case XORASSIGN:
        case REMASSIGN:
        case LSHIFTASSIGN:
        case RSIGNEDSHIFTASSIGN:
        case RUNSIGNEDSHIFTASSIGN:
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case INCR:
            jj_consume_token(INCR);
                   expr = new UnaryExpr(range(expr, jpToken()), expr, UnaryExpr.Operator.POSTFIX_INCREMENT);
            break;
          case DECR:
            jj_consume_token(DECR);
                   expr = new UnaryExpr(range(expr, jpToken()), expr, UnaryExpr.Operator.POSTFIX_DECREMENT);
            break;
          case ASSIGN:
          case PLUSASSIGN:
          case MINUSASSIGN:
          case STARASSIGN:
          case SLASHASSIGN:
          case ANDASSIGN:
          case ORASSIGN:
          case XORASSIGN:
          case REMASSIGN:
          case LSHIFTASSIGN:
          case RSIGNEDSHIFTASSIGN:
          case RUNSIGNEDSHIFTASSIGN:
            op = AssignmentOperator();
            value = Expression();
                                   expr = new AssignExpr(range(expr, jpToken()), expr, value, op);
            break;
          default:
            jj_la1[126] = jj_gen;
            jj_consume_token(-1);
            throw new ParseException();
          }
          break;
        default:
          jj_la1[127] = jj_gen;
          ;
        }
        break;
      default:
        jj_la1[128] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
    jj_consume_token(SEMICOLON);
      {if (true) return new ExpressionStmt(range(expr, jpToken()), expr);}
    throw new Error("Missing return statement in function");
  }

/**
 * Note that the {@code SwitchExpression} and {@code SwitchStatemnt} are similar but different. // TODO: Why/How?
 * // TODO: Examine more closely.
 * https://docs.oracle.com/javase/specs/jls/se15/html/jls-14.html#jls-14.11
 * <pre>{@code
 *     SwitchStatement:
 *         switch ( Expression ) SwitchBlock
 * }</pre>
 * For Convenience:
 * <pre>{@code
 *     SwitchBlock:
 *         { SwitchRule {SwitchRule} }
 *         { {SwitchBlockStatementGroup} {SwitchLabel :} }
 *     SwitchRule:
 *         SwitchLabel -> Expression ;
 *         SwitchLabel -> Block
 *         SwitchLabel -> ThrowStatement
 *     SwitchBlockStatementGroup:
 *         SwitchLabel : {SwitchLabel :} BlockStatements
 *     SwitchLabel:
 *         case CaseConstant {, CaseConstant}
 *         default
 *     CaseConstant:
 *         ConditionalExpression
 * }</pre>
 */
  final public SwitchStmt SwitchStatement() throws ParseException {
    Expression selector;
    SwitchEntry entry;
    NodeList<SwitchEntry> entries = emptyNodeList() ;
    JavaToken begin;
    jj_consume_token(SWITCH);
               begin=jpToken();
    jj_consume_token(LPAREN);
    selector = Expression();
    jj_consume_token(RPAREN);
    jj_consume_token(LBRACE);
    label_44:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case CASE:
      case _DEFAULT:
        ;
        break;
      default:
        jj_la1[129] = jj_gen;
        break label_44;
      }
      entry = SwitchEntry();
                                entries = add(entries, entry);
    }
    jj_consume_token(RBRACE);
      {if (true) return new SwitchStmt(range(begin, jpToken()), selector, entries);}
    throw new Error("Missing return statement in function");
  }

/**
 * Note that the {@code SwitchExpression} and {@code SwitchStatemnt} are similar but different. // TODO: Why/How?
 * // TODO: Examine more closely.
 * https://docs.oracle.com/javase/specs/jls/se15/html/jls-15.html#jls-15.28
 * <pre>{@code
 *     SwitchExpression:
 *         switch ( Expression ) SwitchBlock
 * }</pre>
 * For Convenience:
 * <pre>{@code
 *     SwitchBlock:
 *         { SwitchRule {SwitchRule} }
 *         { {SwitchBlockStatementGroup} {SwitchLabel :} }
 *     SwitchRule:
 *         SwitchLabel -> Expression ;
 *         SwitchLabel -> Block
 *         SwitchLabel -> ThrowStatement
 *     SwitchBlockStatementGroup:
 *         SwitchLabel : {SwitchLabel :} BlockStatements
 *     SwitchLabel:
 *         case CaseConstant {, CaseConstant}
 *         default
 *     CaseConstant:
 *         ConditionalExpression
 * }</pre>
 */
  final public SwitchExpr SwitchExpression() throws ParseException {
    Expression selector;
    SwitchEntry entry;
    NodeList<SwitchEntry> entries = emptyNodeList();
    JavaToken begin;
    jj_consume_token(SWITCH);
               begin=jpToken();
    jj_consume_token(LPAREN);
    selector = Expression();
    jj_consume_token(RPAREN);
    jj_consume_token(LBRACE);
    label_45:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case CASE:
      case _DEFAULT:
        ;
        break;
      default:
        jj_la1[130] = jj_gen;
        break label_45;
      }
      entry = SwitchEntry();
                                entries = add(entries, entry);
    }
    jj_consume_token(RBRACE);
      {if (true) return new SwitchExpr(range(begin, jpToken()), selector, entries);}
    throw new Error("Missing return statement in function");
  }

/**
 * Note that the {@code SwitchBlock} (JLS) and {@code SwitchEntry} (JavaParser) are equivlent.
 * // TODO: Examine more closely.
 * https://docs.oracle.com/javase/specs/jls/se15/html/jls-14.html#jls-14.11.1
 * <pre>{@code
 *     SwitchBlock:
 *         { SwitchRule {SwitchRule} }
 *         { {SwitchBlockStatementGroup} {SwitchLabel :} }
 *     SwitchRule:
 *         SwitchLabel -> Expression ;
 *         SwitchLabel -> Block
 *         SwitchLabel -> ThrowStatement
 *     SwitchBlockStatementGroup:
 *         SwitchLabel : {SwitchLabel :} BlockStatements
 *     SwitchLabel:
 *         case CaseConstant {, CaseConstant}
 *         default
 *     CaseConstant:
 *         ConditionalExpression
 * }</pre>
 */
  final public SwitchEntry SwitchEntry() throws ParseException {
    Expression label = null;
    NodeList<Expression> labels = emptyNodeList();
    NodeList<Statement> stmts = emptyNodeList();
    JavaToken begin;
    SwitchEntry ret;
    Expression expression = null;
    Statement stmt = null;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case CASE:
      jj_consume_token(CASE);
                 begin=jpToken();
      label = ConditionalExpression();
                                          labels = add(labels, label);
      label_46:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case COMMA:
          ;
          break;
        default:
          jj_la1[131] = jj_gen;
          break label_46;
        }
        jj_consume_token(COMMA);
        label = ConditionalExpression();
                                               labels = add(labels, label);
      }
      break;
    case _DEFAULT:
      jj_consume_token(_DEFAULT);
                    begin=jpToken();
      break;
    default:
      jj_la1[132] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case COLON:
      jj_consume_token(COLON);
      stmts = Statements();
          ret = new SwitchEntry(range(begin, jpToken()), labels, STATEMENT_GROUP, stmts);
      break;
    case ARROW:
      jj_consume_token(ARROW);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case BOOLEAN:
      case BYTE:
      case CHAR:
      case DOUBLE:
      case ENUM:
      case FALSE:
      case FLOAT:
      case INT:
      case LONG:
      case NEW:
      case NULL:
      case SHORT:
      case STRICTFP:
      case SUPER:
      case SWITCH:
      case THIS:
      case TRUE:
      case VOID:
      case YIELD:
      case REQUIRES:
      case TO:
      case WITH:
      case OPEN:
      case OPENS:
      case USES:
      case MODULE:
      case EXPORTS:
      case PROVIDES:
      case TRANSITIVE:
      case LONG_LITERAL:
      case INTEGER_LITERAL:
      case FLOATING_POINT_LITERAL:
      case CHARACTER_LITERAL:
      case STRING_LITERAL:
      case TEXT_BLOCK_LITERAL:
      case IDENTIFIER:
      case LPAREN:
      case AT:
      case BANG:
      case TILDE:
      case INCR:
      case DECR:
      case PLUS:
      case MINUS:
        expression = Expression();
        jj_consume_token(SEMICOLON);
                TokenRange r=range(begin, jpToken());
                stmts.add(new ExpressionStmt(r, expression));
                ret = new SwitchEntry(r, labels, EXPRESSION, stmts);
        break;
      case LBRACE:
        stmt = Block();
                TokenRange r=range(begin, jpToken());
                stmts.add(stmt);
                ret = new SwitchEntry(r, labels, BLOCK, stmts);
        break;
      case THROW:
        stmt = ThrowStatement();
                TokenRange r=range(begin, jpToken());
                stmts.add(stmt);
                ret = new SwitchEntry(r, labels, THROWS_STATEMENT, stmts);
        break;
      default:
        jj_la1[133] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      break;
    default:
      jj_la1[134] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
      {if (true) return ret;}
    throw new Error("Missing return statement in function");
  }

/**
 * https://docs.oracle.com/javase/specs/jls/se15/html/jls-14.html#jls-14.9
 * <pre>{@code
 *     IfThenStatement:
 *         if ( Expression ) Statement
 *     IfThenElseStatement:
 *         if ( Expression ) StatementNoShortIf else Statement
 *     IfThenElseStatementNoShortIf:
 *         if ( Expression ) StatementNoShortIf else StatementNoShortIf
 * }</pre>
 */
  final public IfStmt IfStatement() throws ParseException {
    Expression condition;
    Statement thenStmt;
    Statement elseStmt = null;
    JavaToken begin;
    jj_consume_token(IF);
           begin=jpToken();
    jj_consume_token(LPAREN);
    condition = Expression();
    jj_consume_token(RPAREN);
    thenStmt = Statement();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case ELSE:
      jj_consume_token(ELSE);
      elseStmt = Statement();
      break;
    default:
      jj_la1[135] = jj_gen;
      ;
    }
        {if (true) return new IfStmt(range(begin, jpToken()), condition, thenStmt, elseStmt);}
    throw new Error("Missing return statement in function");
  }

/**
 * https://docs.oracle.com/javase/specs/jls/se15/html/jls-14.html#jls-14.12
 * <pre>{@code
 *     WhileStatement:
 *         while ( Expression ) Statement
 *     WhileStatementNoShortIf:
 *         while ( Expression ) StatementNoShortIf
 * }</pre>
 */
  final public WhileStmt WhileStatement() throws ParseException {
    Expression condition;
    Statement body;
    JavaToken begin;
    jj_consume_token(WHILE);
              begin=jpToken();
    jj_consume_token(LPAREN);
    condition = Expression();
    jj_consume_token(RPAREN);
    body = Statement();
      {if (true) return new WhileStmt(range(begin, jpToken()),condition, body);}
    throw new Error("Missing return statement in function");
  }

/**
 * https://docs.oracle.com/javase/specs/jls/se15/html/jls-14.html#jls-14.12
 * <pre>{@code
 *     DoStatement:
 *         do Statement while ( Expression ) ;
 * }</pre>
 */
  final public DoStmt DoStatement() throws ParseException {
    Expression condition;
    Statement body;
    JavaToken begin;
    jj_consume_token(DO);
           begin=jpToken();
    body = Statement();
    jj_consume_token(WHILE);
    jj_consume_token(LPAREN);
    condition = Expression();
    jj_consume_token(RPAREN);
    jj_consume_token(SEMICOLON);
      {if (true) return new DoStmt(range(begin, jpToken()),body, condition);}
    throw new Error("Missing return statement in function");
  }

/**
 * https://docs.oracle.com/javase/specs/jls/se15/html/jls-14.html#jls-14.14
 * <pre>{@code
 *     ForStatement:
 *         BasicForStatement
 *         EnhancedForStatement
 *     ForStatementNoShortIf:
 *         BasicForStatementNoShortIf
 *         EnhancedForStatementNoShortIf
 * }</pre>
 */
  final public Statement ForStatement() throws ParseException {
    VariableDeclarationExpr varExpr = null;
    Expression expr = null;
    NodeList<Expression> init = emptyNodeList();
    NodeList<Expression> update = emptyNodeList();
    Statement body;
    JavaToken begin;
    jj_consume_token(FOR);
            begin=jpToken();
    jj_consume_token(LPAREN);
    if (jj_2_46(2147483647)) {
      varExpr = VariableDeclarationExpression();
      jj_consume_token(COLON);
      expr = Expression();
    } else {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case ABSTRACT:
      case BOOLEAN:
      case BYTE:
      case CHAR:
      case _DEFAULT:
      case DOUBLE:
      case ENUM:
      case FALSE:
      case FINAL:
      case FLOAT:
      case INT:
      case LONG:
      case NATIVE:
      case NEW:
      case NULL:
      case PRIVATE:
      case PROTECTED:
      case PUBLIC:
      case SHORT:
      case STATIC:
      case STRICTFP:
      case SUPER:
      case SWITCH:
      case SYNCHRONIZED:
      case THIS:
      case TRANSIENT:
      case TRUE:
      case VOID:
      case VOLATILE:
      case YIELD:
      case REQUIRES:
      case TO:
      case WITH:
      case OPEN:
      case OPENS:
      case USES:
      case MODULE:
      case EXPORTS:
      case PROVIDES:
      case TRANSITIVE:
      case LONG_LITERAL:
      case INTEGER_LITERAL:
      case FLOATING_POINT_LITERAL:
      case CHARACTER_LITERAL:
      case STRING_LITERAL:
      case TEXT_BLOCK_LITERAL:
      case IDENTIFIER:
      case LPAREN:
      case SEMICOLON:
      case AT:
      case BANG:
      case TILDE:
      case INCR:
      case DECR:
      case PLUS:
      case MINUS:
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case ABSTRACT:
        case BOOLEAN:
        case BYTE:
        case CHAR:
        case _DEFAULT:
        case DOUBLE:
        case ENUM:
        case FALSE:
        case FINAL:
        case FLOAT:
        case INT:
        case LONG:
        case NATIVE:
        case NEW:
        case NULL:
        case PRIVATE:
        case PROTECTED:
        case PUBLIC:
        case SHORT:
        case STATIC:
        case STRICTFP:
        case SUPER:
        case SWITCH:
        case SYNCHRONIZED:
        case THIS:
        case TRANSIENT:
        case TRUE:
        case VOID:
        case VOLATILE:
        case YIELD:
        case REQUIRES:
        case TO:
        case WITH:
        case OPEN:
        case OPENS:
        case USES:
        case MODULE:
        case EXPORTS:
        case PROVIDES:
        case TRANSITIVE:
        case LONG_LITERAL:
        case INTEGER_LITERAL:
        case FLOATING_POINT_LITERAL:
        case CHARACTER_LITERAL:
        case STRING_LITERAL:
        case TEXT_BLOCK_LITERAL:
        case IDENTIFIER:
        case LPAREN:
        case AT:
        case BANG:
        case TILDE:
        case INCR:
        case DECR:
        case PLUS:
        case MINUS:
          init = ForInit();
          break;
        default:
          jj_la1[136] = jj_gen;
          ;
        }
        jj_consume_token(SEMICOLON);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case BOOLEAN:
        case BYTE:
        case CHAR:
        case DOUBLE:
        case ENUM:
        case FALSE:
        case FLOAT:
        case INT:
        case LONG:
        case NEW:
        case NULL:
        case SHORT:
        case STRICTFP:
        case SUPER:
        case SWITCH:
        case THIS:
        case TRUE:
        case VOID:
        case YIELD:
        case REQUIRES:
        case TO:
        case WITH:
        case OPEN:
        case OPENS:
        case USES:
        case MODULE:
        case EXPORTS:
        case PROVIDES:
        case TRANSITIVE:
        case LONG_LITERAL:
        case INTEGER_LITERAL:
        case FLOATING_POINT_LITERAL:
        case CHARACTER_LITERAL:
        case STRING_LITERAL:
        case TEXT_BLOCK_LITERAL:
        case IDENTIFIER:
        case LPAREN:
        case AT:
        case BANG:
        case TILDE:
        case INCR:
        case DECR:
        case PLUS:
        case MINUS:
          expr = Expression();
          break;
        default:
          jj_la1[137] = jj_gen;
          ;
        }
        jj_consume_token(SEMICOLON);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case BOOLEAN:
        case BYTE:
        case CHAR:
        case DOUBLE:
        case ENUM:
        case FALSE:
        case FLOAT:
        case INT:
        case LONG:
        case NEW:
        case NULL:
        case SHORT:
        case STRICTFP:
        case SUPER:
        case SWITCH:
        case THIS:
        case TRUE:
        case VOID:
        case YIELD:
        case REQUIRES:
        case TO:
        case WITH:
        case OPEN:
        case OPENS:
        case USES:
        case MODULE:
        case EXPORTS:
        case PROVIDES:
        case TRANSITIVE:
        case LONG_LITERAL:
        case INTEGER_LITERAL:
        case FLOATING_POINT_LITERAL:
        case CHARACTER_LITERAL:
        case STRING_LITERAL:
        case TEXT_BLOCK_LITERAL:
        case IDENTIFIER:
        case LPAREN:
        case AT:
        case BANG:
        case TILDE:
        case INCR:
        case DECR:
        case PLUS:
        case MINUS:
          update = ForUpdate();
          break;
        default:
          jj_la1[138] = jj_gen;
          ;
        }
        break;
      default:
        jj_la1[139] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
    jj_consume_token(RPAREN);
    body = Statement();
        if (varExpr != null) {
            {if (true) return new ForEachStmt(range(begin, jpToken()),varExpr, expr, body);}
        }
        {if (true) return new ForStmt(range(begin, jpToken()),init, expr, update, body);}
    throw new Error("Missing return statement in function");
  }

/**
 * https://docs.oracle.com/javase/specs/jls/se15/html/jls-14.html#jls-14.14
 * <pre>{@code
 *     BasicForStatement:
 *         for ( [ForInit] ; [Expression] ; [ForUpdate] ) Statement
 *     BasicForStatementNoShortIf:
 *         for ( [ForInit] ; [Expression] ; [ForUpdate] ) StatementNoShortIf
 *     ForInit:
 *         StatementExpressionList
 *         LocalVariableDeclaration
 *     ForUpdate:
 *         StatementExpressionList
 *     StatementExpressionList:
 *         StatementExpression {, StatementExpression}
 * }</pre>
 */
  final public NodeList<Expression> ForInit() throws ParseException {
    NodeList<Expression> ret;
    Expression expr;
    if (jj_2_47(2147483647)) {
      expr = VariableDeclarationExpression();
                                                 ret = new NodeList<Expression>(); ret.add(expr);
    } else {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case BOOLEAN:
      case BYTE:
      case CHAR:
      case DOUBLE:
      case ENUM:
      case FALSE:
      case FLOAT:
      case INT:
      case LONG:
      case NEW:
      case NULL:
      case SHORT:
      case STRICTFP:
      case SUPER:
      case SWITCH:
      case THIS:
      case TRUE:
      case VOID:
      case YIELD:
      case REQUIRES:
      case TO:
      case WITH:
      case OPEN:
      case OPENS:
      case USES:
      case MODULE:
      case EXPORTS:
      case PROVIDES:
      case TRANSITIVE:
      case LONG_LITERAL:
      case INTEGER_LITERAL:
      case FLOATING_POINT_LITERAL:
      case CHARACTER_LITERAL:
      case STRING_LITERAL:
      case TEXT_BLOCK_LITERAL:
      case IDENTIFIER:
      case LPAREN:
      case AT:
      case BANG:
      case TILDE:
      case INCR:
      case DECR:
      case PLUS:
      case MINUS:
        ret = ExpressionList();
        break;
      default:
        jj_la1[140] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
      {if (true) return ret;}
    throw new Error("Missing return statement in function");
  }

/**
 * https://docs.oracle.com/javase/specs/jls/se15/html/jls-14.html#jls-14.14
 * <pre>{@code
 *     BasicForStatement:
 *         for ( [ForInit] ; [Expression] ; [ForUpdate] ) Statement
 *     BasicForStatementNoShortIf:
 *         for ( [ForInit] ; [Expression] ; [ForUpdate] ) StatementNoShortIf
 *     ForInit:
 *         StatementExpressionList
 *         LocalVariableDeclaration
 *     ForUpdate:
 *         StatementExpressionList
 *     StatementExpressionList:
 *         StatementExpression {, StatementExpression}
 * }</pre>
 */
  final public NodeList<Expression> ExpressionList() throws ParseException {
    NodeList<Expression> ret = new NodeList<Expression>();
    Expression expr;
    expr = Expression();
                          ret.add(expr);
    label_47:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case COMMA:
        ;
        break;
      default:
        jj_la1[141] = jj_gen;
        break label_47;
      }
      jj_consume_token(COMMA);
      expr = Expression();
                               ret.add(expr);
    }
      {if (true) return ret;}
    throw new Error("Missing return statement in function");
  }

/**
 * https://docs.oracle.com/javase/specs/jls/se15/html/jls-14.html#jls-14.14
 * <pre>{@code
 *     BasicForStatement:
 *         for ( [ForInit] ; [Expression] ; [ForUpdate] ) Statement
 *     BasicForStatementNoShortIf:
 *         for ( [ForInit] ; [Expression] ; [ForUpdate] ) StatementNoShortIf
 *     ForInit:
 *         StatementExpressionList
 *         LocalVariableDeclaration
 *     ForUpdate:
 *         StatementExpressionList
 *     StatementExpressionList:
 *         StatementExpression {, StatementExpression}
 * }</pre>
 */
  final public NodeList<Expression> ForUpdate() throws ParseException {
    NodeList<Expression> ret;
    ret = ExpressionList();
      {if (true) return ret;}
    throw new Error("Missing return statement in function");
  }

/**
 * https://docs.oracle.com/javase/specs/jls/se15/html/jls-14.html#jls-14.15
 * <pre>{@code
 *     BreakStatement:
 *         break [Identifier] ;
 * }</pre>
 */
  final public BreakStmt BreakStatement() throws ParseException {
    SimpleName label = null;
    JavaToken begin;
    jj_consume_token(BREAK);
              begin=jpToken();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case ENUM:
    case STRICTFP:
    case YIELD:
    case REQUIRES:
    case TO:
    case WITH:
    case OPEN:
    case OPENS:
    case USES:
    case MODULE:
    case EXPORTS:
    case PROVIDES:
    case TRANSITIVE:
    case IDENTIFIER:
      label = SimpleName();
      break;
    default:
      jj_la1[142] = jj_gen;
      ;
    }
    jj_consume_token(SEMICOLON);
      {if (true) return new BreakStmt(range(begin, jpToken()), label);}
    throw new Error("Missing return statement in function");
  }

/**
 * https://docs.oracle.com/javase/specs/jls/se15/html/jls-14.html#jls-14.21
 * <pre>{@code
 *     YieldStatement:
 *         yield Expression ;
 * }</pre>
 */
  final public YieldStmt YieldStatement() throws ParseException {
    Expression value;
    JavaToken begin;
    jj_consume_token(YIELD);
              begin=jpToken();
    value = Expression();
    jj_consume_token(SEMICOLON);
      {if (true) return new YieldStmt(range(begin, jpToken()), value);}
    throw new Error("Missing return statement in function");
  }

/**
 * https://docs.oracle.com/javase/specs/jls/se15/html/jls-14.html#jls-14.16
 * <pre>{@code
 *     ContinueStatement:
 *         continue [Identifier] ;
 * }</pre>
 */
  final public ContinueStmt ContinueStatement() throws ParseException {
    SimpleName label = null;
    JavaToken begin;
    jj_consume_token(CONTINUE);
                 begin=jpToken();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case ENUM:
    case STRICTFP:
    case YIELD:
    case REQUIRES:
    case TO:
    case WITH:
    case OPEN:
    case OPENS:
    case USES:
    case MODULE:
    case EXPORTS:
    case PROVIDES:
    case TRANSITIVE:
    case IDENTIFIER:
      label = SimpleName();
      break;
    default:
      jj_la1[143] = jj_gen;
      ;
    }
    jj_consume_token(SEMICOLON);
      {if (true) return new ContinueStmt(range(begin, jpToken()), label);}
    throw new Error("Missing return statement in function");
  }

/**
 * https://docs.oracle.com/javase/specs/jls/se15/html/jls-14.html#jls-14.17
 * <pre>{@code
 *     ReturnStatement:
 *         return [Expression] ;
 * }</pre>
 */
  final public ReturnStmt ReturnStatement() throws ParseException {
    Expression expr = null;
    JavaToken begin;
    jj_consume_token(RETURN);
               begin=jpToken();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case BOOLEAN:
    case BYTE:
    case CHAR:
    case DOUBLE:
    case ENUM:
    case FALSE:
    case FLOAT:
    case INT:
    case LONG:
    case NEW:
    case NULL:
    case SHORT:
    case STRICTFP:
    case SUPER:
    case SWITCH:
    case THIS:
    case TRUE:
    case VOID:
    case YIELD:
    case REQUIRES:
    case TO:
    case WITH:
    case OPEN:
    case OPENS:
    case USES:
    case MODULE:
    case EXPORTS:
    case PROVIDES:
    case TRANSITIVE:
    case LONG_LITERAL:
    case INTEGER_LITERAL:
    case FLOATING_POINT_LITERAL:
    case CHARACTER_LITERAL:
    case STRING_LITERAL:
    case TEXT_BLOCK_LITERAL:
    case IDENTIFIER:
    case LPAREN:
    case AT:
    case BANG:
    case TILDE:
    case INCR:
    case DECR:
    case PLUS:
    case MINUS:
      expr = Expression();
      break;
    default:
      jj_la1[144] = jj_gen;
      ;
    }
    jj_consume_token(SEMICOLON);
      {if (true) return new ReturnStmt(range(begin, jpToken()),expr);}
    throw new Error("Missing return statement in function");
  }

/**
 * https://docs.oracle.com/javase/specs/jls/se15/html/jls-14.html#jls-14.18
 * <pre>{@code
 *     ThrowStatement:
 *         throw Expression ;
 * }</pre>
 */
  final public ThrowStmt ThrowStatement() throws ParseException {
    Expression expr;
    JavaToken begin;
    jj_consume_token(THROW);
              begin=jpToken();
    expr = Expression();
    jj_consume_token(SEMICOLON);
      {if (true) return new ThrowStmt(range(begin, jpToken()),expr);}
    throw new Error("Missing return statement in function");
  }

/**
 * https://docs.oracle.com/javase/specs/jls/se15/html/jls-14.html#jls-14.19
 * <pre>{@code
 *     SynchronizedStatement:
 *         synchronized ( Expression ) Block
 * }</pre>
 */
  final public SynchronizedStmt SynchronizedStatement() throws ParseException {
    Expression expr;
    BlockStmt body;
    JavaToken begin;
    jj_consume_token(SYNCHRONIZED);
                     begin=jpToken();
    jj_consume_token(LPAREN);
    expr = Expression();
    jj_consume_token(RPAREN);
    body = Block();
      {if (true) return new SynchronizedStmt(range(begin, jpToken()),expr, body);}
    throw new Error("Missing return statement in function");
  }

/**
 * // TODO: Examine more closely.
 * https://docs.oracle.com/javase/specs/jls/se15/html/jls-14.html#jls-14.20
 * <pre>{@code
 *     TryStatement:
 *         try Block Catches
 *         try Block [Catches] Finally
 *         TryWithResourcesStatement
 *     Catches:
 *         CatchClause {CatchClause}
 *     CatchClause:
 *         catch ( CatchFormalParameter ) Block
 *     CatchFormalParameter:
 *        {VariableModifier} CatchType VariableDeclaratorId
 *     CatchType:
 *         UnannClassType {| ClassType}
 *     Finally:
 *         finally Block
 * }<pre>
 * For Convenience:
 * <pre>{@code
 *     VariableModifier:
 *         Annotation
 *         final
 *     VariableDeclaratorId:
 *         Identifier [Dims]
 *     Dims:
 *         {Annotation} [ ] {{Annotation} [ ]}
 * }<pre>
 */
  final public TryStmt TryStatement() throws ParseException {
    NodeList<Expression> resources = emptyNodeList();
    BlockStmt tryBlock;
    BlockStmt finallyBlock = null;
    NodeList<CatchClause> catchs = emptyNodeList();
    BlockStmt catchBlock;
    ModifierHolder exceptModifier;
    ReferenceType exceptionType;
    NodeList<ReferenceType> exceptionTypes = emptyNodeList();
    Pair<SimpleName, List<ArrayBracketPair>> exceptId;
    JavaToken begin;
    JavaToken catchBegin;
    JavaToken typesBegin;
    JavaToken paramEnd;
    Type type;
    jj_consume_token(TRY);
            begin=jpToken();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case LPAREN:
      resources = ResourceSpecification();
      break;
    default:
      jj_la1[145] = jj_gen;
      ;
    }
    tryBlock = Block();
    label_48:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case CATCH:
        ;
        break;
      default:
        jj_la1[146] = jj_gen;
        break label_48;
      }
      jj_consume_token(CATCH);
                     catchBegin=jpToken();
      jj_consume_token(LPAREN);
      exceptModifier = Modifiers();
                                           typesBegin = exceptModifier.begin;
      exceptionType = ReferenceType(emptyNodeList());
                                                             exceptionTypes.add(exceptionType); typesBegin = orIfInvalid(typesBegin, jpToken());
      label_49:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case BIT_OR:
          ;
          break;
        default:
          jj_la1[147] = jj_gen;
          break label_49;
        }
        jj_consume_token(BIT_OR);
        exceptionType = AnnotatedReferenceType();
                                                           exceptionTypes.add(exceptionType);
      }
      exceptId = VariableDeclaratorId();
                                                paramEnd = jpToken();
      jj_consume_token(RPAREN);
      catchBlock = Block();
                if (exceptionTypes.size() > 1) {
                    type = new UnionType(range(exceptionTypes.get(0), exceptionTypes.get(exceptionTypes.size() - 1)), exceptionTypes);
                } else {
                    type = (Type)exceptionTypes.get(0);
                }
                Parameter catchType = new Parameter(range(typesBegin, paramEnd), exceptModifier.modifiers, exceptModifier.annotations, type, false, emptyNodeList(), exceptId.a);
                catchs = add(catchs, new CatchClause(range(catchBegin, jpToken()), catchType, catchBlock));
                exceptionTypes = emptyNodeList();
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case FINALLY:
      jj_consume_token(FINALLY);
      finallyBlock = Block();
      break;
    default:
      jj_la1[148] = jj_gen;
      ;
    }
      {if (true) return new TryStmt(range(begin, jpToken()), resources, tryBlock, catchs, finallyBlock);}
    throw new Error("Missing return statement in function");
  }

/**
 * https://docs.oracle.com/javase/specs/jls/se15/html/jls-14.html#jls-14.20.3
 * <pre>{@code
 *     TryWithResourcesStatement:
 *         try ResourceSpecification Block [Catches] [Finally]
 *     ResourceSpecification:
 *         ( ResourceList [;] )
 *     ResourceList:
 *         Resource {; Resource}
 *     Resource:
 *         {VariableModifier} LocalVariableType Identifier = Expression
 *         VariableAccess
 *     VariableAccess:
 *         ExpressionName
 *         FieldAccess
 * }<pre>
 * For Convenience:
 * <pre>{@code
 *     VariableModifier:
 *         Annotation
 *         final
 *     LocalVariableType:
 *         UnannType
 *         var
 * }<pre>
 */
  final public NodeList<Expression> ResourceSpecification() throws ParseException {
    NodeList<Expression> variables;
    jj_consume_token(LPAREN);
    variables = Resources();
    if (jj_2_48(2)) {
      jj_consume_token(SEMICOLON);
    } else {
      ;
    }
    jj_consume_token(RPAREN);
      {if (true) return variables;}
    throw new Error("Missing return statement in function");
  }

/**
 * https://docs.oracle.com/javase/specs/jls/se15/html/jls-14.html#jls-14.20.3
 * <pre>{@code
 *     ResourceList:
 *         Resource {; Resource}
 *     Resource:
 *         {VariableModifier} LocalVariableType Identifier = Expression
 *         VariableAccess
 *     VariableAccess:
 *         ExpressionName
 *         FieldAccess
 * }<pre>
 * For Convenience:
 * <pre>{@code
 *     VariableModifier:
 *         Annotation
 *         final
 *     LocalVariableType:
 *         UnannType
 *         var
 * }<pre>
 */
  final public NodeList<Expression> Resources() throws ParseException {
    NodeList<Expression> expressions = new NodeList<Expression>();
    Expression expr;
    expr = Resource();
                       expressions.add(expr);
    label_50:
    while (true) {
      if (jj_2_49(2)) {
        ;
      } else {
        break label_50;
      }
      jj_consume_token(SEMICOLON);
      expr = Resource();
                                                                                    expressions.add(expr);
    }
      {if (true) return expressions;}
    throw new Error("Missing return statement in function");
  }

/**
 * // TODO: Examine more closely.
 * https://docs.oracle.com/javase/specs/jls/se15/html/jls-14.html#jls-14.20.3
 * <pre>{@code
 *     Resource:
 *         {VariableModifier} LocalVariableType Identifier = Expression
 *         VariableAccess
 *     VariableAccess:
 *         ExpressionName
 *         FieldAccess
 * }<pre>
 * For Convenience:
 * <pre>{@code
 *     VariableModifier:
 *         Annotation
 *         final
 *     LocalVariableType:
 *         UnannType
 *         var
 * }<pre>
 */
  final public Expression Resource() throws ParseException {
    Expression expr;
    if (jj_2_50(2147483647)) {
      /*this is a bit more lenient than we need to be, e.g. allowing access modifiers like private*/
              expr = VariableDeclarationExpression();
    } else {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case BOOLEAN:
      case BYTE:
      case CHAR:
      case DOUBLE:
      case ENUM:
      case FALSE:
      case FLOAT:
      case INT:
      case LONG:
      case NEW:
      case NULL:
      case SHORT:
      case STRICTFP:
      case SUPER:
      case THIS:
      case TRUE:
      case VOID:
      case YIELD:
      case REQUIRES:
      case TO:
      case WITH:
      case OPEN:
      case OPENS:
      case USES:
      case MODULE:
      case EXPORTS:
      case PROVIDES:
      case TRANSITIVE:
      case LONG_LITERAL:
      case INTEGER_LITERAL:
      case FLOATING_POINT_LITERAL:
      case CHARACTER_LITERAL:
      case STRING_LITERAL:
      case TEXT_BLOCK_LITERAL:
      case IDENTIFIER:
      case LPAREN:
      case AT:
        expr = PrimaryExpression();
        break;
      default:
        jj_la1[149] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
      {if (true) return expr;}
    throw new Error("Missing return statement in function");
  }

/* We use productions to match >>>, >> and > so that we can keep the
 * type declaration syntax with generics clean
 */
  final public void RUNSIGNEDSHIFT() throws ParseException {
    if (getToken(1).kind == GT && getToken(1).realKind == RUNSIGNEDSHIFT) {

    } else {
      jj_consume_token(-1);
      throw new ParseException();
    }
    jj_consume_token(GT);
    jj_consume_token(GT);
    jj_consume_token(GT);
  }

  final public void RSIGNEDSHIFT() throws ParseException {
    if (getToken(1).kind == GT && getToken(1).realKind == RSIGNEDSHIFT) {

    } else {
      jj_consume_token(-1);
      throw new ParseException();
    }
    jj_consume_token(GT);
    jj_consume_token(GT);
  }

/* Annotation syntax follows. */

/**
 * https://docs.oracle.com/javase/specs/jls/se15/html/jls-9.html#jls-9.7
 * <pre>{@code
 *     Annotation:
 *         NormalAnnotation
 *         MarkerAnnotation
 *         SingleElementAnnotation
 * }<pre>
 */
  final public NodeList<AnnotationExpr> Annotations() throws ParseException {
    NodeList<AnnotationExpr> annotations = new NodeList<AnnotationExpr>();
    AnnotationExpr annotation;
    label_51:
    while (true) {
      if (jj_2_51(2147483647)) {
        ;
      } else {
        break label_51;
      }
      annotation = Annotation();
                                    annotations = add(annotations, annotation);
    }
      {if (true) return annotations;}
    throw new Error("Missing return statement in function");
  }

/**
 * https://docs.oracle.com/javase/specs/jls/se15/html/jls-9.html#jls-9.7
 * <pre>{@code
 *     Annotation:
 *         NormalAnnotation
 *         MarkerAnnotation
 *         SingleElementAnnotation
 * }<pre>
 * For Convenience:
 * https://docs.oracle.com/javase/specs/jls/se15/html/jls-9.html#jls-9.7.1
 * <pre>{@code
 *     NormalAnnotation:
 *         @ TypeName ( [ElementValuePairList] )
 *     ElementValuePairList:
 *         ElementValuePair {, ElementValuePair}
 *     ElementValuePair:
 *         Identifier = ElementValue
 *     ElementValue:
 *         ConditionalExpression
 *         ElementValueArrayInitializer
 *         Annotation
 *     ElementValueArrayInitializer:
 *         { [ElementValueList] [,] }
 *     ElementValueList:
 *         ElementValue {, ElementValue}
 * }<pre>
 * For Convenience:
 * https://docs.oracle.com/javase/specs/jls/se15/html/jls-9.html#jls-9.7.2
 * <blockquote>
 * It [The marker annotation] is shorthand for the normal annotation:
 * {@code @TypeName()}
 * </blockquote>
 * <pre>{@code
 *     MarkerAnnotation:
 *         @ TypeName
 * }<pre>
 * For Convenience:
 * https://docs.oracle.com/javase/specs/jls/se15/html/jls-9.html#jls-9.7.3
 * <blockquote>
 * It [The single element annotation] is shorthand for the normal annotation:
 * {@code @TypeName(value = ElementValue)}
 * </blockquote>
 * <pre>{@code
 *     SingleElementAnnotation:
 *         @ TypeName ( ElementValue )
 * }<pre>
 */
  final public AnnotationExpr Annotation() throws ParseException {
    AnnotationExpr ret;
    Name name;
    NodeList<MemberValuePair> pairs = emptyNodeList();
    JavaToken begin;
    Expression memberVal;
    jj_consume_token(AT);
          begin=jpToken();
    name = Name();
    if (jj_2_52(2147483647)) {
      jj_consume_token(LPAREN);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case ENUM:
      case STRICTFP:
      case YIELD:
      case REQUIRES:
      case TO:
      case WITH:
      case OPEN:
      case OPENS:
      case USES:
      case MODULE:
      case EXPORTS:
      case PROVIDES:
      case TRANSITIVE:
      case IDENTIFIER:
        pairs = MemberValuePairs();
        break;
      default:
        jj_la1[150] = jj_gen;
        ;
      }
      jj_consume_token(RPAREN);
          ret = new NormalAnnotationExpr(range(begin, jpToken()), name, pairs);
    } else if (jj_2_53(2147483647)) {
      jj_consume_token(LPAREN);
      memberVal = MemberValue();
      jj_consume_token(RPAREN);
          ret = new SingleMemberAnnotationExpr(range(begin, jpToken()), name, memberVal);
    } else {
          ret = new MarkerAnnotationExpr(range(begin, jpToken()), name);
    }
      {if (true) return ret;}
    throw new Error("Missing return statement in function");
  }

/**
 * Note that {@code MemberValuePairs} (JavaParser) is synonymous with {@code ElementValuePairList} (JLS)
 * https://docs.oracle.com/javase/specs/jls/se15/html/jls-9.html#jls-9.7.1
 * <pre>{@code
 *     NormalAnnotation:
 *         @ TypeName ( [ElementValuePairList] )
 *     ElementValuePairList:
 *         ElementValuePair {, ElementValuePair}
 *     ElementValuePair:
 *         Identifier = ElementValue
 * }<pre>
 */
  final public NodeList<MemberValuePair> MemberValuePairs() throws ParseException {
    NodeList<MemberValuePair> ret = new NodeList<MemberValuePair>();
    MemberValuePair pair;
    pair = MemberValuePair();
                               ret.add(pair);
    label_52:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case COMMA:
        ;
        break;
      default:
        jj_la1[151] = jj_gen;
        break label_52;
      }
      jj_consume_token(COMMA);
      pair = MemberValuePair();
                                   ret.add(pair);
    }
      {if (true) return ret;}
    throw new Error("Missing return statement in function");
  }

/**
 * Note that {@code MemberValuePair} (JavaParser) is synonymous with {@code ElementValuePair} (JLS)
 * https://docs.oracle.com/javase/specs/jls/se15/html/jls-9.html#jls-9.7.1
 * <pre>{@code
 *     ElementValuePair:
 *         Identifier = ElementValue
 *     ElementValue:
 *         ConditionalExpression
 *         ElementValueArrayInitializer
 *         Annotation
 *     ElementValueArrayInitializer:
 *         { [ElementValueList] [,] }
 *     ElementValueList:
 *         ElementValue {, ElementValue}
 * }<pre>
 */
  final public MemberValuePair MemberValuePair() throws ParseException {
    SimpleName name;
    Expression value;
    JavaToken begin;
    name = SimpleName();
                          begin=jpToken();
    jj_consume_token(ASSIGN);
    value = MemberValue();
      {if (true) return new MemberValuePair(range(begin, jpToken()),name, value);}
    throw new Error("Missing return statement in function");
  }

/**
 * Note that {@code MemberValue} (JavaParser) is synonymous with {@code ElementValue} (JLS)
 * https://docs.oracle.com/javase/specs/jls/se15/html/jls-9.html#jls-9.7.1
 * https://docs.oracle.com/javase/specs/jls/se15/html/jls-9.html#jls-ElementValue
 * <pre>{@code
 *     ElementValue:
 *         ConditionalExpression
 *         ElementValueArrayInitializer
 *         Annotation
 *     ElementValueArrayInitializer:
 *         { [ElementValueList] [,] }
 *     ElementValueList:
 *         ElementValue {, ElementValue}
 * }<pre>
 */
  final public Expression MemberValue() throws ParseException {
    Expression ret;
    if (jj_2_54(2147483647)) {
      ret = Annotation();
    } else {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case LBRACE:
        ret = MemberValueArrayInitializer();
        break;
      case BOOLEAN:
      case BYTE:
      case CHAR:
      case DOUBLE:
      case ENUM:
      case FALSE:
      case FLOAT:
      case INT:
      case LONG:
      case NEW:
      case NULL:
      case SHORT:
      case STRICTFP:
      case SUPER:
      case SWITCH:
      case THIS:
      case TRUE:
      case VOID:
      case YIELD:
      case REQUIRES:
      case TO:
      case WITH:
      case OPEN:
      case OPENS:
      case USES:
      case MODULE:
      case EXPORTS:
      case PROVIDES:
      case TRANSITIVE:
      case LONG_LITERAL:
      case INTEGER_LITERAL:
      case FLOATING_POINT_LITERAL:
      case CHARACTER_LITERAL:
      case STRING_LITERAL:
      case TEXT_BLOCK_LITERAL:
      case IDENTIFIER:
      case LPAREN:
      case AT:
      case BANG:
      case TILDE:
      case INCR:
      case DECR:
      case PLUS:
      case MINUS:
        ret = ConditionalExpression();
        break;
      default:
        jj_la1[152] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
      {if (true) return ret;}
    throw new Error("Missing return statement in function");
  }

/**
 * Note that {@code MemberValueArrayInitializer} (JavaParser) is synonymous with {@code ElementValueArrayInitializer} (JLS)
 * https://docs.oracle.com/javase/specs/jls/se15/html/jls-9.html#jls-9.7.1
 * <pre>{@code
 *     ElementValueArrayInitializer:
 *         { [ElementValueList] [,] }
 *     ElementValueList:
 *         ElementValue {, ElementValue}
 * }<pre>
 */
  final public Expression MemberValueArrayInitializer() throws ParseException {
    NodeList<Expression> ret = emptyNodeList();
    Expression member;
    JavaToken begin;
    jj_consume_token(LBRACE);
          begin=jpToken();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case BOOLEAN:
    case BYTE:
    case CHAR:
    case DOUBLE:
    case ENUM:
    case FALSE:
    case FLOAT:
    case INT:
    case LONG:
    case NEW:
    case NULL:
    case SHORT:
    case STRICTFP:
    case SUPER:
    case SWITCH:
    case THIS:
    case TRUE:
    case VOID:
    case YIELD:
    case REQUIRES:
    case TO:
    case WITH:
    case OPEN:
    case OPENS:
    case USES:
    case MODULE:
    case EXPORTS:
    case PROVIDES:
    case TRANSITIVE:
    case LONG_LITERAL:
    case INTEGER_LITERAL:
    case FLOATING_POINT_LITERAL:
    case CHARACTER_LITERAL:
    case STRING_LITERAL:
    case TEXT_BLOCK_LITERAL:
    case IDENTIFIER:
    case LPAREN:
    case LBRACE:
    case AT:
    case BANG:
    case TILDE:
    case INCR:
    case DECR:
    case PLUS:
    case MINUS:
      member = MemberValue();
                                 ret.add(member);
      label_53:
      while (true) {
        if (jj_2_55(2)) {
          ;
        } else {
          break label_53;
        }
        jj_consume_token(COMMA);
        member = MemberValue();
                                     ret.add(member);
      }
      break;
    default:
      jj_la1[153] = jj_gen;
      ;
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case COMMA:
      jj_consume_token(COMMA);
      break;
    default:
      jj_la1[154] = jj_gen;
      ;
    }
    jj_consume_token(RBRACE);
      {if (true) return new ArrayInitializerExpr(range(begin, jpToken()),ret);}
    throw new Error("Missing return statement in function");
  }

/* Annotation Types. */

/**
 * <blockquote>
 * An annotation type declaration specifies a new annotation type, a special kind of interface type.
 * To distinguish an annotation type declaration from a normal interface declaration, the keyword interface is preceded by an at-sign (@).
 * </blockquote>
 * https://docs.oracle.com/javase/specs/jls/se15/html/jls-9.html#jls-9.6
 * <pre>{@code
 *     AnnotationTypeDeclaration:
 *         {InterfaceModifier} @ interface TypeIdentifier AnnotationTypeBody
 * }<pre>
 */
  final public AnnotationDeclaration AnnotationTypeDeclaration(ModifierHolder modifier) throws ParseException {
    SimpleName name;
    NodeList<BodyDeclaration<?>> members = emptyNodeList();
    JavaToken begin = modifier.begin;
    jj_consume_token(AT);
          begin=orIfInvalid(begin, jpToken());
    jj_consume_token(INTERFACE);
    name = SimpleName();
    members = AnnotationTypeBody();
      {if (true) return new AnnotationDeclaration(range(begin, jpToken()), modifier.modifiers, modifier.annotations, name, members);}
    throw new Error("Missing return statement in function");
  }

/**
 * https://docs.oracle.com/javase/specs/jls/se15/html/jls-9.html#jls-9.6.1
 * <pre>{@code
 *     AnnotationTypeBody:
 *         { {AnnotationTypeMemberDeclaration} }
 *     AnnotationTypeMemberDeclaration:
 *         AnnotationTypeElementDeclaration
 *         ConstantDeclaration
 *         ClassDeclaration
 *         InterfaceDeclaration
 *         ;
 * }<pre>
 */
  final public NodeList<BodyDeclaration<?>> AnnotationTypeBody() throws ParseException {
    NodeList<BodyDeclaration<?>> ret = emptyNodeList();
    BodyDeclaration member;
    jj_consume_token(LBRACE);
    label_54:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case ABSTRACT:
      case BOOLEAN:
      case BYTE:
      case CHAR:
      case CLASS:
      case _DEFAULT:
      case DOUBLE:
      case ENUM:
      case FINAL:
      case FLOAT:
      case INT:
      case INTERFACE:
      case LONG:
      case NATIVE:
      case PRIVATE:
      case PROTECTED:
      case PUBLIC:
      case SHORT:
      case STATIC:
      case STRICTFP:
      case SYNCHRONIZED:
      case TRANSIENT:
      case VOLATILE:
      case YIELD:
      case REQUIRES:
      case TO:
      case WITH:
      case OPEN:
      case OPENS:
      case USES:
      case MODULE:
      case EXPORTS:
      case PROVIDES:
      case TRANSITIVE:
      case IDENTIFIER:
      case SEMICOLON:
      case AT:
        ;
        break;
      default:
        jj_la1[155] = jj_gen;
        break label_54;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case ABSTRACT:
      case BOOLEAN:
      case BYTE:
      case CHAR:
      case CLASS:
      case _DEFAULT:
      case DOUBLE:
      case ENUM:
      case FINAL:
      case FLOAT:
      case INT:
      case INTERFACE:
      case LONG:
      case NATIVE:
      case PRIVATE:
      case PROTECTED:
      case PUBLIC:
      case SHORT:
      case STATIC:
      case STRICTFP:
      case SYNCHRONIZED:
      case TRANSIENT:
      case VOLATILE:
      case YIELD:
      case REQUIRES:
      case TO:
      case WITH:
      case OPEN:
      case OPENS:
      case USES:
      case MODULE:
      case EXPORTS:
      case PROVIDES:
      case TRANSITIVE:
      case IDENTIFIER:
      case AT:
        member = AnnotationBodyDeclaration();
                                               ret = addWhenNotNull(ret, member);
        break;
      case SEMICOLON:
        jj_consume_token(SEMICOLON);
        break;
      default:
        jj_la1[156] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
    jj_consume_token(RBRACE);
      {if (true) return ret;}
    throw new Error("Missing return statement in function");
  }

/**
 * Note that {@code AnnotationTypeMemberDeclaration} (JLS) and {@code AnnotationBodyDeclaration} (JavaParser) are synonymous.
 https://docs.oracle.com/javase/specs/jls/se15/html/jls-9.html#jls-9.6.1
 * <pre>{@code
 *     AnnotationTypeBody:
 *         { {AnnotationTypeMemberDeclaration} }
 *     AnnotationTypeMemberDeclaration:
 *         AnnotationTypeElementDeclaration
 *         ConstantDeclaration
 *         ClassDeclaration
 *         InterfaceDeclaration
 *         ;
 *     AnnotationTypeElementDeclaration:
 *         {AnnotationTypeElementModifier} UnannType Identifier ( ) [Dims] [DefaultValue] ;
 *     AnnotationTypeElementModifier:
 *         (one of)
 *         Annotation public
 *         abstract
 * }<pre>
 * For Convenience:
 * <pre>{@code
 *     Dims:
 *         {Annotation} [ ] {{Annotation} [ ]}
 * }<pre>
 */
  final public BodyDeclaration<?> AnnotationBodyDeclaration() throws ParseException {
    ModifierHolder modifier;
    BodyDeclaration ret;
    modifier = Modifiers();
    if (jj_2_56(2147483647)) {
      ret = AnnotationTypeMemberDeclaration(modifier);
    } else {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case CLASS:
      case INTERFACE:
        ret = ClassOrInterfaceDeclaration(modifier);
        break;
      default:
        jj_la1[157] = jj_gen;
        if (jj_2_57(2147483647)) {
          ret = EnumDeclaration(modifier);
        } else {
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case AT:
            ret = AnnotationTypeDeclaration(modifier);
            break;
          case BOOLEAN:
          case BYTE:
          case CHAR:
          case DOUBLE:
          case ENUM:
          case FLOAT:
          case INT:
          case LONG:
          case SHORT:
          case STRICTFP:
          case YIELD:
          case REQUIRES:
          case TO:
          case WITH:
          case OPEN:
          case OPENS:
          case USES:
          case MODULE:
          case EXPORTS:
          case PROVIDES:
          case TRANSITIVE:
          case IDENTIFIER:
            ret = FieldDeclaration(modifier);
            break;
          default:
            jj_la1[158] = jj_gen;
            jj_consume_token(-1);
            throw new ParseException();
          }
        }
      }
    }
      {if (true) return ret;}
    throw new Error("Missing return statement in function");
  }

/**
 * Note that {@code AnnotationTypeElementDeclaration} (JLS) and {@code AnnotationTypeMemberDeclaration} (JavaParser) are synonymous.
 * // TODO/FIXME: Consider missing `[Dims] (present in the JLS, but not the JavaParser grammar)
 * // TODO/FIXME: {AnnotationTypeElementModifier} UnannType Identifier ( ) [Dims] [DefaultValue] ;
 * https://docs.oracle.com/javase/specs/jls/se15/html/jls-9.html#jls-9.6.1
 * <pre>{@code
 *     AnnotationTypeElementDeclaration:
 *         {AnnotationTypeElementModifier} UnannType Identifier ( ) [Dims] [DefaultValue] ;
 *     AnnotationTypeElementModifier:
 *         (one of)
 *         Annotation public
 *         abstract
 * }<pre>
 * For Convenience:
 * <pre>{@code
 *     Dims:
 *         {Annotation} [ ] {{Annotation} [ ]}
 * }<pre>
 */
  final public AnnotationMemberDeclaration AnnotationTypeMemberDeclaration(ModifierHolder modifier) throws ParseException {
    Type type;
    SimpleName name;
    Expression defaultVal = null;
    // TODO/FIXME: Consider missing `[Dims] (present in the JLS, but not the JavaParser grammar)
        // TODO/FIXME: {AnnotationTypeElementModifier} UnannType Identifier ( ) [Dims] [DefaultValue] ;
        type = Type(emptyNodeList());
    name = SimpleName();
    jj_consume_token(LPAREN);
    jj_consume_token(RPAREN);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case _DEFAULT:
      defaultVal = DefaultValue();
      break;
    default:
      jj_la1[159] = jj_gen;
      ;
    }
    jj_consume_token(SEMICOLON);
        JavaToken begin = orIfInvalid(modifier.begin, type);
        {if (true) return new AnnotationMemberDeclaration(range(begin, jpToken()), modifier.modifiers, modifier.annotations, type, name, defaultVal);}
    throw new Error("Missing return statement in function");
  }

/**
 * https://docs.oracle.com/javase/specs/jls/se15/html/jls-9.html#jls-9.6.2
 * <pre>{@code
 *     DefaultValue:
 *     default ElementValue
 * }<pre>
 * For Convenience:
 * https://docs.oracle.com/javase/specs/jls/se15/html/jls-9.html#jls-9.7.1
 * https://docs.oracle.com/javase/specs/jls/se15/html/jls-9.html#jls-ElementValue
 * <pre>{@code
 *     ElementValue:
 *         ConditionalExpression
 *         ElementValueArrayInitializer
 *         Annotation
 *     ElementValueArrayInitializer:
 *         { [ElementValueList] [,] }
 *     ElementValueList:
 *         ElementValue {, ElementValue}
 * }<pre>
 */
  final public Expression DefaultValue() throws ParseException {
    Expression ret;
    jj_consume_token(_DEFAULT);
    ret = MemberValue();
      {if (true) return ret;}
    throw new Error("Missing return statement in function");
  }

/* Module syntax follows */


/**
 * https://docs.oracle.com/javase/specs/jls/se15/html/jls-7.html#jls-ModuleDirective
 * <pre>{@code
 *     ModuleDirective:
 *         requires {RequiresModifier} ModuleName ;
 *         exports PackageName [to ModuleName {, ModuleName}] ;
 *         opens PackageName [to ModuleName {, ModuleName}] ;
 *         uses TypeName ;
 *         provides TypeName with TypeName {, TypeName} ;
 *     RequiresModifier:
 *         (one of)
 *         transitive static
 * }<pre>
 */
  final public ModuleDirective ModuleDirective() throws ParseException {
    ModifierHolder modifiers;
    Name name;
    Name tmpName;
    NodeList<Name> names=emptyNodeList();
    JavaToken begin;
    ModuleDirective directive;
    JavaToken transitiveExceptionalToken;
    if (jj_2_58(2147483647)) {
      jj_consume_token(REQUIRES);
                     begin=jpToken();
      jj_consume_token(TRANSITIVE);
                      transitiveExceptionalToken=jpToken(); setTokenKind(IDENTIFIER);
      jj_consume_token(SEMICOLON);
          directive=new ModuleRequiresDirective(range(begin, jpToken()), new NodeList<Modifier>(), new Name(range(transitiveExceptionalToken, transitiveExceptionalToken), null, transitiveExceptionalToken.getText()));
    } else {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case REQUIRES:
        jj_consume_token(REQUIRES);
                     begin=jpToken();
        modifiers = Modifiers();
        name = Name();
        jj_consume_token(SEMICOLON);
          directive=new ModuleRequiresDirective(range(begin, jpToken()), modifiers.modifiers, name);
        break;
      case EXPORTS:
        jj_consume_token(EXPORTS);
                    begin=jpToken();
        name = Name();
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case TO:
          jj_consume_token(TO);
          tmpName = Name();
                             names.add(tmpName);
          label_55:
          while (true) {
            switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
            case COMMA:
              ;
              break;
            default:
              jj_la1[160] = jj_gen;
              break label_55;
            }
            jj_consume_token(COMMA);
            tmpName = Name();
                                names.add(tmpName);
          }
          break;
        default:
          jj_la1[161] = jj_gen;
          ;
        }
        jj_consume_token(SEMICOLON);
          directive=new ModuleExportsDirective(range(begin, jpToken()), name, names);
        break;
      case OPENS:
        jj_consume_token(OPENS);
                  begin=jpToken();
        name = Name();
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case TO:
          jj_consume_token(TO);
          tmpName = Name();
                             names.add(tmpName);
          label_56:
          while (true) {
            switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
            case COMMA:
              ;
              break;
            default:
              jj_la1[162] = jj_gen;
              break label_56;
            }
            jj_consume_token(COMMA);
            tmpName = Name();
                                 names.add(tmpName);
          }
          break;
        default:
          jj_la1[163] = jj_gen;
          ;
        }
        jj_consume_token(SEMICOLON);
          directive=new ModuleOpensDirective(range(begin, jpToken()), name, names);
        break;
      case USES:
        jj_consume_token(USES);
                 begin=jpToken();
        name = Name();
        jj_consume_token(SEMICOLON);
          directive=new ModuleUsesDirective(range(begin, jpToken()), name);
        break;
      case PROVIDES:
        jj_consume_token(PROVIDES);
                     begin=jpToken();
        name = Name();
        jj_consume_token(WITH);
        tmpName = Name();
                         names.add(tmpName);
        label_57:
        while (true) {
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case COMMA:
            ;
            break;
          default:
            jj_la1[164] = jj_gen;
            break label_57;
          }
          jj_consume_token(COMMA);
          tmpName = Name();
                             names.add(tmpName);
        }
        jj_consume_token(SEMICOLON);
          directive=new ModuleProvidesDirective(range(begin, jpToken()), name, names);
        break;
      default:
        jj_la1[165] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
      {if (true) return directive;}
    throw new Error("Missing return statement in function");
  }

/**
 * https://docs.oracle.com/javase/specs/jls/se15/html/jls-7.html#jls-7.7
 * <pre>{@code
 *     ModuleDeclaration:
 *         {Annotation} [open] module Identifier {. Identifier} { {ModuleDirective} }
 * }<pre>
 */
  final public ModuleDeclaration ModuleDeclaration(ModifierHolder modifier) throws ParseException {
    NodeList<ModuleDirective> directives = new NodeList<ModuleDirective>();
    boolean open=false;
    ModuleDirective directive;
    Name name;
    JavaToken begin = modifier.begin;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case OPEN:
      jj_consume_token(OPEN);
               open = true; begin = orIfInvalid(begin, jpToken());
      break;
    default:
      jj_la1[166] = jj_gen;
      ;
    }
    jj_consume_token(MODULE);
               begin = orIfInvalid(begin, jpToken());
    name = Name();
    jj_consume_token(LBRACE);
    label_58:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case REQUIRES:
      case OPENS:
      case USES:
      case EXPORTS:
      case PROVIDES:
        ;
        break;
      default:
        jj_la1[167] = jj_gen;
        break label_58;
      }
      directive = ModuleDirective();
                                        directives = add(directives, directive);
    }
    jj_consume_token(RBRACE);
      {if (true) return new ModuleDeclaration(range(begin, jpToken()), modifier.annotations, name, open, directives);}
    throw new Error("Missing return statement in function");
  }

/* Rules for matching partial inputs.
These rules are needed to properly terminate them -
if we simply use the usual rules, they will ignore everything in the provider
after they matched their desired input, which will lead to unexpected behaviour
*/
  final public BlockStmt BlockParseStart() throws ParseException {
  BlockStmt ret;
    ret = Block();
    jj_consume_token(0);
                        {if (true) return ret;}
    throw new Error("Missing return statement in function");
  }

  final public Statement BlockStatementParseStart() throws ParseException {
  Statement ret;
    if (jj_2_59(3)) {
      ret = BlockStatement();
    } else {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case BOOLEAN:
      case BYTE:
      case CHAR:
      case DOUBLE:
      case ENUM:
      case FALSE:
      case FLOAT:
      case INT:
      case LONG:
      case NEW:
      case NULL:
      case SHORT:
      case STRICTFP:
      case SUPER:
      case THIS:
      case TRUE:
      case VOID:
      case YIELD:
      case REQUIRES:
      case TO:
      case WITH:
      case OPEN:
      case OPENS:
      case USES:
      case MODULE:
      case EXPORTS:
      case PROVIDES:
      case TRANSITIVE:
      case LONG_LITERAL:
      case INTEGER_LITERAL:
      case FLOATING_POINT_LITERAL:
      case CHARACTER_LITERAL:
      case STRING_LITERAL:
      case TEXT_BLOCK_LITERAL:
      case IDENTIFIER:
      case LPAREN:
      case AT:
      case LT:
        ret = ExplicitConstructorInvocation();
        break;
      default:
        jj_la1[168] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
    jj_consume_token(0);
                                                                                      {if (true) return ret;}
    throw new Error("Missing return statement in function");
  }

  final public ImportDeclaration ImportDeclarationParseStart() throws ParseException {
  ImportDeclaration ret;
    ret = ImportDeclaration();
    jj_consume_token(0);
                                    {if (true) return ret;}
    throw new Error("Missing return statement in function");
  }

  final public Expression ExpressionParseStart() throws ParseException {
  Expression ret;
    ret = Expression();
    jj_consume_token(0);
                             {if (true) return ret;}
    throw new Error("Missing return statement in function");
  }

  final public AnnotationExpr AnnotationParseStart() throws ParseException {
  AnnotationExpr ret;
    ret = Annotation();
    jj_consume_token(0);
                             {if (true) return ret;}
    throw new Error("Missing return statement in function");
  }

  final public BodyDeclaration<?> AnnotationBodyDeclarationParseStart() throws ParseException {
  BodyDeclaration<?> ret;
    ret = AnnotationBodyDeclaration();
    jj_consume_token(0);
                                            {if (true) return ret;}
    throw new Error("Missing return statement in function");
  }

  final public BodyDeclaration<?> ClassOrInterfaceBodyDeclarationParseStart() throws ParseException {
  BodyDeclaration<?> ret;
    ret = ClassOrInterfaceBodyDeclaration();
    jj_consume_token(0);
                                                  {if (true) return ret;}
    throw new Error("Missing return statement in function");
  }

  final public ClassOrInterfaceType ClassOrInterfaceTypeParseStart() throws ParseException {
  ClassOrInterfaceType ret;
    ret = AnnotatedClassOrInterfaceType();
    jj_consume_token(0);
                                                {if (true) return ret;}
    throw new Error("Missing return statement in function");
  }

  final public Type ResultTypeParseStart() throws ParseException {
  NodeList<AnnotationExpr> annotations; Type ret;
    annotations = Annotations();
    ret = ResultType(annotations);
    jj_consume_token(0);
                                                                    {if (true) return ret;}
    throw new Error("Missing return statement in function");
  }

  final public VariableDeclarationExpr VariableDeclarationExpressionParseStart() throws ParseException {
  VariableDeclarationExpr ret;
    ret = VariableDeclarationExpression();
    jj_consume_token(0);
                                                {if (true) return ret;}
    throw new Error("Missing return statement in function");
  }

  final public ExplicitConstructorInvocationStmt ExplicitConstructorInvocationParseStart() throws ParseException {
  ExplicitConstructorInvocationStmt ret;
    ret = ExplicitConstructorInvocation();
    jj_consume_token(0);
                                                {if (true) return ret;}
    throw new Error("Missing return statement in function");
  }

  final public Name NameParseStart() throws ParseException {
  Name ret;
    ret = Name();
    jj_consume_token(0);
                       {if (true) return ret;}
    throw new Error("Missing return statement in function");
  }

  final public SimpleName SimpleNameParseStart() throws ParseException {
  SimpleName ret;
    ret = SimpleName();
    jj_consume_token(0);
                             {if (true) return ret;}
    throw new Error("Missing return statement in function");
  }

  final public Parameter ParameterParseStart() throws ParseException {
  Parameter ret;
    ret = Parameter();
    jj_consume_token(0);
                            {if (true) return ret;}
    throw new Error("Missing return statement in function");
  }

  final public PackageDeclaration PackageDeclarationParseStart() throws ParseException {
  PackageDeclaration ret;
    ret = PackageDeclaration();
    jj_consume_token(0);
                                     {if (true) return ret;}
    throw new Error("Missing return statement in function");
  }

  final public TypeDeclaration<?> TypeDeclarationParseStart() throws ParseException {
    TypeDeclaration<?> ret;
    ModifierHolder modifier;
    modifier = Modifiers();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case CLASS:
    case INTERFACE:
      ret = ClassOrInterfaceDeclaration(modifier);
      break;
    case ENUM:
      ret = EnumDeclaration(modifier);
      break;
    case AT:
      ret = AnnotationTypeDeclaration(modifier);
      break;
    default:
      jj_la1[169] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    jj_consume_token(0);
     {if (true) return ret;}
    throw new Error("Missing return statement in function");
  }

  final public ModuleDeclaration ModuleDeclarationParseStart() throws ParseException {
    ModuleDeclaration ret;
    ModifierHolder modifiers;
    modifiers = Modifiers();
    ret = ModuleDeclaration(modifiers);
    jj_consume_token(0);
      {if (true) return ret;}
    throw new Error("Missing return statement in function");
  }

  final public ModuleDirective ModuleDirectiveParseStart() throws ParseException {
  ModuleDirective ret;
    ret = ModuleDirective();
    jj_consume_token(0);
                                  {if (true) return ret;}
    throw new Error("Missing return statement in function");
  }

  final public TypeParameter TypeParameterParseStart() throws ParseException {
    TypeParameter ret;
    NodeList<AnnotationExpr> annotations;
    annotations = Annotations();
    ret = TypeParameter(annotations);
    jj_consume_token(0);
      {if (true) return ret;}
    throw new Error("Missing return statement in function");
  }

  final public MethodDeclaration MethodDeclarationParseStart() throws ParseException {
    MethodDeclaration ret;
    ModifierHolder modifier;
    modifier = Modifiers();
    ret = MethodDeclaration(modifier);
    jj_consume_token(0);
      {if (true) return ret;}
    throw new Error("Missing return statement in function");
  }

  private boolean jj_2_1(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_1(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(0, xla); }
  }

  private boolean jj_2_2(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_2(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(1, xla); }
  }

  private boolean jj_2_3(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_3(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(2, xla); }
  }

  private boolean jj_2_4(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_4(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(3, xla); }
  }

  private boolean jj_2_5(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_5(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(4, xla); }
  }

  private boolean jj_2_6(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_6(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(5, xla); }
  }

  private boolean jj_2_7(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_7(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(6, xla); }
  }

  private boolean jj_2_8(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_8(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(7, xla); }
  }

  private boolean jj_2_9(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_9(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(8, xla); }
  }

  private boolean jj_2_10(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_10(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(9, xla); }
  }

  private boolean jj_2_11(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_11(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(10, xla); }
  }

  private boolean jj_2_12(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_12(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(11, xla); }
  }

  private boolean jj_2_13(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_13(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(12, xla); }
  }

  private boolean jj_2_14(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_14(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(13, xla); }
  }

  private boolean jj_2_15(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_15(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(14, xla); }
  }

  private boolean jj_2_16(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_16(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(15, xla); }
  }

  private boolean jj_2_17(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_17(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(16, xla); }
  }

  private boolean jj_2_18(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_18(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(17, xla); }
  }

  private boolean jj_2_19(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_19(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(18, xla); }
  }

  private boolean jj_2_20(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_20(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(19, xla); }
  }

  private boolean jj_2_21(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_21(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(20, xla); }
  }

  private boolean jj_2_22(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_22(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(21, xla); }
  }

  private boolean jj_2_23(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_23(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(22, xla); }
  }

  private boolean jj_2_24(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_24(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(23, xla); }
  }

  private boolean jj_2_25(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_25(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(24, xla); }
  }

  private boolean jj_2_26(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_26(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(25, xla); }
  }

  private boolean jj_2_27(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_27(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(26, xla); }
  }

  private boolean jj_2_28(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_28(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(27, xla); }
  }

  private boolean jj_2_29(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_29(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(28, xla); }
  }

  private boolean jj_2_30(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_30(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(29, xla); }
  }

  private boolean jj_2_31(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_31(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(30, xla); }
  }

  private boolean jj_2_32(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_32(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(31, xla); }
  }

  private boolean jj_2_33(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_33(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(32, xla); }
  }

  private boolean jj_2_34(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_34(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(33, xla); }
  }

  private boolean jj_2_35(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_35(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(34, xla); }
  }

  private boolean jj_2_36(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_36(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(35, xla); }
  }

  private boolean jj_2_37(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_37(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(36, xla); }
  }

  private boolean jj_2_38(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_38(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(37, xla); }
  }

  private boolean jj_2_39(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_39(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(38, xla); }
  }

  private boolean jj_2_40(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_40(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(39, xla); }
  }

  private boolean jj_2_41(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_41(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(40, xla); }
  }

  private boolean jj_2_42(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_42(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(41, xla); }
  }

  private boolean jj_2_43(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_43(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(42, xla); }
  }

  private boolean jj_2_44(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_44(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(43, xla); }
  }

  private boolean jj_2_45(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_45(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(44, xla); }
  }

  private boolean jj_2_46(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_46(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(45, xla); }
  }

  private boolean jj_2_47(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_47(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(46, xla); }
  }

  private boolean jj_2_48(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_48(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(47, xla); }
  }

  private boolean jj_2_49(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_49(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(48, xla); }
  }

  private boolean jj_2_50(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_50(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(49, xla); }
  }

  private boolean jj_2_51(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_51(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(50, xla); }
  }

  private boolean jj_2_52(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_52(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(51, xla); }
  }

  private boolean jj_2_53(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_53(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(52, xla); }
  }

  private boolean jj_2_54(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_54(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(53, xla); }
  }

  private boolean jj_2_55(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_55(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(54, xla); }
  }

  private boolean jj_2_56(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_56(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(55, xla); }
  }

  private boolean jj_2_57(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_57(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(56, xla); }
  }

  private boolean jj_2_58(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_58(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(57, xla); }
  }

  private boolean jj_2_59(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_59(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(58, xla); }
  }

  private boolean jj_3R_327() {
    if (jj_3R_90()) return true;
    return false;
  }

  private boolean jj_3R_298() {
    if (jj_scan_token(CONTINUE)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_327()) jj_scanpos = xsp;
    if (jj_scan_token(SEMICOLON)) return true;
    return false;
  }

  private boolean jj_3R_396() {
    if (jj_scan_token(NE)) return true;
    return false;
  }

  private boolean jj_3R_180() {
    if (jj_scan_token(COMMA)) return true;
    if (jj_3R_88()) return true;
    if (jj_3R_179()) return true;
    return false;
  }

  private boolean jj_3R_395() {
    if (jj_scan_token(EQ)) return true;
    return false;
  }

  private boolean jj_3R_391() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_395()) {
    jj_scanpos = xsp;
    if (jj_3R_396()) return true;
    }
    if (jj_3R_382()) return true;
    return false;
  }

  private boolean jj_3R_120() {
    if (jj_scan_token(LT)) return true;
    if (jj_3R_88()) return true;
    if (jj_3R_179()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_180()) { jj_scanpos = xsp; break; }
    }
    if (jj_scan_token(GT)) return true;
    return false;
  }

  private boolean jj_3_39() {
    if (jj_3R_107()) return true;
    return false;
  }

  private boolean jj_3R_110() {
    if (jj_scan_token(YIELD)) return true;
    if (jj_3R_92()) return true;
    if (jj_scan_token(SEMICOLON)) return true;
    return false;
  }

  private boolean jj_3R_372() {
    if (jj_3R_382()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_391()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  private boolean jj_3R_323() {
    if (jj_3R_185()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3_39()) jj_scanpos = xsp;
    return false;
  }

  private boolean jj_3_14() {
    if (jj_3R_84()) return true;
    if (jj_scan_token(DOT)) return true;
    return false;
  }

  private boolean jj_3R_322() {
    if (jj_3R_321()) return true;
    return false;
  }

  private boolean jj_3R_187() {
    if (jj_3R_89()) return true;
    return false;
  }

  private boolean jj_3R_288() {
    if (jj_3R_199()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_322()) {
    jj_scanpos = xsp;
    if (jj_3R_323()) return true;
    }
    return false;
  }

  private boolean jj_3R_85() {
    if (jj_3R_89()) return true;
    return false;
  }

  private boolean jj_3R_186() {
    if (jj_3R_84()) return true;
    if (jj_scan_token(DOT)) return true;
    return false;
  }

  private boolean jj_3_15() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_85()) jj_scanpos = xsp;
    if (jj_scan_token(THIS)) return true;
    if (jj_scan_token(LPAREN)) return true;
    return false;
  }

  private boolean jj_3R_326() {
    if (jj_3R_90()) return true;
    return false;
  }

  private boolean jj_3R_287() {
    if (jj_3R_99()) return true;
    if (jj_3R_321()) return true;
    return false;
  }

  private boolean jj_3R_297() {
    if (jj_scan_token(BREAK)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_326()) jj_scanpos = xsp;
    if (jj_scan_token(SEMICOLON)) return true;
    return false;
  }

  private boolean jj_3R_129() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_186()) jj_scanpos = xsp;
    xsp = jj_scanpos;
    if (jj_3R_187()) jj_scanpos = xsp;
    if (jj_scan_token(SUPER)) return true;
    if (jj_3R_185()) return true;
    if (jj_scan_token(SEMICOLON)) return true;
    return false;
  }

  private boolean jj_3R_184() {
    if (jj_3R_89()) return true;
    return false;
  }

  private boolean jj_3R_286() {
    if (jj_3R_89()) return true;
    return false;
  }

  private boolean jj_3R_128() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_184()) jj_scanpos = xsp;
    if (jj_scan_token(THIS)) return true;
    if (jj_3R_185()) return true;
    if (jj_scan_token(SEMICOLON)) return true;
    return false;
  }

  private boolean jj_3_58() {
    if (jj_scan_token(REQUIRES)) return true;
    if (jj_scan_token(TRANSITIVE)) return true;
    if (jj_scan_token(SEMICOLON)) return true;
    return false;
  }

  private boolean jj_3R_225() {
    if (jj_scan_token(NEW)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_286()) jj_scanpos = xsp;
    if (jj_3R_88()) return true;
    xsp = jj_scanpos;
    if (jj_3R_287()) {
    jj_scanpos = xsp;
    if (jj_3R_288()) return true;
    }
    return false;
  }

  private boolean jj_3R_83() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_128()) {
    jj_scanpos = xsp;
    if (jj_3R_129()) return true;
    }
    return false;
  }

  private boolean jj_3R_387() {
    if (jj_scan_token(BIT_AND)) return true;
    if (jj_3R_372()) return true;
    return false;
  }

  private boolean jj_3R_434() {
    if (jj_3R_107()) return true;
    return false;
  }

  private boolean jj_3R_433() {
    if (jj_3R_185()) return true;
    return false;
  }

  private boolean jj_3R_445() {
    if (jj_3R_392()) return true;
    return false;
  }

  private boolean jj_3R_119() {
    if (jj_3R_118()) return true;
    return false;
  }

  private boolean jj_3R_355() {
    if (jj_3R_372()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_387()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  private boolean jj_3R_74() {
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_119()) { jj_scanpos = xsp; break; }
    }
    if (jj_3R_90()) return true;
    xsp = jj_scanpos;
    if (jj_3R_433()) jj_scanpos = xsp;
    xsp = jj_scanpos;
    if (jj_3R_434()) jj_scanpos = xsp;
    return false;
  }

  private boolean jj_3_13() {
    if (jj_3R_83()) return true;
    return false;
  }

  private boolean jj_3R_453() {
    if (jj_scan_token(COMMA)) return true;
    if (jj_3R_92()) return true;
    return false;
  }

  private boolean jj_3R_379() {
    if (jj_scan_token(XOR)) return true;
    if (jj_3R_355()) return true;
    return false;
  }

  private boolean jj_3R_435() {
    if (jj_3R_260()) return true;
    return false;
  }

  private boolean jj_3R_419() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_435()) {
    jj_scanpos = xsp;
    if (jj_scan_token(102)) return true;
    }
    return false;
  }

  private boolean jj_3R_411() {
    if (jj_3R_83()) return true;
    return false;
  }

  private boolean jj_3R_392() {
    if (jj_3R_92()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_453()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  private boolean jj_3R_331() {
    if (jj_3R_355()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_379()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  private boolean jj_3R_422() {
    if (jj_scan_token(COMMA)) return true;
    if (jj_3R_253()) return true;
    return false;
  }

  private boolean jj_3R_410() {
    if (jj_scan_token(THROWS)) return true;
    if (jj_3R_253()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_422()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  private boolean jj_3R_407() {
    if (jj_scan_token(SEMICOLON)) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_419()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  private boolean jj_3R_455() {
    if (jj_scan_token(_DEFAULT)) return true;
    if (jj_3R_117()) return true;
    return false;
  }

  private boolean jj_3_4() {
    if (jj_scan_token(COMMA)) return true;
    if (jj_3R_74()) return true;
    return false;
  }

  private boolean jj_3R_406() {
    if (jj_3R_74()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3_4()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  private boolean jj_3R_316() {
    if (jj_scan_token(COMMA)) return true;
    if (jj_3R_92()) return true;
    return false;
  }

  private boolean jj_3R_377() {
    if (jj_3R_120()) return true;
    return false;
  }

  private boolean jj_3R_361() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_377()) jj_scanpos = xsp;
    if (jj_3R_90()) return true;
    if (jj_3R_409()) return true;
    xsp = jj_scanpos;
    if (jj_3R_410()) jj_scanpos = xsp;
    if (jj_scan_token(LBRACE)) return true;
    xsp = jj_scanpos;
    if (jj_3R_411()) jj_scanpos = xsp;
    if (jj_3R_181()) return true;
    if (jj_scan_token(RBRACE)) return true;
    return false;
  }

  private boolean jj_3_47() {
    if (jj_3R_111()) return true;
    if (jj_3R_77()) return true;
    if (jj_3R_76()) return true;
    return false;
  }

  private boolean jj_3R_405() {
    if (jj_3R_313()) return true;
    return false;
  }

  private boolean jj_3R_271() {
    if (jj_3R_92()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_316()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  private boolean jj_3R_359() {
    if (jj_scan_token(ENUM)) return true;
    if (jj_3R_90()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_405()) jj_scanpos = xsp;
    if (jj_scan_token(LBRACE)) return true;
    xsp = jj_scanpos;
    if (jj_3R_406()) jj_scanpos = xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(103)) jj_scanpos = xsp;
    xsp = jj_scanpos;
    if (jj_3R_407()) jj_scanpos = xsp;
    if (jj_scan_token(RBRACE)) return true;
    return false;
  }

  private boolean jj_3R_389() {
    if (jj_3R_392()) return true;
    return false;
  }

  private boolean jj_3R_388() {
    if (jj_3R_112()) return true;
    return false;
  }

  private boolean jj_3R_364() {
    if (jj_scan_token(BIT_OR)) return true;
    if (jj_3R_331()) return true;
    return false;
  }

  private boolean jj_3R_380() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_388()) {
    jj_scanpos = xsp;
    if (jj_3R_389()) return true;
    }
    return false;
  }

  private boolean jj_3R_217() {
    if (jj_3R_271()) return true;
    return false;
  }

  private boolean jj_3R_305() {
    if (jj_3R_331()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_364()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  private boolean jj_3R_185() {
    if (jj_scan_token(LPAREN)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_217()) jj_scanpos = xsp;
    if (jj_scan_token(RPAREN)) return true;
    return false;
  }

  private boolean jj_3R_454() {
    if (jj_3R_455()) return true;
    return false;
  }

  private boolean jj_3_12() {
    if (jj_3R_82()) return true;
    return false;
  }

  private boolean jj_3R_452() {
    if (jj_3R_77()) return true;
    if (jj_3R_90()) return true;
    if (jj_scan_token(LPAREN)) return true;
    if (jj_scan_token(RPAREN)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_454()) jj_scanpos = xsp;
    if (jj_scan_token(SEMICOLON)) return true;
    return false;
  }

  private boolean jj_3R_183() {
    if (jj_3R_82()) return true;
    if (jj_scan_token(DOT)) return true;
    return false;
  }

  private boolean jj_3R_425() {
    if (jj_scan_token(COMMA)) return true;
    if (jj_3R_314()) return true;
    return false;
  }

  private boolean jj_3R_127() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_183()) jj_scanpos = xsp;
    if (jj_scan_token(THIS)) return true;
    return false;
  }

  private boolean jj_3R_313() {
    if (jj_scan_token(IMPLEMENTS)) return true;
    if (jj_3R_314()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_425()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  private boolean jj_3R_342() {
    if (jj_scan_token(SC_AND)) return true;
    if (jj_3R_305()) return true;
    return false;
  }

  private boolean jj_3R_318() {
    if (jj_scan_token(NULL)) return true;
    return false;
  }

  private boolean jj_3R_441() {
    if (jj_3R_445()) return true;
    return false;
  }

  private boolean jj_3R_440() {
    if (jj_3R_92()) return true;
    return false;
  }

  private boolean jj_3_46() {
    if (jj_3R_112()) return true;
    if (jj_scan_token(COLON)) return true;
    return false;
  }

  private boolean jj_3R_365() {
    if (jj_3R_380()) return true;
    return false;
  }

  private boolean jj_3R_252() {
    if (jj_3R_305()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_342()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  private boolean jj_3R_346() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_365()) jj_scanpos = xsp;
    if (jj_scan_token(SEMICOLON)) return true;
    xsp = jj_scanpos;
    if (jj_3R_440()) jj_scanpos = xsp;
    if (jj_scan_token(SEMICOLON)) return true;
    xsp = jj_scanpos;
    if (jj_3R_441()) jj_scanpos = xsp;
    return false;
  }

  private boolean jj_3_57() {
    if (jj_scan_token(ENUM)) return true;
    return false;
  }

  private boolean jj_3R_348() {
    if (jj_scan_token(FALSE)) return true;
    return false;
  }

  private boolean jj_3R_347() {
    if (jj_scan_token(TRUE)) return true;
    return false;
  }

  private boolean jj_3R_345() {
    if (jj_3R_112()) return true;
    if (jj_scan_token(COLON)) return true;
    if (jj_3R_92()) return true;
    return false;
  }

  private boolean jj_3R_451() {
    if (jj_3R_362()) return true;
    return false;
  }

  private boolean jj_3_56() {
    if (jj_3R_77()) return true;
    if (jj_3R_76()) return true;
    if (jj_scan_token(LPAREN)) return true;
    return false;
  }

  private boolean jj_3R_450() {
    if (jj_3R_360()) return true;
    return false;
  }

  private boolean jj_3R_317() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_347()) {
    jj_scanpos = xsp;
    if (jj_3R_348()) return true;
    }
    return false;
  }

  private boolean jj_3R_449() {
    if (jj_3R_359()) return true;
    return false;
  }

  private boolean jj_3R_81() {
    if (jj_3R_88()) return true;
    if (jj_3R_77()) return true;
    if (jj_3R_127()) return true;
    return false;
  }

  private boolean jj_3R_448() {
    if (jj_3R_196()) return true;
    return false;
  }

  private boolean jj_3R_296() {
    if (jj_scan_token(FOR)) return true;
    if (jj_scan_token(LPAREN)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_345()) {
    jj_scanpos = xsp;
    if (jj_3R_346()) return true;
    }
    if (jj_scan_token(RPAREN)) return true;
    if (jj_3R_197()) return true;
    return false;
  }

  private boolean jj_3R_447() {
    if (jj_3R_452()) return true;
    return false;
  }

  private boolean jj_3R_424() {
    if (jj_scan_token(COMMA)) return true;
    if (jj_3R_314()) return true;
    return false;
  }

  private boolean jj_3R_444() {
    if (jj_3R_111()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_447()) {
    jj_scanpos = xsp;
    if (jj_3R_448()) {
    jj_scanpos = xsp;
    if (jj_3R_449()) {
    jj_scanpos = xsp;
    if (jj_3R_450()) {
    jj_scanpos = xsp;
    if (jj_3R_451()) return true;
    }
    }
    }
    }
    return false;
  }

  private boolean jj_3R_312() {
    if (jj_scan_token(EXTENDS)) return true;
    if (jj_3R_314()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_424()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  private boolean jj_3R_279() {
    if (jj_3R_318()) return true;
    return false;
  }

  private boolean jj_3R_278() {
    if (jj_3R_317()) return true;
    return false;
  }

  private boolean jj_3R_277() {
    if (jj_scan_token(TEXT_BLOCK_LITERAL)) return true;
    return false;
  }

  private boolean jj_3R_276() {
    if (jj_scan_token(STRING_LITERAL)) return true;
    return false;
  }

  private boolean jj_3R_311() {
    if (jj_scan_token(SC_OR)) return true;
    if (jj_3R_252()) return true;
    return false;
  }

  private boolean jj_3R_275() {
    if (jj_scan_token(CHARACTER_LITERAL)) return true;
    return false;
  }

  private boolean jj_3R_274() {
    if (jj_scan_token(FLOATING_POINT_LITERAL)) return true;
    return false;
  }

  private boolean jj_3R_166() {
    if (jj_3R_88()) return true;
    if (jj_scan_token(ELLIPSIS)) return true;
    return false;
  }

  private boolean jj_3R_273() {
    if (jj_scan_token(LONG_LITERAL)) return true;
    return false;
  }

  private boolean jj_3R_202() {
    if (jj_3R_252()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_311()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  private boolean jj_3R_272() {
    if (jj_scan_token(INTEGER_LITERAL)) return true;
    return false;
  }

  private boolean jj_3R_102() {
    if (jj_3R_111()) return true;
    if (jj_3R_77()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_166()) jj_scanpos = xsp;
    if (jj_3R_103()) return true;
    return false;
  }

  private boolean jj_3R_218() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_272()) {
    jj_scanpos = xsp;
    if (jj_3R_273()) {
    jj_scanpos = xsp;
    if (jj_3R_274()) {
    jj_scanpos = xsp;
    if (jj_3R_275()) {
    jj_scanpos = xsp;
    if (jj_3R_276()) {
    jj_scanpos = xsp;
    if (jj_3R_277()) {
    jj_scanpos = xsp;
    if (jj_3R_278()) {
    jj_scanpos = xsp;
    if (jj_3R_279()) return true;
    }
    }
    }
    }
    }
    }
    }
    return false;
  }

  private boolean jj_3R_295() {
    if (jj_scan_token(DO)) return true;
    if (jj_3R_197()) return true;
    if (jj_scan_token(WHILE)) return true;
    if (jj_scan_token(LPAREN)) return true;
    if (jj_3R_92()) return true;
    if (jj_scan_token(RPAREN)) return true;
    if (jj_scan_token(SEMICOLON)) return true;
    return false;
  }

  private boolean jj_3R_269() {
    if (jj_3R_313()) return true;
    return false;
  }

  private boolean jj_3R_436() {
    if (jj_3R_444()) return true;
    return false;
  }

  private boolean jj_3R_420() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_436()) {
    jj_scanpos = xsp;
    if (jj_scan_token(102)) return true;
    }
    return false;
  }

  private boolean jj_3R_268() {
    if (jj_3R_312()) return true;
    return false;
  }

  private boolean jj_3R_267() {
    if (jj_3R_120()) return true;
    return false;
  }

  private boolean jj_3R_231() {
    if (jj_scan_token(INTERFACE)) return true;
    return false;
  }

  private boolean jj_3R_230() {
    if (jj_scan_token(CLASS)) return true;
    return false;
  }

  private boolean jj_3R_106() {
    if (jj_3R_89()) return true;
    return false;
  }

  private boolean jj_3R_408() {
    if (jj_scan_token(LBRACE)) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_420()) { jj_scanpos = xsp; break; }
    }
    if (jj_scan_token(RBRACE)) return true;
    return false;
  }

  private boolean jj_3R_261() {
    if (jj_scan_token(HOOK)) return true;
    if (jj_3R_92()) return true;
    if (jj_scan_token(COLON)) return true;
    if (jj_3R_151()) return true;
    return false;
  }

  private boolean jj_3_38() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_106()) jj_scanpos = xsp;
    if (jj_3R_76()) return true;
    return false;
  }

  private boolean jj_3R_320() {
    if (jj_scan_token(COMMA)) return true;
    if (jj_3R_103()) return true;
    return false;
  }

  private boolean jj_3R_165() {
    if (jj_scan_token(LBRACKET)) return true;
    if (jj_3R_92()) return true;
    if (jj_scan_token(RBRACKET)) return true;
    return false;
  }

  private boolean jj_3R_294() {
    if (jj_scan_token(WHILE)) return true;
    if (jj_scan_token(LPAREN)) return true;
    if (jj_3R_92()) return true;
    if (jj_scan_token(RPAREN)) return true;
    if (jj_3R_197()) return true;
    return false;
  }

  private boolean jj_3R_196() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_230()) {
    jj_scanpos = xsp;
    if (jj_3R_231()) return true;
    }
    if (jj_3R_90()) return true;
    xsp = jj_scanpos;
    if (jj_3R_267()) jj_scanpos = xsp;
    xsp = jj_scanpos;
    if (jj_3R_268()) jj_scanpos = xsp;
    xsp = jj_scanpos;
    if (jj_3R_269()) jj_scanpos = xsp;
    if (jj_3R_107()) return true;
    return false;
  }

  private boolean jj_3R_151() {
    if (jj_3R_202()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_261()) jj_scanpos = xsp;
    return false;
  }

  private boolean jj_3R_259() {
    if (jj_3R_185()) return true;
    return false;
  }

  private boolean jj_3R_285() {
    if (jj_3R_103()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_320()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  private boolean jj_3R_258() {
    if (jj_3R_89()) return true;
    return false;
  }

  private boolean jj_3R_207() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_258()) jj_scanpos = xsp;
    if (jj_3R_90()) return true;
    xsp = jj_scanpos;
    if (jj_3R_259()) jj_scanpos = xsp;
    return false;
  }

  private boolean jj_3R_206() {
    if (jj_3R_225()) return true;
    return false;
  }

  private boolean jj_3R_205() {
    if (jj_scan_token(THIS)) return true;
    return false;
  }

  private boolean jj_3R_164() {
    if (jj_scan_token(DOT)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_205()) {
    jj_scanpos = xsp;
    if (jj_3R_206()) {
    jj_scanpos = xsp;
    if (jj_3R_207()) return true;
    }
    }
    return false;
  }

  private boolean jj_3R_427() {
    if (jj_scan_token(ELSE)) return true;
    if (jj_3R_197()) return true;
    return false;
  }

  private boolean jj_3R_150() {
    if (jj_scan_token(ORASSIGN)) return true;
    return false;
  }

  private boolean jj_3R_360() {
    if (jj_scan_token(AT)) return true;
    if (jj_scan_token(INTERFACE)) return true;
    if (jj_3R_90()) return true;
    if (jj_3R_408()) return true;
    return false;
  }

  private boolean jj_3R_149() {
    if (jj_scan_token(XORASSIGN)) return true;
    return false;
  }

  private boolean jj_3R_148() {
    if (jj_scan_token(ANDASSIGN)) return true;
    return false;
  }

  private boolean jj_3R_147() {
    if (jj_scan_token(RUNSIGNEDSHIFTASSIGN)) return true;
    return false;
  }

  private boolean jj_3R_101() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_164()) {
    jj_scanpos = xsp;
    if (jj_3R_165()) return true;
    }
    return false;
  }

  private boolean jj_3R_146() {
    if (jj_scan_token(RSIGNEDSHIFTASSIGN)) return true;
    return false;
  }

  private boolean jj_3R_145() {
    if (jj_scan_token(LSHIFTASSIGN)) return true;
    return false;
  }

  private boolean jj_3R_144() {
    if (jj_scan_token(MINUSASSIGN)) return true;
    return false;
  }

  private boolean jj_3R_143() {
    if (jj_scan_token(PLUSASSIGN)) return true;
    return false;
  }

  private boolean jj_3R_142() {
    if (jj_scan_token(REMASSIGN)) return true;
    return false;
  }

  private boolean jj_3R_141() {
    if (jj_scan_token(SLASHASSIGN)) return true;
    return false;
  }

  private boolean jj_3R_293() {
    if (jj_scan_token(IF)) return true;
    if (jj_scan_token(LPAREN)) return true;
    if (jj_3R_92()) return true;
    if (jj_scan_token(RPAREN)) return true;
    if (jj_3R_197()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_427()) jj_scanpos = xsp;
    return false;
  }

  private boolean jj_3R_140() {
    if (jj_scan_token(STARASSIGN)) return true;
    return false;
  }

  private boolean jj_3R_139() {
    if (jj_scan_token(ASSIGN)) return true;
    return false;
  }

  private boolean jj_3R_91() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_139()) {
    jj_scanpos = xsp;
    if (jj_3R_140()) {
    jj_scanpos = xsp;
    if (jj_3R_141()) {
    jj_scanpos = xsp;
    if (jj_3R_142()) {
    jj_scanpos = xsp;
    if (jj_3R_143()) {
    jj_scanpos = xsp;
    if (jj_3R_144()) {
    jj_scanpos = xsp;
    if (jj_3R_145()) {
    jj_scanpos = xsp;
    if (jj_3R_146()) {
    jj_scanpos = xsp;
    if (jj_3R_147()) {
    jj_scanpos = xsp;
    if (jj_3R_148()) {
    jj_scanpos = xsp;
    if (jj_3R_149()) {
    jj_scanpos = xsp;
    if (jj_3R_150()) return true;
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    return false;
  }

  private boolean jj_3R_163() {
    if (jj_scan_token(DOT)) return true;
    if (jj_scan_token(SUPER)) return true;
    return false;
  }

  private boolean jj_3R_73() {
    if (jj_3R_118()) return true;
    return false;
  }

  private boolean jj_3_37() {
    if (jj_3R_101()) return true;
    return false;
  }

  private boolean jj_3R_319() {
    if (jj_scan_token(COMMA)) return true;
    if (jj_3R_102()) return true;
    return false;
  }

  private boolean jj_3R_72() {
    if (jj_scan_token(_DEFAULT)) return true;
    return false;
  }

  private boolean jj_3_55() {
    if (jj_scan_token(COMMA)) return true;
    if (jj_3R_117()) return true;
    return false;
  }

  private boolean jj_3R_71() {
    if (jj_scan_token(TRANSITIVE)) return true;
    return false;
  }

  private boolean jj_3R_284() {
    if (jj_3R_102()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_319()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  private boolean jj_3R_100() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3_37()) {
    jj_scanpos = xsp;
    if (jj_3R_163()) return true;
    }
    return false;
  }

  private boolean jj_3R_70() {
    if (jj_scan_token(STRICTFP)) return true;
    return false;
  }

  private boolean jj_3R_371() {
    if (jj_3R_117()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3_55()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  private boolean jj_3R_69() {
    if (jj_scan_token(VOLATILE)) return true;
    return false;
  }

  private boolean jj_3R_68() {
    if (jj_scan_token(TRANSIENT)) return true;
    return false;
  }

  private boolean jj_3R_67() {
    if (jj_scan_token(NATIVE)) return true;
    return false;
  }

  private boolean jj_3R_335() {
    if (jj_3R_76()) return true;
    return false;
  }

  private boolean jj_3R_66() {
    if (jj_scan_token(SYNCHRONIZED)) return true;
    return false;
  }

  private boolean jj_3R_215() {
    if (jj_scan_token(LBRACE)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_371()) jj_scanpos = xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(103)) jj_scanpos = xsp;
    if (jj_scan_token(RBRACE)) return true;
    return false;
  }

  private boolean jj_3R_386() {
    if (jj_3R_300()) return true;
    return false;
  }

  private boolean jj_3R_334() {
    if (jj_3R_89()) return true;
    return false;
  }

  private boolean jj_3R_65() {
    if (jj_scan_token(ABSTRACT)) return true;
    return false;
  }

  private boolean jj_3R_263() {
    if (jj_scan_token(DOUBLECOLON)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_334()) jj_scanpos = xsp;
    xsp = jj_scanpos;
    if (jj_3R_335()) {
    jj_scanpos = xsp;
    if (jj_scan_token(42)) return true;
    }
    return false;
  }

  private boolean jj_3R_64() {
    if (jj_scan_token(FINAL)) return true;
    return false;
  }

  private boolean jj_3R_228() {
    if (jj_3R_185()) return true;
    return false;
  }

  private boolean jj_3R_63() {
    if (jj_scan_token(PRIVATE)) return true;
    return false;
  }

  private boolean jj_3_36() {
    if (jj_3R_105()) return true;
    if (jj_scan_token(DOUBLECOLON)) return true;
    return false;
  }

  private boolean jj_3R_195() {
    if (jj_3R_90()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_228()) jj_scanpos = xsp;
    return false;
  }

  private boolean jj_3R_385() {
    if (jj_3R_124()) return true;
    return false;
  }

  private boolean jj_3R_62() {
    if (jj_scan_token(PROTECTED)) return true;
    return false;
  }

  private boolean jj_3R_61() {
    if (jj_scan_token(STATIC)) return true;
    return false;
  }

  private boolean jj_3R_60() {
    if (jj_scan_token(PUBLIC)) return true;
    return false;
  }

  private boolean jj_3_35() {
    if (jj_3R_104()) return true;
    if (jj_scan_token(DOT)) return true;
    if (jj_scan_token(CLASS)) return true;
    return false;
  }

  private boolean jj_3R_227() {
    if (jj_3R_76()) return true;
    return false;
  }

  private boolean jj_3R_226() {
    if (jj_3R_89()) return true;
    return false;
  }

  private boolean jj_3_54() {
    if (jj_scan_token(AT)) return true;
    return false;
  }

  private boolean jj_3R_384() {
    if (jj_3R_92()) return true;
    if (jj_scan_token(SEMICOLON)) return true;
    return false;
  }

  private boolean jj_3R_194() {
    if (jj_3R_105()) return true;
    if (jj_scan_token(DOUBLECOLON)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_226()) jj_scanpos = xsp;
    xsp = jj_scanpos;
    if (jj_3R_227()) {
    jj_scanpos = xsp;
    if (jj_scan_token(42)) return true;
    }
    return false;
  }

  private boolean jj_3_3() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_60()) {
    jj_scanpos = xsp;
    if (jj_3R_61()) {
    jj_scanpos = xsp;
    if (jj_3R_62()) {
    jj_scanpos = xsp;
    if (jj_3R_63()) {
    jj_scanpos = xsp;
    if (jj_3R_64()) {
    jj_scanpos = xsp;
    if (jj_3R_65()) {
    jj_scanpos = xsp;
    if (jj_3R_66()) {
    jj_scanpos = xsp;
    if (jj_3R_67()) {
    jj_scanpos = xsp;
    if (jj_3R_68()) {
    jj_scanpos = xsp;
    if (jj_3R_69()) {
    jj_scanpos = xsp;
    if (jj_3R_70()) {
    jj_scanpos = xsp;
    if (jj_3R_71()) {
    jj_scanpos = xsp;
    if (jj_3R_72()) {
    jj_scanpos = xsp;
    if (jj_3R_73()) return true;
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    return false;
  }

  private boolean jj_3R_262() {
    if (jj_scan_token(ARROW)) return true;
    if (jj_3R_333()) return true;
    return false;
  }

  private boolean jj_3R_178() {
    if (jj_3R_151()) return true;
    return false;
  }

  private boolean jj_3_11() {
    if (jj_3R_81()) return true;
    return false;
  }

  private boolean jj_3R_177() {
    if (jj_3R_215()) return true;
    return false;
  }

  private boolean jj_3R_376() {
    if (jj_scan_token(ARROW)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_384()) {
    jj_scanpos = xsp;
    if (jj_3R_385()) {
    jj_scanpos = xsp;
    if (jj_3R_386()) return true;
    }
    }
    return false;
  }

  private boolean jj_3_24() {
    if (jj_3R_91()) return true;
    if (jj_3R_92()) return true;
    return false;
  }

  private boolean jj_3_34() {
    if (jj_3R_103()) return true;
    if (jj_scan_token(COMMA)) return true;
    return false;
  }

  private boolean jj_3R_111() {
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3_3()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  private boolean jj_3R_193() {
    if (jj_3R_104()) return true;
    if (jj_scan_token(DOT)) return true;
    if (jj_scan_token(CLASS)) return true;
    return false;
  }

  private boolean jj_3R_176() {
    if (jj_3R_118()) return true;
    return false;
  }

  private boolean jj_3R_192() {
    if (jj_3R_225()) return true;
    return false;
  }

  private boolean jj_3R_375() {
    if (jj_scan_token(COLON)) return true;
    if (jj_3R_181()) return true;
    return false;
  }

  private boolean jj_3R_224() {
    if (jj_3R_92()) return true;
    if (jj_scan_token(RPAREN)) return true;
    return false;
  }

  private boolean jj_3R_439() {
    if (jj_scan_token(COMMA)) return true;
    if (jj_3R_102()) return true;
    return false;
  }

  private boolean jj_3R_438() {
    if (jj_3R_102()) return true;
    return false;
  }

  private boolean jj_3R_209() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3_24()) {
    jj_scanpos = xsp;
    if (jj_3R_262()) {
    jj_scanpos = xsp;
    if (jj_3R_263()) return true;
    }
    }
    return false;
  }

  private boolean jj_3_33() {
    if (jj_3R_102()) return true;
    return false;
  }

  private boolean jj_3R_117() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_176()) {
    jj_scanpos = xsp;
    if (jj_3R_177()) {
    jj_scanpos = xsp;
    if (jj_3R_178()) return true;
    }
    }
    return false;
  }

  private boolean jj_3R_383() {
    if (jj_scan_token(COMMA)) return true;
    if (jj_3R_151()) return true;
    return false;
  }

  private boolean jj_3R_374() {
    if (jj_scan_token(_DEFAULT)) return true;
    return false;
  }

  private boolean jj_3R_437() {
    if (jj_3R_81()) return true;
    return false;
  }

  private boolean jj_3R_223() {
    if (jj_3R_285()) return true;
    if (jj_scan_token(RPAREN)) return true;
    return false;
  }

  private boolean jj_3R_92() {
    if (jj_3R_151()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_209()) jj_scanpos = xsp;
    return false;
  }

  private boolean jj_3R_421() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_437()) {
    jj_scanpos = xsp;
    if (jj_3R_438()) return true;
    }
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_439()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  private boolean jj_3R_373() {
    if (jj_scan_token(CASE)) return true;
    if (jj_3R_151()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_383()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  private boolean jj_3R_222() {
    if (jj_3R_284()) return true;
    if (jj_scan_token(RPAREN)) return true;
    return false;
  }

  private boolean jj_3R_221() {
    if (jj_scan_token(RPAREN)) return true;
    return false;
  }

  private boolean jj_3R_409() {
    if (jj_scan_token(LPAREN)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_421()) jj_scanpos = xsp;
    if (jj_scan_token(RPAREN)) return true;
    return false;
  }

  private boolean jj_3R_356() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_373()) {
    jj_scanpos = xsp;
    if (jj_3R_374()) return true;
    }
    xsp = jj_scanpos;
    if (jj_3R_375()) {
    jj_scanpos = xsp;
    if (jj_3R_376()) return true;
    }
    return false;
  }

  private boolean jj_3R_191() {
    if (jj_scan_token(LPAREN)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_221()) {
    jj_scanpos = xsp;
    if (jj_3R_222()) {
    jj_scanpos = xsp;
    if (jj_3R_223()) {
    jj_scanpos = xsp;
    if (jj_3R_224()) return true;
    }
    }
    }
    return false;
  }

  private boolean jj_3R_282() {
    if (jj_3R_89()) return true;
    return false;
  }

  private boolean jj_3R_283() {
    if (jj_3R_76()) return true;
    return false;
  }

  private boolean jj_3R_220() {
    if (jj_scan_token(DOUBLECOLON)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_282()) jj_scanpos = xsp;
    xsp = jj_scanpos;
    if (jj_3R_283()) {
    jj_scanpos = xsp;
    if (jj_scan_token(42)) return true;
    }
    return false;
  }

  private boolean jj_3R_353() {
    if (jj_3R_90()) return true;
    if (jj_scan_token(ASSIGN)) return true;
    if (jj_3R_117()) return true;
    return false;
  }

  private boolean jj_3R_281() {
    if (jj_3R_185()) return true;
    return false;
  }

  private boolean jj_3R_280() {
    if (jj_3R_89()) return true;
    return false;
  }

  private boolean jj_3R_219() {
    if (jj_scan_token(DOT)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_280()) jj_scanpos = xsp;
    if (jj_3R_90()) return true;
    xsp = jj_scanpos;
    if (jj_3R_281()) jj_scanpos = xsp;
    return false;
  }

  private boolean jj_3R_190() {
    if (jj_scan_token(SUPER)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_219()) {
    jj_scanpos = xsp;
    if (jj_3R_220()) return true;
    }
    return false;
  }

  private boolean jj_3R_76() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(71)) {
    jj_scanpos = xsp;
    if (jj_scan_token(65)) {
    jj_scanpos = xsp;
    if (jj_scan_token(66)) {
    jj_scanpos = xsp;
    if (jj_scan_token(67)) {
    jj_scanpos = xsp;
    if (jj_scan_token(68)) {
    jj_scanpos = xsp;
    if (jj_scan_token(69)) {
    jj_scanpos = xsp;
    if (jj_scan_token(70)) {
    jj_scanpos = xsp;
    if (jj_scan_token(72)) {
    jj_scanpos = xsp;
    if (jj_scan_token(73)) {
    jj_scanpos = xsp;
    if (jj_scan_token(74)) {
    jj_scanpos = xsp;
    if (jj_scan_token(26)) {
    jj_scanpos = xsp;
    if (jj_scan_token(51)) {
    jj_scanpos = xsp;
    if (jj_scan_token(64)) {
    jj_scanpos = xsp;
    if (jj_scan_token(93)) return true;
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    return false;
  }

  private boolean jj_3R_189() {
    if (jj_scan_token(THIS)) return true;
    return false;
  }

  private boolean jj_3R_188() {
    if (jj_3R_218()) return true;
    return false;
  }

  private boolean jj_3R_332() {
    if (jj_3R_356()) return true;
    return false;
  }

  private boolean jj_3R_105() {
    if (jj_3R_88()) return true;
    if (jj_3R_77()) return true;
    return false;
  }

  private boolean jj_3R_130() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_188()) {
    jj_scanpos = xsp;
    if (jj_3R_189()) {
    jj_scanpos = xsp;
    if (jj_3R_190()) {
    jj_scanpos = xsp;
    if (jj_3R_191()) {
    jj_scanpos = xsp;
    if (jj_3R_192()) {
    jj_scanpos = xsp;
    if (jj_3R_193()) {
    jj_scanpos = xsp;
    if (jj_3R_194()) {
    jj_scanpos = xsp;
    if (jj_3R_195()) return true;
    }
    }
    }
    }
    }
    }
    }
    return false;
  }

  private boolean jj_3R_354() {
    if (jj_scan_token(COMMA)) return true;
    if (jj_3R_353()) return true;
    return false;
  }

  private boolean jj_3R_330() {
    if (jj_3R_353()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_354()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  private boolean jj_3R_309() {
    if (jj_scan_token(SWITCH)) return true;
    if (jj_scan_token(LPAREN)) return true;
    if (jj_3R_92()) return true;
    if (jj_scan_token(RPAREN)) return true;
    if (jj_scan_token(LBRACE)) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_332()) { jj_scanpos = xsp; break; }
    }
    if (jj_scan_token(RBRACE)) return true;
    return false;
  }

  private boolean jj_3_32() {
    if (jj_3R_101()) return true;
    return false;
  }

  private boolean jj_3R_253() {
    if (jj_3R_88()) return true;
    if (jj_3R_87()) return true;
    return false;
  }

  private boolean jj_3R_131() {
    if (jj_3R_101()) return true;
    return false;
  }

  private boolean jj_3_53() {
    if (jj_scan_token(LPAREN)) return true;
    return false;
  }

  private boolean jj_3R_116() {
    if (jj_3R_76()) return true;
    if (jj_scan_token(ASSIGN)) return true;
    return false;
  }

  private boolean jj_3R_415() {
    if (jj_3R_124()) return true;
    return false;
  }

  private boolean jj_3R_84() {
    if (jj_3R_130()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_131()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  private boolean jj_3R_249() {
    return false;
  }

  private boolean jj_3R_423() {
    if (jj_scan_token(COMMA)) return true;
    if (jj_3R_253()) return true;
    return false;
  }

  private boolean jj_3_52() {
    if (jj_scan_token(LPAREN)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_116()) {
    jj_scanpos = xsp;
    if (jj_scan_token(97)) return true;
    }
    return false;
  }

  private boolean jj_3R_59() {
    if (jj_3R_88()) return true;
    if (jj_scan_token(PACKAGE)) return true;
    if (jj_3R_82()) return true;
    if (jj_scan_token(SEMICOLON)) return true;
    return false;
  }

  private boolean jj_3R_414() {
    if (jj_scan_token(THROWS)) return true;
    if (jj_3R_253()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_423()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  private boolean jj_3R_90() {
    if (jj_3R_76()) return true;
    return false;
  }

  private boolean jj_3R_248() {
    if (jj_scan_token(LPAREN)) return true;
    if (jj_3R_117()) return true;
    if (jj_scan_token(RPAREN)) return true;
    return false;
  }

  private boolean jj_3R_413() {
    if (jj_3R_122()) return true;
    return false;
  }

  private boolean jj_3R_303() {
    if (jj_3R_330()) return true;
    return false;
  }

  private boolean jj_3_31() {
    if (jj_3R_100()) return true;
    return false;
  }

  private boolean jj_3R_214() {
    if (jj_3R_130()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3_31()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  private boolean jj_3R_247() {
    if (jj_scan_token(LPAREN)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_303()) jj_scanpos = xsp;
    if (jj_scan_token(RPAREN)) return true;
    return false;
  }

  private boolean jj_3R_378() {
    if (jj_3R_120()) return true;
    return false;
  }

  private boolean jj_3R_363() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_378()) jj_scanpos = xsp;
    if (jj_3R_88()) return true;
    if (jj_3R_104()) return true;
    if (jj_3R_90()) return true;
    if (jj_3R_409()) return true;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_413()) { jj_scanpos = xsp; break; }
    }
    xsp = jj_scanpos;
    if (jj_3R_414()) jj_scanpos = xsp;
    xsp = jj_scanpos;
    if (jj_3R_415()) {
    jj_scanpos = xsp;
    if (jj_scan_token(102)) return true;
    }
    return false;
  }

  private boolean jj_3R_426() {
    if (jj_3R_356()) return true;
    return false;
  }

  private boolean jj_3R_118() {
    if (jj_scan_token(AT)) return true;
    if (jj_3R_82()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_247()) {
    jj_scanpos = xsp;
    if (jj_3R_248()) {
    jj_scanpos = xsp;
    if (jj_3R_249()) return true;
    }
    }
    return false;
  }

  private boolean jj_3_23() {
    if (jj_scan_token(DOT)) return true;
    if (jj_3R_76()) return true;
    return false;
  }

  private boolean jj_3R_82() {
    if (jj_3R_76()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3_23()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  private boolean jj_3R_292() {
    if (jj_scan_token(SWITCH)) return true;
    if (jj_scan_token(LPAREN)) return true;
    if (jj_3R_92()) return true;
    if (jj_scan_token(RPAREN)) return true;
    if (jj_scan_token(LBRACE)) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_426()) { jj_scanpos = xsp; break; }
    }
    if (jj_scan_token(RBRACE)) return true;
    return false;
  }

  private boolean jj_3_2() {
    if (jj_3R_59()) return true;
    return false;
  }

  private boolean jj_3R_169() {
    if (jj_3R_77()) return true;
    return false;
  }

  private boolean jj_3_1() {
    if (jj_scan_token(SEMICOLON)) return true;
    return false;
  }

  private boolean jj_3R_168() {
    if (jj_scan_token(VOID)) return true;
    return false;
  }

  private boolean jj_3R_203() {
    if (jj_scan_token(BIT_AND)) return true;
    if (jj_3R_253()) return true;
    return false;
  }

  private boolean jj_3R_104() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_168()) {
    jj_scanpos = xsp;
    if (jj_3R_169()) return true;
    }
    return false;
  }

  private boolean jj_3_10() {
    if (jj_scan_token(COMMA)) return true;
    if (jj_3R_80()) return true;
    return false;
  }

  private boolean jj_3R_343() {
    if (jj_3R_80()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3_10()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  private boolean jj_3R_154() {
    if (jj_3R_87()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_203()) { jj_scanpos = xsp; break; }
    }
    if (jj_scan_token(RPAREN)) return true;
    if (jj_3R_204()) return true;
    return false;
  }

  private boolean jj_3R_182() {
    if (jj_scan_token(LBRACE)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_343()) jj_scanpos = xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(103)) jj_scanpos = xsp;
    if (jj_scan_token(RBRACE)) return true;
    return false;
  }

  private boolean jj_3_30() {
    if (jj_3R_99()) return true;
    if (jj_scan_token(RPAREN)) return true;
    if (jj_3R_172()) return true;
    return false;
  }

  private boolean jj_3R_162() {
    if (jj_scan_token(DOUBLE)) return true;
    return false;
  }

  private boolean jj_3R_370() {
    if (jj_3R_91()) return true;
    if (jj_3R_92()) return true;
    return false;
  }

  private boolean jj_3R_161() {
    if (jj_scan_token(FLOAT)) return true;
    return false;
  }

  private boolean jj_3R_369() {
    if (jj_scan_token(DECR)) return true;
    return false;
  }

  private boolean jj_3R_160() {
    if (jj_scan_token(LONG)) return true;
    return false;
  }

  private boolean jj_3_51() {
    if (jj_scan_token(AT)) return true;
    return false;
  }

  private boolean jj_3R_368() {
    if (jj_scan_token(INCR)) return true;
    return false;
  }

  private boolean jj_3R_351() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_368()) {
    jj_scanpos = xsp;
    if (jj_3R_369()) {
    jj_scanpos = xsp;
    if (jj_3R_370()) return true;
    }
    }
    return false;
  }

  private boolean jj_3R_159() {
    if (jj_scan_token(INT)) return true;
    return false;
  }

  private boolean jj_3R_96() {
    if (jj_scan_token(LPAREN)) return true;
    if (jj_3R_88()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3_30()) {
    jj_scanpos = xsp;
    if (jj_3R_154()) return true;
    }
    return false;
  }

  private boolean jj_3R_158() {
    if (jj_scan_token(SHORT)) return true;
    return false;
  }

  private boolean jj_3R_157() {
    if (jj_scan_token(BYTE)) return true;
    return false;
  }

  private boolean jj_3R_325() {
    if (jj_3R_214()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_351()) jj_scanpos = xsp;
    return false;
  }

  private boolean jj_3R_156() {
    if (jj_scan_token(CHAR)) return true;
    return false;
  }

  private boolean jj_3R_324() {
    if (jj_3R_264()) return true;
    return false;
  }

  private boolean jj_3R_155() {
    if (jj_scan_token(BOOLEAN)) return true;
    return false;
  }

  private boolean jj_3R_137() {
    if (jj_3R_118()) return true;
    return false;
  }

  private boolean jj_3_45() {
    if (jj_3R_113()) return true;
    return false;
  }

  private boolean jj_3R_99() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_155()) {
    jj_scanpos = xsp;
    if (jj_3R_156()) {
    jj_scanpos = xsp;
    if (jj_3R_157()) {
    jj_scanpos = xsp;
    if (jj_3R_158()) {
    jj_scanpos = xsp;
    if (jj_3R_159()) {
    jj_scanpos = xsp;
    if (jj_3R_160()) {
    jj_scanpos = xsp;
    if (jj_3R_161()) {
    jj_scanpos = xsp;
    if (jj_3R_162()) return true;
    }
    }
    }
    }
    }
    }
    }
    return false;
  }

  private boolean jj_3R_126() {
    if (jj_3R_92()) return true;
    return false;
  }

  private boolean jj_3R_88() {
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_137()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  private boolean jj_3R_291() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3_45()) {
    jj_scanpos = xsp;
    if (jj_3R_324()) {
    jj_scanpos = xsp;
    if (jj_3R_325()) return true;
    }
    }
    if (jj_scan_token(SEMICOLON)) return true;
    return false;
  }

  private boolean jj_3R_125() {
    if (jj_3R_182()) return true;
    return false;
  }

  private boolean jj_3R_80() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_125()) {
    jj_scanpos = xsp;
    if (jj_3R_126()) return true;
    }
    return false;
  }

  private boolean jj_3R_98() {
    if (jj_scan_token(DECR)) return true;
    return false;
  }

  private boolean jj_3R_97() {
    if (jj_scan_token(INCR)) return true;
    return false;
  }

  private boolean jj_3R_152() {
    return false;
  }

  private boolean jj_3R_358() {
    if (jj_3R_124()) return true;
    return false;
  }

  private boolean jj_3_29() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_97()) {
    jj_scanpos = xsp;
    if (jj_3R_98()) return true;
    }
    return false;
  }

  private boolean jj_3R_357() {
    if (jj_3R_92()) return true;
    return false;
  }

  private boolean jj_3R_153() {
    return false;
  }

  private boolean jj_3R_94() {
    jj_lookingAhead = true;
    jj_semLA = getToken(1).kind == GT && getToken(1).realKind == RSIGNEDSHIFT;
    jj_lookingAhead = false;
    if (!jj_semLA || jj_3R_152()) return true;
    if (jj_scan_token(GT)) return true;
    if (jj_scan_token(GT)) return true;
    return false;
  }

  private boolean jj_3R_308() {
    if (jj_3R_214()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3_29()) jj_scanpos = xsp;
    return false;
  }

  private boolean jj_3R_333() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_357()) {
    jj_scanpos = xsp;
    if (jj_3R_358()) return true;
    }
    return false;
  }

  private boolean jj_3R_367() {
    if (jj_scan_token(SUPER)) return true;
    if (jj_3R_88()) return true;
    if (jj_3R_87()) return true;
    return false;
  }

  private boolean jj_3R_167() {
    if (jj_3R_122()) return true;
    return false;
  }

  private boolean jj_3R_366() {
    if (jj_scan_token(EXTENDS)) return true;
    if (jj_3R_88()) return true;
    if (jj_3R_87()) return true;
    return false;
  }

  private boolean jj_3R_350() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_366()) {
    jj_scanpos = xsp;
    if (jj_3R_367()) return true;
    }
    return false;
  }

  private boolean jj_3R_95() {
    jj_lookingAhead = true;
    jj_semLA = getToken(1).kind == GT && getToken(1).realKind == RUNSIGNEDSHIFT;
    jj_lookingAhead = false;
    if (!jj_semLA || jj_3R_153()) return true;
    if (jj_scan_token(GT)) return true;
    if (jj_scan_token(GT)) return true;
    if (jj_scan_token(GT)) return true;
    return false;
  }

  private boolean jj_3R_103() {
    if (jj_3R_90()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_167()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  private boolean jj_3_28() {
    if (jj_3R_96()) return true;
    return false;
  }

  private boolean jj_3R_304() {
    if (jj_scan_token(HOOK)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_350()) jj_scanpos = xsp;
    return false;
  }

  private boolean jj_3_49() {
    if (jj_scan_token(SEMICOLON)) return true;
    if (jj_3R_114()) return true;
    return false;
  }

  private boolean jj_3R_257() {
    if (jj_3R_309()) return true;
    return false;
  }

  private boolean jj_3R_174() {
    if (jj_3R_214()) return true;
    return false;
  }

  private boolean jj_3R_290() {
    if (jj_scan_token(SEMICOLON)) return true;
    return false;
  }

  private boolean jj_3R_256() {
    if (jj_3R_308()) return true;
    return false;
  }

  private boolean jj_3_50() {
    if (jj_3R_111()) return true;
    if (jj_3R_77()) return true;
    if (jj_3R_115()) return true;
    return false;
  }

  private boolean jj_3R_307() {
    if (jj_scan_token(BANG)) return true;
    return false;
  }

  private boolean jj_3R_255() {
    if (jj_3R_96()) return true;
    return false;
  }

  private boolean jj_3R_306() {
    if (jj_scan_token(TILDE)) return true;
    return false;
  }

  private boolean jj_3R_173() {
    if (jj_3R_112()) return true;
    return false;
  }

  private boolean jj_3R_254() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_306()) {
    jj_scanpos = xsp;
    if (jj_3R_307()) return true;
    }
    if (jj_3R_172()) return true;
    return false;
  }

  private boolean jj_3R_114() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_173()) {
    jj_scanpos = xsp;
    if (jj_3R_174()) return true;
    }
    return false;
  }

  private boolean jj_3R_251() {
    if (jj_3R_304()) return true;
    return false;
  }

  private boolean jj_3R_250() {
    if (jj_3R_77()) return true;
    return false;
  }

  private boolean jj_3R_204() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_254()) {
    jj_scanpos = xsp;
    if (jj_3R_255()) {
    jj_scanpos = xsp;
    if (jj_3R_256()) {
    jj_scanpos = xsp;
    if (jj_3R_257()) return true;
    }
    }
    }
    return false;
  }

  private boolean jj_3R_171() {
    if (jj_scan_token(COMMA)) return true;
    if (jj_3R_115()) return true;
    return false;
  }

  private boolean jj_3R_201() {
    if (jj_3R_88()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_250()) {
    jj_scanpos = xsp;
    if (jj_3R_251()) return true;
    }
    return false;
  }

  private boolean jj_3R_112() {
    if (jj_3R_111()) return true;
    if (jj_3R_77()) return true;
    if (jj_3R_115()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_171()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  private boolean jj_3R_175() {
    if (jj_scan_token(ASSIGN)) return true;
    if (jj_3R_80()) return true;
    return false;
  }

  private boolean jj_3_44() {
    if (jj_3R_112()) return true;
    return false;
  }

  private boolean jj_3R_115() {
    if (jj_3R_103()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_175()) jj_scanpos = xsp;
    return false;
  }

  private boolean jj_3_43() {
    if (jj_3R_111()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(19)) {
    jj_scanpos = xsp;
    if (jj_scan_token(39)) return true;
    }
    return false;
  }

  private boolean jj_3R_134() {
    if (jj_3R_197()) return true;
    return false;
  }

  private boolean jj_3R_229() {
    if (jj_scan_token(COMMA)) return true;
    if (jj_3R_201()) return true;
    return false;
  }

  private boolean jj_3R_264() {
    if (jj_scan_token(DECR)) return true;
    if (jj_3R_172()) return true;
    return false;
  }

  private boolean jj_3R_133() {
    if (jj_3R_112()) return true;
    if (jj_scan_token(SEMICOLON)) return true;
    return false;
  }

  private boolean jj_3R_381() {
    if (jj_3R_114()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3_49()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  private boolean jj_3R_138() {
    if (jj_3R_201()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_229()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  private boolean jj_3R_132() {
    if (jj_3R_111()) return true;
    if (jj_3R_196()) return true;
    return false;
  }

  private boolean jj_3R_89() {
    if (jj_scan_token(LT)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_138()) jj_scanpos = xsp;
    if (jj_scan_token(GT)) return true;
    return false;
  }

  private boolean jj_3R_86() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_132()) {
    jj_scanpos = xsp;
    if (jj_3R_133()) {
    jj_scanpos = xsp;
    if (jj_3R_134()) return true;
    }
    }
    return false;
  }

  private boolean jj_3R_78() {
    if (jj_3R_122()) return true;
    return false;
  }

  private boolean jj_3R_412() {
    if (jj_scan_token(COMMA)) return true;
    if (jj_3R_115()) return true;
    return false;
  }

  private boolean jj_3R_113() {
    if (jj_scan_token(INCR)) return true;
    if (jj_3R_172()) return true;
    return false;
  }

  private boolean jj_3R_362() {
    if (jj_3R_77()) return true;
    if (jj_3R_115()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_412()) { jj_scanpos = xsp; break; }
    }
    if (jj_scan_token(SEMICOLON)) return true;
    return false;
  }

  private boolean jj_3_22() {
    if (jj_3R_89()) return true;
    return false;
  }

  private boolean jj_3R_213() {
    if (jj_3R_204()) return true;
    return false;
  }

  private boolean jj_3R_266() {
    if (jj_scan_token(MINUS)) return true;
    return false;
  }

  private boolean jj_3_21() {
    if (jj_scan_token(DOT)) return true;
    if (jj_3R_88()) return true;
    if (jj_3R_90()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3_22()) jj_scanpos = xsp;
    return false;
  }

  private boolean jj_3R_265() {
    if (jj_scan_token(PLUS)) return true;
    return false;
  }

  private boolean jj_3_48() {
    if (jj_scan_token(SEMICOLON)) return true;
    return false;
  }

  private boolean jj_3_8() {
    if (jj_3R_77()) return true;
    if (jj_3R_76()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_78()) { jj_scanpos = xsp; break; }
    }
    xsp = jj_scanpos;
    if (jj_scan_token(103)) {
    jj_scanpos = xsp;
    if (jj_scan_token(106)) {
    jj_scanpos = xsp;
    if (jj_scan_token(102)) return true;
    }
    }
    return false;
  }

  private boolean jj_3R_352() {
    if (jj_scan_token(LPAREN)) return true;
    if (jj_3R_381()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3_48()) jj_scanpos = xsp;
    if (jj_scan_token(RPAREN)) return true;
    return false;
  }

  private boolean jj_3R_75() {
    if (jj_3R_120()) return true;
    return false;
  }

  private boolean jj_3R_212() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_265()) {
    jj_scanpos = xsp;
    if (jj_3R_266()) return true;
    }
    if (jj_3R_172()) return true;
    return false;
  }

  private boolean jj_3_7() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_75()) jj_scanpos = xsp;
    if (jj_3R_76()) return true;
    if (jj_scan_token(LPAREN)) return true;
    return false;
  }

  private boolean jj_3_20() {
    if (jj_3R_89()) return true;
    return false;
  }

  private boolean jj_3R_211() {
    if (jj_3R_264()) return true;
    return false;
  }

  private boolean jj_3R_210() {
    if (jj_3R_113()) return true;
    return false;
  }

  private boolean jj_3_6() {
    if (jj_scan_token(AT)) return true;
    if (jj_scan_token(INTERFACE)) return true;
    return false;
  }

  private boolean jj_3R_199() {
    if (jj_3R_90()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3_20()) jj_scanpos = xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3_21()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  private boolean jj_3R_341() {
    if (jj_3R_363()) return true;
    return false;
  }

  private boolean jj_3_5() {
    if (jj_scan_token(ENUM)) return true;
    return false;
  }

  private boolean jj_3R_340() {
    if (jj_3R_362()) return true;
    return false;
  }

  private boolean jj_3R_172() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_210()) {
    jj_scanpos = xsp;
    if (jj_3R_211()) {
    jj_scanpos = xsp;
    if (jj_3R_212()) {
    jj_scanpos = xsp;
    if (jj_3R_213()) return true;
    }
    }
    }
    return false;
  }

  private boolean jj_3R_339() {
    if (jj_3R_361()) return true;
    return false;
  }

  private boolean jj_3R_338() {
    if (jj_3R_360()) return true;
    return false;
  }

  private boolean jj_3R_337() {
    if (jj_3R_359()) return true;
    return false;
  }

  private boolean jj_3R_336() {
    if (jj_3R_196()) return true;
    return false;
  }

  private boolean jj_3R_314() {
    if (jj_3R_88()) return true;
    if (jj_3R_199()) return true;
    return false;
  }

  private boolean jj_3R_310() {
    if (jj_3R_111()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_336()) {
    jj_scanpos = xsp;
    if (jj_3R_337()) {
    jj_scanpos = xsp;
    if (jj_3R_338()) {
    jj_scanpos = xsp;
    if (jj_3R_339()) {
    jj_scanpos = xsp;
    if (jj_3R_340()) {
    jj_scanpos = xsp;
    if (jj_3R_341()) return true;
    }
    }
    }
    }
    }
    return false;
  }

  private boolean jj_3R_124() {
    if (jj_scan_token(LBRACE)) return true;
    if (jj_3R_181()) return true;
    if (jj_scan_token(RBRACE)) return true;
    return false;
  }

  private boolean jj_3_9() {
    if (jj_3R_79()) return true;
    return false;
  }

  private boolean jj_3R_443() {
    if (jj_scan_token(FINALLY)) return true;
    if (jj_3R_124()) return true;
    return false;
  }

  private boolean jj_3R_429() {
    if (jj_scan_token(FINALLY)) return true;
    if (jj_3R_124()) return true;
    return false;
  }

  private boolean jj_3R_432() {
    if (jj_scan_token(REM)) return true;
    return false;
  }

  private boolean jj_3R_260() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3_9()) {
    jj_scanpos = xsp;
    if (jj_3R_310()) return true;
    }
    return false;
  }

  private boolean jj_3R_431() {
    if (jj_scan_token(SLASH)) return true;
    return false;
  }

  private boolean jj_3R_430() {
    if (jj_scan_token(STAR)) return true;
    return false;
  }

  private boolean jj_3R_416() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_430()) {
    jj_scanpos = xsp;
    if (jj_3R_431()) {
    jj_scanpos = xsp;
    if (jj_3R_432()) return true;
    }
    }
    if (jj_3R_172()) return true;
    return false;
  }

  private boolean jj_3R_446() {
    if (jj_scan_token(BIT_OR)) return true;
    if (jj_3R_253()) return true;
    return false;
  }

  private boolean jj_3R_399() {
    if (jj_3R_172()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_416()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  private boolean jj_3R_122() {
    if (jj_3R_88()) return true;
    if (jj_scan_token(LBRACKET)) return true;
    if (jj_scan_token(RBRACKET)) return true;
    return false;
  }

  private boolean jj_3R_109() {
    if (jj_3R_90()) return true;
    if (jj_scan_token(COLON)) return true;
    if (jj_3R_197()) return true;
    return false;
  }

  private boolean jj_3_19() {
    if (jj_3R_88()) return true;
    if (jj_scan_token(LBRACKET)) return true;
    return false;
  }

  private boolean jj_3R_442() {
    if (jj_scan_token(CATCH)) return true;
    if (jj_scan_token(LPAREN)) return true;
    if (jj_3R_111()) return true;
    if (jj_3R_87()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_446()) { jj_scanpos = xsp; break; }
    }
    if (jj_3R_103()) return true;
    if (jj_scan_token(RPAREN)) return true;
    if (jj_3R_124()) return true;
    return false;
  }

  private boolean jj_3_18() {
    if (jj_3R_88()) return true;
    if (jj_scan_token(LBRACKET)) return true;
    return false;
  }

  private boolean jj_3R_428() {
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_442()) { jj_scanpos = xsp; break; }
    }
    xsp = jj_scanpos;
    if (jj_3R_443()) jj_scanpos = xsp;
    return false;
  }

  private boolean jj_3R_200() {
    if (jj_3R_122()) return true;
    return false;
  }

  private boolean jj_3R_418() {
    if (jj_scan_token(MINUS)) return true;
    return false;
  }

  private boolean jj_3R_329() {
    if (jj_3R_352()) return true;
    return false;
  }

  private boolean jj_3R_417() {
    if (jj_scan_token(PLUS)) return true;
    return false;
  }

  private boolean jj_3R_302() {
    if (jj_scan_token(TRY)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_329()) jj_scanpos = xsp;
    if (jj_3R_124()) return true;
    xsp = jj_scanpos;
    if (jj_3R_428()) {
    jj_scanpos = xsp;
    if (jj_3R_429()) return true;
    }
    return false;
  }

  private boolean jj_3R_136() {
    if (jj_3R_199()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_200()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  private boolean jj_3R_198() {
    if (jj_3R_122()) return true;
    return false;
  }

  private boolean jj_3R_344() {
    if (jj_scan_token(COLON)) return true;
    if (jj_3R_92()) return true;
    return false;
  }

  private boolean jj_3R_404() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_417()) {
    jj_scanpos = xsp;
    if (jj_3R_418()) return true;
    }
    if (jj_3R_399()) return true;
    return false;
  }

  private boolean jj_3R_289() {
    if (jj_scan_token(ASSERT)) return true;
    if (jj_3R_92()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_344()) jj_scanpos = xsp;
    if (jj_scan_token(SEMICOLON)) return true;
    return false;
  }

  private boolean jj_3R_135() {
    if (jj_3R_99()) return true;
    Token xsp;
    if (jj_3R_198()) return true;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_198()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  private boolean jj_3R_170() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_208()) {
    jj_scanpos = xsp;
    if (jj_scan_token(102)) return true;
    }
    return false;
  }

  private boolean jj_3R_208() {
    if (jj_3R_260()) return true;
    return false;
  }

  private boolean jj_3R_397() {
    if (jj_3R_399()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_404()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  private boolean jj_3R_87() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_135()) {
    jj_scanpos = xsp;
    if (jj_3R_136()) return true;
    }
    return false;
  }

  private boolean jj_3R_107() {
    if (jj_scan_token(LBRACE)) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_170()) { jj_scanpos = xsp; break; }
    }
    if (jj_scan_token(RBRACE)) return true;
    return false;
  }

  private boolean jj_3R_246() {
    if (jj_3R_302()) return true;
    return false;
  }

  private boolean jj_3R_245() {
    if (jj_3R_301()) return true;
    return false;
  }

  private boolean jj_3R_244() {
    if (jj_3R_300()) return true;
    return false;
  }

  private boolean jj_3R_243() {
    if (jj_3R_299()) return true;
    return false;
  }

  private boolean jj_3_27() {
    if (jj_3R_95()) return true;
    return false;
  }

  private boolean jj_3R_242() {
    if (jj_3R_298()) return true;
    return false;
  }

  private boolean jj_3R_241() {
    if (jj_3R_297()) return true;
    return false;
  }

  private boolean jj_3_26() {
    if (jj_3R_94()) return true;
    return false;
  }

  private boolean jj_3R_240() {
    if (jj_3R_296()) return true;
    return false;
  }

  private boolean jj_3R_239() {
    if (jj_3R_295()) return true;
    return false;
  }

  private boolean jj_3R_93() {
    if (jj_scan_token(LSHIFT)) return true;
    return false;
  }

  private boolean jj_3R_238() {
    if (jj_3R_294()) return true;
    return false;
  }

  private boolean jj_3R_237() {
    if (jj_3R_293()) return true;
    return false;
  }

  private boolean jj_3R_236() {
    if (jj_3R_292()) return true;
    return false;
  }

  private boolean jj_3R_235() {
    if (jj_3R_291()) return true;
    return false;
  }

  private boolean jj_3R_234() {
    if (jj_3R_290()) return true;
    return false;
  }

  private boolean jj_3_25() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_93()) {
    jj_scanpos = xsp;
    if (jj_3_26()) {
    jj_scanpos = xsp;
    if (jj_3_27()) return true;
    }
    }
    if (jj_3R_397()) return true;
    return false;
  }

  private boolean jj_3R_233() {
    if (jj_3R_124()) return true;
    return false;
  }

  private boolean jj_3_42() {
    if (jj_3R_110()) return true;
    return false;
  }

  private boolean jj_3R_232() {
    if (jj_3R_289()) return true;
    return false;
  }

  private boolean jj_3_41() {
    if (jj_3R_109()) return true;
    return false;
  }

  private boolean jj_3R_393() {
    if (jj_3R_397()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3_25()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  private boolean jj_3R_121() {
    if (jj_3R_99()) return true;
    return false;
  }

  private boolean jj_3R_197() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3_41()) {
    jj_scanpos = xsp;
    if (jj_3R_232()) {
    jj_scanpos = xsp;
    if (jj_3_42()) {
    jj_scanpos = xsp;
    if (jj_3R_233()) {
    jj_scanpos = xsp;
    if (jj_3R_234()) {
    jj_scanpos = xsp;
    if (jj_3R_235()) {
    jj_scanpos = xsp;
    if (jj_3R_236()) {
    jj_scanpos = xsp;
    if (jj_3R_237()) {
    jj_scanpos = xsp;
    if (jj_3R_238()) {
    jj_scanpos = xsp;
    if (jj_3R_239()) {
    jj_scanpos = xsp;
    if (jj_3R_240()) {
    jj_scanpos = xsp;
    if (jj_3R_241()) {
    jj_scanpos = xsp;
    if (jj_3R_242()) {
    jj_scanpos = xsp;
    if (jj_3R_243()) {
    jj_scanpos = xsp;
    if (jj_3R_244()) {
    jj_scanpos = xsp;
    if (jj_3R_245()) {
    jj_scanpos = xsp;
    if (jj_3R_246()) return true;
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    return false;
  }

  private boolean jj_3R_315() {
    if (jj_scan_token(BIT_AND)) return true;
    if (jj_3R_314()) return true;
    return false;
  }

  private boolean jj_3_17() {
    if (jj_3R_87()) return true;
    return false;
  }

  private boolean jj_3R_301() {
    if (jj_scan_token(SYNCHRONIZED)) return true;
    if (jj_scan_token(LPAREN)) return true;
    if (jj_3R_92()) return true;
    if (jj_scan_token(RPAREN)) return true;
    if (jj_3R_124()) return true;
    return false;
  }

  private boolean jj_3R_77() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3_17()) {
    jj_scanpos = xsp;
    if (jj_3R_121()) return true;
    }
    return false;
  }

  private boolean jj_3R_270() {
    if (jj_scan_token(EXTENDS)) return true;
    if (jj_3R_314()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_315()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  private boolean jj_3R_403() {
    if (jj_scan_token(GE)) return true;
    return false;
  }

  private boolean jj_3R_402() {
    if (jj_scan_token(LE)) return true;
    return false;
  }

  private boolean jj_3R_401() {
    if (jj_scan_token(GT)) return true;
    return false;
  }

  private boolean jj_3R_400() {
    if (jj_scan_token(LT)) return true;
    return false;
  }

  private boolean jj_3R_398() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_400()) {
    jj_scanpos = xsp;
    if (jj_3R_401()) {
    jj_scanpos = xsp;
    if (jj_3R_402()) {
    jj_scanpos = xsp;
    if (jj_3R_403()) return true;
    }
    }
    }
    if (jj_3R_393()) return true;
    return false;
  }

  private boolean jj_3_59() {
    if (jj_3R_86()) return true;
    return false;
  }

  private boolean jj_3R_394() {
    if (jj_scan_token(INSTANCEOF)) return true;
    if (jj_3R_253()) return true;
    return false;
  }

  private boolean jj_3R_300() {
    if (jj_scan_token(THROW)) return true;
    if (jj_3R_92()) return true;
    if (jj_scan_token(SEMICOLON)) return true;
    return false;
  }

  private boolean jj_3R_390() {
    if (jj_3R_393()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_398()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  private boolean jj_3R_123() {
    if (jj_scan_token(STATIC)) return true;
    return false;
  }

  private boolean jj_3R_79() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_123()) jj_scanpos = xsp;
    if (jj_3R_124()) return true;
    return false;
  }

  private boolean jj_3R_216() {
    if (jj_3R_270()) return true;
    return false;
  }

  private boolean jj_3R_328() {
    if (jj_3R_92()) return true;
    return false;
  }

  private boolean jj_3R_179() {
    if (jj_3R_90()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_216()) jj_scanpos = xsp;
    return false;
  }

  private boolean jj_3R_108() {
    if (jj_3R_92()) return true;
    return false;
  }

  private boolean jj_3R_349() {
    if (jj_3R_182()) return true;
    return false;
  }

  private boolean jj_3R_299() {
    if (jj_scan_token(RETURN)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_328()) jj_scanpos = xsp;
    if (jj_scan_token(SEMICOLON)) return true;
    return false;
  }

  private boolean jj_3_40() {
    if (jj_3R_88()) return true;
    if (jj_scan_token(LBRACKET)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_108()) jj_scanpos = xsp;
    if (jj_scan_token(RBRACKET)) return true;
    return false;
  }

  private boolean jj_3_16() {
    if (jj_3R_86()) return true;
    return false;
  }

  private boolean jj_3R_382() {
    if (jj_3R_390()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_394()) jj_scanpos = xsp;
    return false;
  }

  private boolean jj_3R_321() {
    Token xsp;
    if (jj_3_40()) return true;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3_40()) { jj_scanpos = xsp; break; }
    }
    xsp = jj_scanpos;
    if (jj_3R_349()) jj_scanpos = xsp;
    return false;
  }

  private boolean jj_3R_181() {
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3_16()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  /** Generated Token Manager. */
  public GeneratedJavaParserTokenManager token_source;
  SimpleCharStream jj_input_stream;
  /** Current token. */
  public Token token;
  /** Next token. */
  public Token jj_nt;
  private int jj_ntk;
  private Token jj_scanpos, jj_lastpos;
  private int jj_la;
  /** Whether we are looking ahead. */
  private boolean jj_lookingAhead = false;
  private boolean jj_semLA;
  private int jj_gen;
  final private int[] jj_la1 = new int[170];
  static private int[] jj_la1_0;
  static private int[] jj_la1_1;
  static private int[] jj_la1_2;
  static private int[] jj_la1_3;
  static private int[] jj_la1_4;
  static {
      jj_la1_init_0();
      jj_la1_init_1();
      jj_la1_init_2();
      jj_la1_init_3();
      jj_la1_init_4();
   }
   private static void jj_la1_init_0() {
      jj_la1_0 = new int[] {0x24480800,0x4080000,0x24480800,0x1,0x0,0x0,0x20400800,0x80000,0x0,0x8000000,0x0,0x0,0x0,0x0,0x4000000,0x0,0xa54ca800,0xa54ca800,0x0,0x0,0x0,0x0,0x0,0x8000000,0x0,0xa54ca800,0xa54ca800,0x80000,0x8504a000,0xa54ca800,0x0,0x0,0x0,0x9504a000,0x9504a000,0x0,0x0,0x0,0x0,0x0,0x0,0xa544a800,0x0,0xa544a800,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x9504a000,0x0,0x8104a000,0x8504a000,0x8504a000,0x0,0x8504a000,0x8504a000,0x8000000,0x8000000,0x8104a000,0x8504a000,0x4000000,0x0,0x4000000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x9504a000,0x0,0x0,0x9504a000,0x0,0x0,0x8504a000,0x0,0x0,0x0,0x4000000,0x0,0x0,0x9504a000,0x0,0x4000000,0x0,0x10000000,0x4000000,0x0,0x0,0x0,0x0,0x0,0x10000000,0x10000000,0x9504a000,0x0,0x0,0x0,0x8504a000,0x9504a000,0x0,0x1000,0x95a4e000,0x0,0x95a4f000,0x0,0x9504a000,0x0,0x0,0x9504a000,0x410000,0x410000,0x0,0x410000,0x9504a000,0x0,0x2000000,0xb544a800,0x9504a000,0x9504a000,0xb544a800,0x9504a000,0x0,0x4000000,0x4000000,0x9504a000,0x0,0x20000,0x0,0x40000000,0x9504a000,0x4000000,0x0,0x9504a000,0x9504a000,0x0,0xa54ca800,0xa54ca800,0x80000,0x8504a000,0x400000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x9504a000,0x4080000,};
   }
   private static void jj_la1_init_1() {
      jj_la1_1 = new int[] {0x444ce290,0x80,0x444ce290,0x0,0x40000,0x0,0x444ce200,0x80,0x0,0x0,0x8,0x0,0x0,0x8,0x80000,0x0,0x644ee3c0,0x644ee3c0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x644ee3c0,0x644ee3c0,0x80,0x200a0140,0x644ee3c0,0x0,0x0,0x0,0x28ba0d40,0x28ba0d40,0x0,0x0,0x0,0x0,0x2000000,0x0,0x444ee340,0x0,0x444ee340,0x0,0x0,0x0,0x0,0x0,0x2000000,0x0,0x0,0x289a0d40,0x40000,0x20140,0xa0140,0xa0140,0x0,0xa0140,0xa0140,0x100000,0x100000,0x20140,0x200a0140,0x80000,0x0,0x80400,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x20,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x28ba0d40,0x0,0x0,0x28ba0d40,0x0,0x0,0xa0140,0x0,0x0,0x0,0x80400,0x0,0x0,0x28ba0d40,0x0,0x80400,0x0,0x8900c00,0x80000,0x0,0x0,0x0,0x800400,0x0,0x8000800,0x8000000,0x28ba0d40,0x0,0x0,0x0,0xa0140,0x28ba0d40,0x0,0x0,0xb9fb0d45,0x0,0xb9fb0d45,0x0,0x28ba0d40,0x0,0x0,0x289a0d40,0x0,0x0,0x0,0x0,0x29ba0d40,0x0,0x0,0x6cfeef40,0x28ba0d40,0x28ba0d40,0x6cfeef40,0x28ba0d40,0x0,0x80000,0x80000,0x28ba0d40,0x0,0x0,0x0,0x0,0x289a0d40,0x80000,0x0,0x28ba0d40,0x28ba0d40,0x0,0x444ee3c0,0x444ee3c0,0x80,0xa0140,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x289a0d40,0x80,};
   }
   private static void jj_la1_init_2() {
      jj_la1_2 = new int[] {0x490,0x90,0x490,0x0,0x0,0x0,0x400,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x200007ff,0x0,0x200007ff,0x200007ff,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x200007ff,0x200007ff,0x0,0x200007ff,0x200007ff,0x0,0x0,0x0,0x2b021fff,0x2b021fff,0x0,0x0,0x0,0x0,0x0,0x0,0x200007ff,0x0,0x200007ff,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x2b021fff,0x0,0x0,0x200007ff,0x200007ff,0x0,0x200007ff,0x200007ff,0x0,0x0,0x0,0x200007ff,0x200007ff,0x0,0x200007ff,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x2b021fff,0x0,0x0,0x2b021fff,0x0,0x0,0x200007ff,0x0,0x0,0x0,0x200007ff,0x0,0x0,0x2b021fff,0x0,0x200007ff,0x0,0xb021800,0x200007ff,0x0,0x0,0x0,0x0,0x0,0xb021800,0x0,0x2b021fff,0x0,0x0,0x0,0x200007ff,0x2b021fff,0x0,0x0,0x2b021fff,0x0,0x2b021fff,0x0,0x2b021fff,0x0,0x0,0x2b021fff,0x0,0x0,0x0,0x0,0x2b021fff,0x0,0x0,0x2b021fff,0x2b021fff,0x2b021fff,0x2b021fff,0x2b021fff,0x0,0x200007ff,0x200007ff,0x2b021fff,0x0,0x0,0x0,0x0,0x2b021fff,0x200007ff,0x0,0x2b021fff,0x2b021fff,0x0,0x200007ff,0x200007ff,0x0,0x200007ff,0x0,0x0,0x4,0x0,0x4,0x0,0x362,0x10,0x362,0x2b021fff,0x0,};
   }
   private static void jj_la1_init_3() {
      jj_la1_3 = new int[] {0x240,0x240,0x240,0x0,0x0,0x100,0x200,0x0,0x800,0x0,0x0,0x80,0x80,0x0,0x200,0x80,0xa44,0xa44,0x40,0x200,0x1,0x4,0x80,0x0,0x20000000,0xa44,0xa44,0x0,0xa00,0xa00,0x80,0x400,0x210,0x7803205,0x7803205,0x80,0x800,0x210,0x80,0x0,0x44,0x200,0x80,0x200,0x80,0x80,0x200,0x800,0x80,0x0,0x800,0x800,0xa01,0x0,0x0,0x0,0x200,0x80,0x4200,0x4000,0x0,0x0,0x0,0x0,0x0,0x800,0x0,0x10000,0x10400,0x400,0x4000,0x400000,0x200000,0x40000000,0x80000000,0x20000000,0x120000,0x120000,0x0,0xc0800,0xc0800,0x0,0x6000000,0x6000000,0x18000000,0x18000000,0x6000000,0x7803201,0x3000,0x3000,0x201,0x1800000,0x20000000,0x0,0x800,0x1,0x800,0x0,0x100,0x2,0x7803201,0x800,0x0,0x1,0x1,0x0,0x100,0x800,0x1,0x0,0x110,0x0,0x0,0x7803201,0x80,0x800,0x211,0x0,0x7803201,0x4,0x0,0x1800245,0x8000,0x1800245,0x80,0x7803205,0x1800400,0x1800400,0x1000201,0x0,0x0,0x80,0x0,0x7803205,0x18000,0x0,0x7803201,0x7803201,0x7803201,0x7803241,0x7803201,0x80,0x0,0x0,0x7803201,0x1,0x0,0x40000000,0x0,0x201,0x0,0x80,0x7803205,0x7803205,0x80,0x240,0x240,0x0,0x200,0x0,0x80,0x0,0x80,0x0,0x80,0x0,0x0,0x0,0xa01,0x200,};
   }
   private static void jj_la1_init_4() {
      jj_la1_4 = new int[] {0x0,0x0,0x0,0x40000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x2000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x4000,0x5ffc,0x1ffc,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x20000,0x20000,0x2,0x0,0x0,0x1,0x1,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x4000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1ffc,0x1ffc,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,};
   }
  final private JJCalls[] jj_2_rtns = new JJCalls[59];
  private boolean jj_rescan = false;
  private int jj_gc = 0;

  /** Constructor with InputStream. */
  public GeneratedJavaParser(java.io.InputStream stream) {
     this(stream, null);
  }
  /** Constructor with InputStream and supplied encoding */
  public GeneratedJavaParser(java.io.InputStream stream, String encoding) {
    try { jj_input_stream = new SimpleCharStream(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
    token_source = new GeneratedJavaParserTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 170; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  /** Reinitialise. */
  public void ReInit(java.io.InputStream stream) {
     ReInit(stream, null);
  }
  /** Reinitialise. */
  public void ReInit(java.io.InputStream stream, String encoding) {
    try { jj_input_stream.ReInit(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 170; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  /** Constructor. */
  public GeneratedJavaParser(java.io.Reader stream) {
    jj_input_stream = new SimpleCharStream(stream, 1, 1);
    token_source = new GeneratedJavaParserTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 170; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  /** Reinitialise. */
  public void ReInit(java.io.Reader stream) {
    jj_input_stream.ReInit(stream, 1, 1);
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 170; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  /** Constructor with generated Token Manager. */
  public GeneratedJavaParser(GeneratedJavaParserTokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 170; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  /** Reinitialise. */
  public void ReInit(GeneratedJavaParserTokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 170; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  private Token jj_consume_token(int kind) throws ParseException {
    Token oldToken;
    if ((oldToken = token).next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    if (token.kind == kind) {
      jj_gen++;
      if (++jj_gc > 100) {
        jj_gc = 0;
        for (int i = 0; i < jj_2_rtns.length; i++) {
          JJCalls c = jj_2_rtns[i];
          while (c != null) {
            if (c.gen < jj_gen) c.first = null;
            c = c.next;
          }
        }
      }
      return token;
    }
    token = oldToken;
    jj_kind = kind;
    throw generateParseException();
  }

  static private final class LookaheadSuccess extends java.lang.Error { }
  final private LookaheadSuccess jj_ls = new LookaheadSuccess();
  private boolean jj_scan_token(int kind) {
    if (jj_scanpos == jj_lastpos) {
      jj_la--;
      if (jj_scanpos.next == null) {
        jj_lastpos = jj_scanpos = jj_scanpos.next = token_source.getNextToken();
      } else {
        jj_lastpos = jj_scanpos = jj_scanpos.next;
      }
    } else {
      jj_scanpos = jj_scanpos.next;
    }
    if (jj_rescan) {
      int i = 0; Token tok = token;
      while (tok != null && tok != jj_scanpos) { i++; tok = tok.next; }
      if (tok != null) jj_add_error_token(kind, i);
    }
    if (jj_scanpos.kind != kind) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) throw jj_ls;
    return false;
  }


/** Get the next Token. */
  final public Token getNextToken() {
    if (token.next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    jj_gen++;
    return token;
  }

/** Get the specific Token. */
  final public Token getToken(int index) {
    Token t = jj_lookingAhead ? jj_scanpos : token;
    for (int i = 0; i < index; i++) {
      if (t.next != null) t = t.next;
      else t = t.next = token_source.getNextToken();
    }
    return t;
  }

  private int jj_ntk() {
    if ((jj_nt=token.next) == null)
      return (jj_ntk = (token.next=token_source.getNextToken()).kind);
    else
      return (jj_ntk = jj_nt.kind);
  }

  private java.util.List<int[]> jj_expentries = new java.util.ArrayList<int[]>();
  private int[] jj_expentry;
  private int jj_kind = -1;
  private int[] jj_lasttokens = new int[100];
  private int jj_endpos;

  private void jj_add_error_token(int kind, int pos) {
    if (pos >= 100) return;
    if (pos == jj_endpos + 1) {
      jj_lasttokens[jj_endpos++] = kind;
    } else if (jj_endpos != 0) {
      jj_expentry = new int[jj_endpos];
      for (int i = 0; i < jj_endpos; i++) {
        jj_expentry[i] = jj_lasttokens[i];
      }
      jj_entries_loop: for (java.util.Iterator<?> it = jj_expentries.iterator(); it.hasNext();) {
        int[] oldentry = (int[])(it.next());
        if (oldentry.length == jj_expentry.length) {
          for (int i = 0; i < jj_expentry.length; i++) {
            if (oldentry[i] != jj_expentry[i]) {
              continue jj_entries_loop;
            }
          }
          jj_expentries.add(jj_expentry);
          break jj_entries_loop;
        }
      }
      if (pos != 0) jj_lasttokens[(jj_endpos = pos) - 1] = kind;
    }
  }

  /** Generate ParseException. */
  public ParseException generateParseException() {
    jj_expentries.clear();
    boolean[] la1tokens = new boolean[147];
    if (jj_kind >= 0) {
      la1tokens[jj_kind] = true;
      jj_kind = -1;
    }
    for (int i = 0; i < 170; i++) {
      if (jj_la1[i] == jj_gen) {
        for (int j = 0; j < 32; j++) {
          if ((jj_la1_0[i] & (1<<j)) != 0) {
            la1tokens[j] = true;
          }
          if ((jj_la1_1[i] & (1<<j)) != 0) {
            la1tokens[32+j] = true;
          }
          if ((jj_la1_2[i] & (1<<j)) != 0) {
            la1tokens[64+j] = true;
          }
          if ((jj_la1_3[i] & (1<<j)) != 0) {
            la1tokens[96+j] = true;
          }
          if ((jj_la1_4[i] & (1<<j)) != 0) {
            la1tokens[128+j] = true;
          }
        }
      }
    }
    for (int i = 0; i < 147; i++) {
      if (la1tokens[i]) {
        jj_expentry = new int[1];
        jj_expentry[0] = i;
        jj_expentries.add(jj_expentry);
      }
    }
    jj_endpos = 0;
    jj_rescan_token();
    jj_add_error_token(0, 0);
    int[][] exptokseq = new int[jj_expentries.size()][];
    for (int i = 0; i < jj_expentries.size(); i++) {
      exptokseq[i] = jj_expentries.get(i);
    }
    return new ParseException(token, exptokseq, tokenImage);
  }

  /** Enable tracing. */
  final public void enable_tracing() {
  }

  /** Disable tracing. */
  final public void disable_tracing() {
  }

  private void jj_rescan_token() {
    jj_rescan = true;
    for (int i = 0; i < 59; i++) {
    try {
      JJCalls p = jj_2_rtns[i];
      do {
        if (p.gen > jj_gen) {
          jj_la = p.arg; jj_lastpos = jj_scanpos = p.first;
          switch (i) {
            case 0: jj_3_1(); break;
            case 1: jj_3_2(); break;
            case 2: jj_3_3(); break;
            case 3: jj_3_4(); break;
            case 4: jj_3_5(); break;
            case 5: jj_3_6(); break;
            case 6: jj_3_7(); break;
            case 7: jj_3_8(); break;
            case 8: jj_3_9(); break;
            case 9: jj_3_10(); break;
            case 10: jj_3_11(); break;
            case 11: jj_3_12(); break;
            case 12: jj_3_13(); break;
            case 13: jj_3_14(); break;
            case 14: jj_3_15(); break;
            case 15: jj_3_16(); break;
            case 16: jj_3_17(); break;
            case 17: jj_3_18(); break;
            case 18: jj_3_19(); break;
            case 19: jj_3_20(); break;
            case 20: jj_3_21(); break;
            case 21: jj_3_22(); break;
            case 22: jj_3_23(); break;
            case 23: jj_3_24(); break;
            case 24: jj_3_25(); break;
            case 25: jj_3_26(); break;
            case 26: jj_3_27(); break;
            case 27: jj_3_28(); break;
            case 28: jj_3_29(); break;
            case 29: jj_3_30(); break;
            case 30: jj_3_31(); break;
            case 31: jj_3_32(); break;
            case 32: jj_3_33(); break;
            case 33: jj_3_34(); break;
            case 34: jj_3_35(); break;
            case 35: jj_3_36(); break;
            case 36: jj_3_37(); break;
            case 37: jj_3_38(); break;
            case 38: jj_3_39(); break;
            case 39: jj_3_40(); break;
            case 40: jj_3_41(); break;
            case 41: jj_3_42(); break;
            case 42: jj_3_43(); break;
            case 43: jj_3_44(); break;
            case 44: jj_3_45(); break;
            case 45: jj_3_46(); break;
            case 46: jj_3_47(); break;
            case 47: jj_3_48(); break;
            case 48: jj_3_49(); break;
            case 49: jj_3_50(); break;
            case 50: jj_3_51(); break;
            case 51: jj_3_52(); break;
            case 52: jj_3_53(); break;
            case 53: jj_3_54(); break;
            case 54: jj_3_55(); break;
            case 55: jj_3_56(); break;
            case 56: jj_3_57(); break;
            case 57: jj_3_58(); break;
            case 58: jj_3_59(); break;
          }
        }
        p = p.next;
      } while (p != null);
      } catch(LookaheadSuccess ls) { }
    }
    jj_rescan = false;
  }

  private void jj_save(int index, int xla) {
    JJCalls p = jj_2_rtns[index];
    while (p.gen > jj_gen) {
      if (p.next == null) { p = p.next = new JJCalls(); break; }
      p = p.next;
    }
    p.gen = jj_gen + xla - jj_la; p.first = token; p.arg = xla;
  }

  static final class JJCalls {
    int gen;
    Token first;
    int arg;
    JJCalls next;
  }

}
