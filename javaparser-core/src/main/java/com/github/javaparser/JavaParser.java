/*
 * Copyright (C) 2007-2010 Júlio Vilmar Gesser.
 * Copyright (C) 2011, 2013-2015 The JavaParser Team.
 *
 * This file is part of JavaParser.
 *
 * JavaParser is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * JavaParser is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with JavaParser.  If not, see <http://www.gnu.org/licenses/>.
 */

package com.github.javaparser;

import com.github.javaparser.ast.CompilationUnit;
import com.github.javaparser.ast.ImportDeclaration;
import com.github.javaparser.ast.body.BodyDeclaration;
import com.github.javaparser.ast.expr.AnnotationExpr;
import com.github.javaparser.ast.expr.Expression;
import com.github.javaparser.ast.stmt.BlockStmt;
import com.github.javaparser.ast.stmt.Statement;
import com.github.javaparser.parser.Parser;

import java.io.*;

// FIXME this file does not seem to be generated by javacc. Is the doc wrong, or the javacc config?
/**
 * <p>
 * This class was generated automatically by javacc, do not edit.
 * </p>
 * <p>
 * Parse Java 1.5 source code and creates Abstract Syntax Tree classes.
 * </p>
 *
 * @author Júlio Vilmar Gesser
 */
public final class JavaParser {
    private JavaParser() {
        // hide the constructor
    }

    private static boolean _doNotAssignCommentsPreceedingEmptyLines = true;

    private static boolean _doNotConsiderAnnotationsAsNodeStartForCodeAttribution = false;

    public static boolean getDoNotConsiderAnnotationsAsNodeStartForCodeAttribution()
    {
        return _doNotConsiderAnnotationsAsNodeStartForCodeAttribution;
    }

    public static void setDoNotConsiderAnnotationsAsNodeStartForCodeAttribution(boolean doNotConsiderAnnotationsAsNodeStartForCodeAttribution) {
        _doNotConsiderAnnotationsAsNodeStartForCodeAttribution = doNotConsiderAnnotationsAsNodeStartForCodeAttribution;
    }

    public static boolean getDoNotAssignCommentsPreceedingEmptyLines()
    {
        return _doNotAssignCommentsPreceedingEmptyLines;
    }

    public static void setDoNotAssignCommentsPreceedingEmptyLines(boolean doNotAssignCommentsPreceedingEmptyLines)
    {
        _doNotAssignCommentsPreceedingEmptyLines = doNotAssignCommentsPreceedingEmptyLines;
    }

    public static CompilationUnit parse(final InputStream in,
                                        final String encoding)
            throws ParseException, IOException {
        return parse(in, encoding, true, true);
    }

    /**
     * Parses the Java code contained in the {@link InputStream} and returns a
     * {@link CompilationUnit} that represents it.
     *
     * @param in
     *            {@link InputStream} containing Java source code
     * @param encoding
     *            encoding of the source code
     * @return CompilationUnit representing the Java source code
     * @throws ParseException
     *             if the source code has parser errors
     */
    public static CompilationUnit parse(final InputStream in,
                                        final String encoding,
                                        boolean attributeComments,
                                        boolean preserveLexemes)
            throws ParseException, IOException {
        try {
            return Parser.newInstance(in, encoding, attributeComments, preserveLexemes).CompilationUnit();
        } catch (com.github.javaparser.parser.ParseException e) {
            throw convertParseException(e);
        } finally {
            in.close();
        }
    }

    /**
     * Parses the Java code contained in the {@link InputStream} and returns a
     * {@link CompilationUnit} that represents it.
     *
     * @param in
     *            {@link InputStream} containing Java source code
     * @return CompilationUnit representing the Java source code
     * @throws ParseException
     *             if the source code has parser errors
     */
    public static CompilationUnit parse(final InputStream in)
            throws ParseException, IOException {
        return parse(in, null, true, true);
    }

    public static CompilationUnit parse(final File file,
                                        final String encoding)
            throws ParseException, IOException {
        return parse(file, encoding, true, true);
    }

    /**
     * Parses the Java code contained in a {@link File} and returns a
     * {@link CompilationUnit} that represents it.
     *
     * @param file
     *            {@link File} containing Java source code
     * @param encoding
     *            encoding of the source code
     * @return CompilationUnit representing the Java source code
     * @throws ParseException
     *             if the source code has parser errors
     * @throws IOException
     */
    public static CompilationUnit parse(final File file,
                                        final String encoding,
                                        boolean attributeComments)
            throws ParseException, IOException {
        return parse(file, encoding, attributeComments, true);
    }

	public static CompilationUnit parse(final File file,
                                        final String encoding,
                                        boolean attributeComments,
                                        boolean preserveLexemes)
			throws ParseException, IOException {
		final FileInputStream in = new FileInputStream(file);
		try {
			return parse(in, encoding, attributeComments, preserveLexemes);
		} finally {
			in.close();
		}
	}

    /**
     * Parses the Java code contained in a {@link File} and returns a
     * {@link CompilationUnit} that represents it.
     *
     * @param file
     *            {@link File} containing Java source code
     * @return CompilationUnit representing the Java source code
     * @throws ParseException
     *             if the source code has parser errors
     * @throws IOException
     */
    public static CompilationUnit parse(final File file)
            throws ParseException, IOException {
        return parse(file, null, true, true);
    }

	public static CompilationUnit parse(final Reader reader,
                                        boolean attributeComments,
                                        boolean preserveLexemes)
            throws ParseException, IOException {
        try {
            return Parser.newInstance(reader, attributeComments, preserveLexemes).CompilationUnit();
        } catch (com.github.javaparser.parser.ParseException e) {
            throw convertParseException(e);
        } finally {
            reader.close();
        }
    }

    /**
     * Parses the Java block contained in a {@link String} and returns a
     * {@link BlockStmt} that represents it.
     *
     * @param blockStatement
     *            {@link String} containing Java block code
     * @return BlockStmt representing the Java block
     * @throws ParseException
     *             if the source code has parser errors
     */
    public static BlockStmt parseBlock(final String blockStatement) throws ParseException {
        StringReader sr = new StringReader(blockStatement);
        try {
            return Parser.newInstance(sr, true, true).Block();
        } catch (com.github.javaparser.parser.ParseException e) {
            throw convertParseException(e);
        } finally {
            sr.close();
        }
    }

    /**
     * Parses the Java statement contained in a {@link String} and returns a
     * {@link Statement} that represents it.
     *
     * @param statement
     *            {@link String} containing Java statement code
     * @return Statement representing the Java statement
     * @throws ParseException
     *             if the source code has parser errors
     */
    public static Statement parseStatement(final String statement) throws ParseException {
        StringReader sr = new StringReader(statement);
        try {
            return Parser.newInstance(sr, true, true).Statement();
        } catch (com.github.javaparser.parser.ParseException e) {
            throw convertParseException(e);
        } finally {
            sr.close();
        }
    }

    /**
     * Parses the Java import contained in a {@link String} and returns a
     * {@link ImportDeclaration} that represents it.
     *
     * @param importDeclaration
     *            {@link String} containing Java import code
     * @return ImportDeclaration representing the Java import declaration
     * @throws ParseException
     *             if the source code has parser errors
     */
    public static ImportDeclaration parseImport(final String importDeclaration) throws ParseException {
        StringReader sr = new StringReader(importDeclaration);
        try {
            return Parser.newInstance(sr, true, true).ImportDeclaration();
        } catch (com.github.javaparser.parser.ParseException e) {
            throw convertParseException(e);
        } finally {
            sr.close();
        }
    }

    /**
     * Parses the Java expression contained in a {@link String} and returns a
     * {@link Expression} that represents it.
     *
     * @param expression
     *            {@link String} containing Java expression
     * @return Expression representing the Java expression
     * @throws ParseException
     *             if the source code has parser errors
     */
    public static Expression parseExpression(final String expression) throws ParseException {
        StringReader sr = new StringReader(expression);
        try {
            return Parser.newInstance(sr, true, true).Expression();
        } catch (com.github.javaparser.parser.ParseException e) {
            throw convertParseException(e);
        } finally {
            sr.close();
        }
    }

    /**
     * Parses the Java annotation contained in a {@link String} and returns a
     * {@link AnnotationExpr} that represents it.
     *
     * @param annotation
     *            {@link String} containing Java annotation
     * @return AnnotationExpr representing the Java annotation
     * @throws ParseException
     *             if the source code has parser errors
     */
    public static AnnotationExpr parseAnnotation(final String annotation) throws ParseException {
        StringReader sr = new StringReader(annotation);
        try {
            return Parser.newInstance(sr, true, true).Annotation();
        } catch (com.github.javaparser.parser.ParseException e) {
            throw convertParseException(e);
        } finally {
            sr.close();
        }
    }

    /**
     * Parses the Java body declaration(e.g fields or methods) contained in a
     * {@link String} and returns a {@link BodyDeclaration} that represents it.
     *
     * @param body
     *            {@link String} containing Java body declaration
     * @return BodyDeclaration representing the Java annotation
     * @throws ParseException
     *             if the source code has parser errors
     */
    public static BodyDeclaration parseBodyDeclaration(final String body) throws ParseException {
        StringReader sr = new StringReader(body);
        try {
            return Parser.newInstance(sr, true, true).AnnotationBodyDeclaration();
        } catch (com.github.javaparser.parser.ParseException e) {
            throw convertParseException(e);
        } finally {
            sr.close();
        }
    }

    private static ParseException convertParseException(com.github.javaparser.parser.ParseException e)
            throws ParseException {
        return new ParseException(e.getMessage());
    }
}
